[ { "title": "iOS Swfit UIKit UICollectionView", "url": "/posts/iOS-UiKit-UICollectionView/", "categories": "Swift, UIKit", "tags": "iOS, UIKit, UITabBarController, UITabBar", "date": "2023-02-27 21:30:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 iOS UIKit UICollectionView에 대하여 알아보도록 하겠습니다.🦋 UICollectionView 데이터 항목의 정렬된 Collection을 관리하고, Cutom한 Layout을 사용해 표시하는 객체 List, Slide 등 다양한 형태로 표현 가능🌸 UICollectionView 구성 요소 Supplementary View, Cell, Decoration View로 구성되어 있음 Supplementary View 👉 Section에 대한 정보를 표시 (Header, Footer라고 생각하면 됨, 필수 구현 x) Cell 👉 CollectionView의 Content 표시 Decoration View 👉 CollectionView에 대한 배경을 꾸밀 때 사용🌸 UICollectionViewFlowLayout 1️⃣ Flow Layout 객체를 작성하고 Collection View에 이를 할당한다. 2️⃣ Cell의 width, height를 정한다. 3️⃣ 필요한 경우 Cell들 간의 좌우 최소 간격, 위아래 최소 간격을 설정한다. 4️⃣ Section에 Header와 Footer가 있다면 이것들의 크기를 지정한다. 5️⃣ Layout의 Scroll 방향을 설정한다.🌸 UICollectionViewDataSource Collection View로 보여지는 Content들을 관리하는 객체 Collection View의 Content(데이터)를 관리하고 해당 Content를 표현하는 데 필요한 View 참고 👇 func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int 👉 지정된 섹션에 표시할 항목의 개수를 묻는 메서드 func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell 👉 컬렉션뷰의 지정된 위치에 표시할 셀을 요청하는 메서드. optional func numberOfSections(in collectionView: UICollectionView) -&gt; Int 👉 컬렉션뷰의 섹션의 개수를 묻는 메서드. 이 메서드를 구현하지 않으면 섹션 개수 기본 값은 1. optional func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -&gt; Bool 👉 지정된 위치의 항목을 컬렉션뷰의 다른 위치로 이동할 수 있는지를 묻는 메서드. optional func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) 👉 지정된 위치의 항목을 다른 위치로 이동하도록 지시하는 메서드 🌸 UICollectionViewDelegate Content의 표현, 사용자와의 상호작용과 관련된 것들을 관리하는 객체 셀의 선택 및 강조표시를 관리하고 해당 셀에 대한 작업을 수행할 수 있는 메서드를 정의 필수로 구현하지 않아도 상관없음 참고 👇 optional func collectionView(_ collectionView: UICollectionView, shouldSelectItemAt indexPath: IndexPath) -&gt; Bool 👉 지정된 셀이 사용자에 의해 선택될 수 있는지 묻는 메서드. optional func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) 👉 지정된 셀이 선택되었음을 알리는 메서드. optional func collectionView(_ collectionView: UICollectionView, shouldDeselectItemAt indexPath: IndexPath) -&gt; Bool 👉 지정된 셀의 선택이 해제될 수 있는지 묻는 메서드. 선택 해제가 가능한 경우 true로 응답하며, 그렇지 않다면 false로 응답. optional func collectionView(_ collectionView: UICollectionView, didDeselectItemAt indexPath: IndexPath) 👉 지정된 셀의 선택이 해제되었음을 알리는 메서드. optional func collectionView(_ collectionView: UICollectionView, shouldHighlightItemAt indexPath: IndexPath) -&gt; Bool 👉 지정된 셀이 강조될 수 있는지 묻는 메서드. 강조해야 하는 경우 true로 응답하며, 그렇지 않다면 false로 응답. optional func collectionView(_ collectionView: UICollectionView, didHighlightItemAt indexPath: IndexPath) 👉 지정된 셀이 강조되었을 때 알려주는 메서드. optional func collectionView(_ collectionView: UICollectionView, didUnhighlightItemAt indexPath: IndexPath) 👉 지정된 셀이 강조가 해제될 때 알려주는 메서드. " }, { "title": "iOS Swfit UIKit UITabBarController", "url": "/posts/iOS-UiKit-UITabBarController/", "categories": "Swift, UIKit", "tags": "iOS, UIKit, UITabBarController, UITabBar", "date": "2023-02-27 21:20:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 iOS UIKit UITabBarController, UITabBar에 대하여 알아보도록 하겠습니다.🦋 UITabBarController 다중 선택 인터페이스를 관리하는 ContainerViewController로 선택에 따라 어떤 자식 ViewController를 보여줄 것인지가 결정됨 UIViewController를 상속받음🌸 UITabBar 앱에서 서로 다른 하위작업, View, 모드 사이의 선택을 할 수 있도록, TabBar에 하나 혹은 하나 이상의 버튼을 보여주는 Controll 항상 스크린 하단에 나타남 하나 혹은 하나 이상의 UITabBarItem으로 구성되어 있음 Android 로 치면 BottomNavigationView" }, { "title": "iOS Swfit UIKit UITableView", "url": "/posts/iOS-UiKit-TableView/", "categories": "Swift, UIKit", "tags": "iOS, UIKit, UITableView", "date": "2023-02-27 18:20:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 iOS UIKit UITableView에 대하여 알아보도록 하겠습니다.🦋 UITableView 여러 개의 Cell을 가지고 있고, 하나의 열과 여러 줄의 행을 지니고 있으며, 수직 으로만 Scroll이 가능 Section을 이용해 행을 그룹화하여 Content를 좀 더 쉽게 탐색할 수 있음 Section의 Header와 Footer에 View를 구성하여 추가적인 정보를 표시할 수 있음🌸 UITableViewDelegate TableView의 시각적인 부분을 설정하고, 행의 Action 관리, 엑세서리 View 지원 그리고 TableView의 개별 행 편집을 도와 줌 TableView의 동작과 외관을 담당 View 가 변경되는 상황을 Delegate가 담당 행의 높이, 행을 선택하면 어떤 Action을 할건지 정의 참고 👇 optional func tableView(UITableView, heightForRowAt: IndexPath) 👉 특정 위치 행의 높이를 묻는 메서드 optional func tableView(UITableView, indentationLevelForRowAt: IndexPath) 👉 특정 위치 행의 들여쓰기 수준을 묻는 메서드 optional func tableView(UITableView, didSelectRowAt: IndexPath) 👉 지정된 행이 선택되었음을 알리는 메서드 optional func tableView(UITableView, didDeselectRowAt: IndexPath) 👉 지정된 행의 선택이 해제되었음을 알리는 메서드 optional func tableView(UITableView, viewForHeaderInSection: Int) 👉 특정 Section의 HeaderView 를 요청하는 메서드 optional func tableView(UITableView, viewForFooterInSection: Int) 👉 특정 Section의 FooterView 를 요청하는 메서드 optional func tableView(UITableView, heightForHeaderInSection: Int) 👉 특정 Section의 HeaderView의 높이를 물어보는 메서드 optional func tableView(UITableView, heightForFooterInSection: Int) 👉 특정 Section의 FooterView의 높이를 물어보는 메서드 optional func tableView(UITableView, willBeginEditingRowAt: IndexPath) 👉 TableView가 편집모드에 들어갔음을 알리는 메서드 optional func tableView(UITableView, didEndEditingRowAt: IndexPath?) 👉 TableView가 편집모드에서 빠져나왔음을 알리는 메서드 🌸 UITableViewDataSource TableView를 생성하고 수정하는데 필요한 정보를 TableView 객체에 제공 data를 받아 View를 그려주는 역할을 담당 총 Section의 개수, Section의 행의 개수, Section에 어떤 정보를 표시할 것 인지 정의 참고 👇 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 👉 각 Settion애 표시할 행의 개수를 묻는 메서드 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 👉 특정 Index Row의 Cell에 대한 정보를 넣어 Cell을 반환하는 메서드 optional func numberOfSections(in tableView: UITableView) -&gt; Int 👉 총 Section 개수를 묻는 메서드 optional func tableView(UITableView, titleForHeaderInSection: Int) -&gt; String? 👉 특정 Section의 Header Title을 묻는 메서드 optional func tableView(UITableView, titleForFooterInSection: Int) -&gt; String? 👉 특정 Section의 Footer Title을 묻는 메서드 optional func tableView(UITableView, canEditRowAt: IndexPath) -&gt; Bool 👉 특정 위치의 행이 편집 가능한지 묻는 메서드 optional func tableView(UITableView, canMoveRowAt: IndexPath) -&gt; Bool 👉 특정 위치의 행을 재정렬 할 수 있는지 묻는 메서드 optional func sectionIndexTitles(for tableView: UITableView) -&gt; [String]? 👉 TableView Section Index Title을 묻는 메서드 optional func tableView(UITableView, sectionForSectionIndexTitle: String, at: Int) -&gt; Int 👉 Index에 해당하는 Section을 알려주는 메서드 optional func tableView(UITableView, commit: UITableViewCell.EditingStyle, forRowAt: IndexPath) 👉 스와이프 모드, 편집 모드에서 버튼을 선택하면 호출되는 메서드, 해당 메서드에서는 행에 변경사항을 Commit 해야함 optional func tableView(UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) 👉 행이 다른 위치로 이동되면 어디에서 어디로 이동했는지 알려주는 메서드 " }, { "title": "React-Native Dimensions Window / Screen 차이점", "url": "/posts/React-Native-Dimensions-Window-Screen/", "categories": "React-Native, View", "tags": "react-native, dimensions, window, screen", "date": "2022-12-19 17:30:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 React-Native에서 모바일 기기의 해상도를 가져올 수 있는 API인 Dimensions에 대하여 알아보도록 하겠습니다.🍀 Window / Screen 차이점 Dimensions는 기본적으로 현재 기기의 화면 크기를 알기위해 사용 iOS에서는 window와 screen둘 중 어떤 것을 쓰더라도 동일 하게 작동 Android에서는 최상단 statusBar에서 차이가 남 👇☘️ Window 위에 보이는 그림 1의 빨간색으로 표시된(statusBar) 부분을 포함하지 않고 영역을 추출const width = Dimensions.get(\"window\").width;☘️ Screen 위에 보이는 그림 1의 빨간색으로 표시된(statusBar) 부분을 포함하고 영역을 추출const height = Dimensions.get(\"screen\").height;" }, { "title": "JavaScript 비동기 작업 Promise, async, await 알아보기", "url": "/posts/Javascript-Promise-Async-Await/", "categories": "React-Native, JavaScript", "tags": "javasciprt, async, await, promise", "date": "2022-12-09 17:19:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 JavaScript에서 비동기 처리에 사용되는 promise, async, await에 대하여 알아보도록 하겠습니다.🍀 Promise 비동기 작업의 단위 new Promise를 사용하여 생성 첫 번째 인수 resolve 👇 비동기 작업이 성공했을 경우 호출됨 두 번째 인수 reject 비동기 작업이 실패했을 경우 호출됨 ✅ new Promise(...)의 인스턴스를 생성하는 순간 여기에 할당된 비동기 작업은 바로 실행됨 즉, new Promise를 하는 순간 비동기 작업이 시작 then 👉 해당 Promise가 성공했을 때의 동작을 지정, 함수를 받음 chatch 👉 해당 Promise가 실패했을 때의 동작을 지정, 함수를 받음 예제👇 const promise1 = new Promise((resolve, reject) =&gt; { resolve();});promise .then(() =&gt; { console.log(\"then!\"); }) .catch(() =&gt; { console.log(\"catch!\"); }); ✅ 재사용 👉 비동기 작업이 있을때 마다 new Promise를 할 필요 없이 return에 new Promise를 하게되면 재사용이 가능함 예제 ) 재사용 👇 function startAsync(age) { return new Promise((resolve, reject) =&gt; { if (age &gt; 20) resolve(); else reject(); });}const promise1 = startAsync(25);promise1 .then(() =&gt; { console.log(\"1 then!\"); }) .catch(() =&gt; { console.log(\"1 catch!\"); });const promise2 = startAsync(15);promise2 .then(() =&gt; { console.log(\"2 then!\"); }) .catch(() =&gt; { console.log(\"2 then!\"); }); ✅ 작업 결과 전달 👉 resolve, reject함수에 인자를 전달함으로써 then 및 catch함수에서 비동기 작업으로부터 정보를 얻을 수 있음 예제 ) 작업 결과 전달 👇 function startAsync(age) { return new Promise((resolve, reject) =&gt; { if (age &gt; 20) resolve(`${age} success`); else reject(new Error(`${age} is not over 20`)); });}const promise1 = startAsync(25);promise1 .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.error(error); });const promise2 = startAsync(15);promise2 .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.error(error); }); 🍀 Async 비동기 작업을 만드는 손쉬운 방법 함수앞에 async 키워드를 붙힘 ✅ async함수의 return값은 무조건 Promise 예제 new Promise를 async로 변경 👇 async function startAsync(age) { if (age &gt; 20) return `${age} success`; else throw new Error(`${age} is not over 20`);}const promise1 = startAsync(25);promise1 .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.error(error); });const promise2 = startAsync(15);promise2 .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.error(error); }); 🍀 Await ✅ Promise가 끝날 때까지 기다림 Promise가 resolve되든지 reject되든지 끝날 때까지 기다리는 함수 await는 async 함수 내부에서만 사용할 수 있음 예제 👇 function setTimeoutPromise(delay) { return new Promise((resolve) =&gt; setTimeout(resolve, delay));}async function startAsync(age) { if (age &gt; 20) return `${age} success`; else throw new Error(`${age} is not over 20`);}async function startAsyncJobs() { await setTimeoutPromise(1000); const promise1 = startAsync(25); try { const value = await promise1; console.log(value); } catch (e) { console.error(e); } const promise2 = startAsync(15); try { const value = await promise2; console.log(value); } catch (e) { console.error(e); }}startAsyncJobs(); " }, { "title": "iOS SwiftUi Alamofire 기초", "url": "/posts/iOS-Swift-Alamofire/", "categories": "Swift, Alamofire", "tags": "iOS, Alamofire", "date": "2022-12-02 10:59:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift에서 http 통신을 하기 위해 사용하는 Alamofire에 대하여 알아보도록 하겠습니다.🍀 Alamofire URLSession 에서 불편한 점을 한번더 보완한 라이브러리 URLSession을 기반으로 하여 어려운 네트워킹 작업을 감춰주기 때문에 주요 로직에 집중할 수 있게 해줌 GET, POST, Download, DELETE, PATCH 등 다양한 Http 통신을 지원 ✅ 즉, Alamofire는 HTTP네트워킹을 하는데 자주 사용하게 되는 코드나 함수를 더 쉽게 사용할 수 있도록 모아놓은 것 ℹ️ Github URL 👍 대표적인 기능 AF.upload 👉 파일을 업로드함 AF.download 👉 파일을 다운로드 하거나 이미 진행중인 다운로드를 재개함 AF.request 👉 파일 전송과 무관한 다른 HTTP 요청 ☘️ AF.request 첫 번째 파라미터 👉 url method 👉 통신방식 선택 (get, post, delete, patch, put 등) parameters 👉 paramters 가 없는 경우 nil 값 할당, [String:String] 형태로 보낼 수 있음 paramters: [\"foo\": \"bar\"] 이런식으로 보낼 수 있음. encoding 👉 URL이기에 URLEncoding 넣기 headers 👉 헤더 값 할당, json 형식으로 받게끔 작성, [String:String]형태로 보낼 수 있음 validate 👉 유효성 검사 responseJSON 👉 정보를 받는 부분🌱 GET 예제 👇import Alamofirefunc getTest() { let url = \"https://jsonplaceholder.typicode.com/todos/1\" AF.request( url, method: .get, parameters: nil, encoding: URLEncoding.default, headers: [\"Content-Type\":\"application/json\", \"Accept\":\"application/json\"] ) .validate(statusCode: 200..&lt;300) // 200 ~ 300 사이의 상태코드만 허용 .responseJSON { (json) in // 가쟈온 데이터를 사용 }}🌱 POST 예제 👇import Alamofirefunc postTest() { let url = \"https://ptsv2.com/t/im8p3-1592789118/post\" var request = URLRequest(url: URL(string: url)!) request.httpMethod = \"POST\" request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\") request.timeoutInterval = 10 // POST로 보낼 정보 let params = [\"id\":\"아이디\", \"pw\":\"패스워드\"] as Dictionary // httpBody 에 parameters 추가 do { try request.httpBody = JSONSerialization.data(withJSONObject: parmas, options: []) } catch { print(\"http Body Error\") } AF.request(request).responseString { (response) in switch response.result { case .success: print(\"POST 성공\") case .failure(let error): print(\"🚫 Alamofire Request Error\\nCode:\\(error._code), Message: \\(error.errorDescription!)\") } }}☘️ AF.Download 첫 번째 파라미터 👉 Url method 👉 통신방식 선택 (get, post, delete, patch, put 등) parameters 👉 paramters 가 없는 경우 nil 값 할당 encoding 👉 JSON이기에 JSONEncoding 넣기 to 👉 파일 경로 지정 및 다운로드 옵션 설정 옵션 👉 이전 파일 삭제, 디렉토리 생성 등등.. 예제 👇 func downTest() { let url = \"http://212.183.159.230/50MB.zip\" // 파일 메니저 let fileManager = FileManager.default // 앱 경로 let appURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0] // 파일 이름 url 의 맨 뒤 컴포넌트로 지정 (50MB.zip) let fileName: String = URL(string: url)!.lastPathComponent // 파일 경로 생성 let fileURL = appURL.appendingPathComponent(fileName) // 파일 경로 지정 및 다운로드 옵션 설정 (이전 파일 삭제, 디렉토리 생성) let destination: DownloadRequest.Destination = { _, _, in return (fileUrl, [.removePreviousFile, .createIntermediateDirectories]) } // 다운로드 시작 AF.download( url, method: .get, parameters: nil, encoding: JSONEncoding.default, do: destination ).downloadProgress { (progress) in // 이 부분에서 프로그레스 수정 self.progressView.progress = Float(progress.fractionCompleted) self.progressLabel.text = \"\\(Int(progress.fractionCompleted * 1000))\" }.response { response in if response.error != nil { print(\"파일다운로드 실패\") } else { print(\"파일다운로드 완료\") } }} " }, { "title": "iOS Swfit UIKit ViewController Lifecycle", "url": "/posts/iOS-UiKit-Lifecycle/", "categories": "Swift, UIKit", "tags": "iOS, UIKit, ViewController, Lifecycle", "date": "2022-12-02 10:20:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 iOS UIKit ViewController의 Lifecycle 에 대하여 알아보도록 하겠습니다.🍀 ViewController Lifecycle☘️ Init ViewController의 초기화를 진행하면 내부의 객체들을 초기화하는 작업이 수행됨 ⚠️ 아직 내부의 View들이 생성된 것은 아니기에 내부 View 요소에는 접근할 수 없음 init(coder:) 👉 스토리보드를 기반으로 ViewController를 만들 경우 사용 init(nibName: bundle:): nib 파일을 기반으로 ViewController를 만들 경우 사용 ✅ 참고 nib 👉 NeXT Interface Builder (binary 기반), 인터페이스 빌더에서 생성한 객체들을 저장하는 파일, UI를 구성하는 객체들과 이들의 세부설정, 각 객체들간의 관계등을 포함합니다. ☘️ loadView ViewController가 사용자가 설정한 View를 자신의 최상위 View로 설정하는 과정 ViewController가 무엇을 기반으로 호출되었는가(Code, 스토리보드, nib)와 관계없이 호출됨 내부적으로 instantiateWithOwner()라는 메서드가 실행되면서 필요한 subView들을 nib으로부터 unarchiving하고 subView 객체들이 ViewController와 연결 되게 됩니다. 이 때 subView 객체들은 로드가 끝나자마자 awakeFromNib()을 호출합니다. subView들은 ViewController가 아니기 때문에 바로 내부 객체들에 접근할 수 있음. subView들과 연결이 완료되면 ViewController는 viewDidLoad()를 호출 하여 view 들에 대한 load가 완전히 종료되었음을 알림☘️ viewDidLoad 필요한 View의 정보들이 모두 메모리에 위치되면 호춛됨 필요한 데이터를 갱신하는 코드를 작성 ViewController의 생애중 단 한번만 호출됨☘️ viewWillAppear ViewController의 View가 화면에 나타나기 직전에 호출됨 화면이 나타날때마다 호출 되므로 다른 View에서 돌아올 때 수행하고 싶은 행위 들에 대해 처리하기 좋음☘️ viewDidAppear ViewController의 View가 모두 화면에 나타나면 호출됨 주로 UI의 Animation을 실행 시키거나 비디오 및 소리를 재생 시키거나 data의 update를 수행 API data를 받아와 화면을 update하는 로직을 위치시키기에 적당☘️ viewWillLayoutSubviews view의 bounds를 정하는 단계 UIView의 layoutSubviews() 메서드가 트리거되기 직전에 호출 가로모드 혹은 세로모드가 되면서 screen의 방향이 변화될 때도 호출 View의 bounds에 대한 재계산이 필요할때마다 호출☘️ viewDidLayoutSubviews layoutSubviews() 메서드 호출 후에 호출 sub View들의 size와 position, constraint들이 적용이 완료된 상태 가로모드 혹은 세로모드가 되면서 screen의 방향이 변화될 때도 호출 View의 bounds에 대한 재계산이 필요할때마다 호출☘️ viewWillDisappear 다른 ViewController로 화면이 전환되면서 원래 ViewController가 사라질 때 호출 일반적으로 이 함수를 override 해서 처리해야 할 작업은 거의 없음☘️ viewDidDisappear ViewController가 화면에 사라지고나면 호출 Container View Controller를 사용하다보면 여러 ViewController가 메모리에 유지 ⚠️ 즉, 화면에서 사라진 ViewController도 여전히 notification 등의 이벤트를 받을 수 있다는 것 notification, observing 취소 및 디바이스 점검 등을 수행☘️ deinit ViewController 객체가 메모리에 사라지기 전 호출 주로 할당받은 자원중 ARC에 의해 해제가 되지 않는 자원을 해제하기 위해 override 화면에서 사라진다고 해당 메서드가 호출되는 것은 아님☘️ didReceiveMemoryWarning 메모리가 부족해지면 호출 이를 관리해 필요없는 메모리를 해제 하는 작업을 할 수 있음 iOS가 강제로 Application을 종료하는 것을 방지 하기 위해 필요" }, { "title": "iOS SwiftUi Combine Publisher 종류", "url": "/posts/iOS-Swift-Combine-Publisher/", "categories": "Swift, Combine", "tags": "iOS, Combine, SwiftUi, Publisher", "date": "2022-12-02 10:20:00 +0900", "snippet": "안녕하세요. narvis2 입니다.지난시간에는 iOS에서 비동기를 처리할때 사용되는 Combine에 대하여 간단히 알아보았습니다.이번시간에는 지난 시간에 이어 간단한 예제를 통해 Publisher의 종류 에 대하여 알아보고자 합니다.🍀 Publisher의 종류☘️ Just 가장 단순한 형태의 Publisher 단일 Event 발생 후 종료되는 Publisher Error 타입은 항상 Never 예제 👇 Just((0...5)).sink { value in print(value) // 0...5} ☘️ Future 일반적으로 Publisher의 처리를 sink라는 구독을 형태로 많이 처리하게 되는데 이 때 Closure를 전달하는 과정에서 Callback 기반의 completion 핸들러를 사용하게 되는데 Future를 통하여 더욱 깔끔한 코드 작성 이 가능 단일 Event와 종료 혹은 실패를 제공하는 Publisher 1️⃣ 예제 ) 간단한 사용 👇 let myFuture = Future&lt;Int, Never&gt; { promise in promise(.success(10))}myFuture.sink { value in print(value) // 10} 2️⃣ 예제 ) URLSession이나 Alamofire등 RestFul 관련 API비동기 요청시에 해당 요청이 성공했는지, 실패 했는지에 대한 여부를 return 해주는 예제 👇 func isSuccessAPIRequest() -&gt; AnyPublisher&lt;Bool, Never&gt; { Future&lt;Bool, Never&gt; { promise in urlRequestPublisher.sink( receiveCompletion: { completion in switch completion { case .finished: print(\"finished\") promise(.success(true)) case .failure(let error): print(error.localizedDescription) promise(.success(false)) } }, receiveValue: { value in print(value) } ) } .eraseToAnyPublisher()}// 사용isSuccessAPIRequest().sink { if $0 { // 성공 즉, true일 경우 Handling } else { // 실패 즉, false일 경우 Handling }} ☘️ Empty 값을 게시하지 않고 선택적으로 즉시 완료되는 Publisher ✅ 즉, Event 없이 종료되는 Publisher 어떤 데이터도 발행하지 않는 Publisher로 주로 Error처리나, Optional값을 처리할 때 사용 예제 👇 Empty&lt;String, Never&gt;().sink( receiveCompletion: { print($0) // finish }, receiveValue: { print(\"receiveValue: \\($0)\") // 출력 안함 }) ☘️ Fail 오류와 함께 종료되는 Publisher 예제 👇 let failed = Fail&lt;String, Error&gt;(error: NSError(domain: \"error\", code: -1, userInfo: null))_ = failed.sink { print($0)} receiveValue: { print($0)}// 결과 👉 failure(Error Domain=error Code=-1 \"(null)\") ☘️ Deffered 구독이 일어나기 전까지 대기상태로 있다가 구독이 일어 났을 때 Publisher가 결정이 됨 ✅ 즉, 구독(Subscribers)이 이루어질때 publisher가 만들어 짐 Closure 안에는 지연 실행 할 Publisher를 반환함 예제 👇 Deferred { Just(Void()) }.sink(receiveValue: { print(\"Diferred\") }) ☘️ Sequence 요소의 주어진 Sequence를 반환하는 Publisher Publisher가 Sequence에 있는 요소들을 하나 하나 제공 해주며, 모든 요소들이 다 제공되었을 때 종료 예제 👇 Publishers.Sequence&lt;[Int], Never&gt;(sequence: [1, 2, 3]) .sink(receiveValue: { print(\"Sequence : \\($0)\") }) ☘️ Record 입력과 완료를 기록해 후에 다른 Subsciber에서 반복될 수 있는 Publisher 예제 👇 let record = Record&lt;String, Error&gt; { recoding in print(\"make recording\") recording.receive(\"jack\") recording.receive(\"tom\") recording.receive(completion: .finished)}_ = record.sink { print($0)} receiveValue: { print($0)}_ = record.sink { print($0)} receiveValue: { print($0)} 결과 make recording jack tom finished jack tom finished " }, { "title": "iOS SwiftUi Combine 기초", "url": "/posts/iOS-Swift-Combine-Basic/", "categories": "Swift, Combine", "tags": "iOS, Combine, SwiftUi", "date": "2022-12-01 17:20:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 iOS에서 비동기를 처리할때 사용되는 Combine에 대하여 알아보고자 합니다.🍀 Combine Event 처리를 위한 선언적 접근을 합니다. Delegate나 Completion Handler 구현 대신 Event 소스에 대한 Single processing chain을 만들 수 있습니다. Apple 버전의 RxSwift 시간의 흐름에 따라 값을 처리하기 위한 Declarative Swift API를 제공하는 프레임워크 ✅ Combine으로 할 수 있는 대표적인 작업 1️⃣ 필드에 입력한 값이 유요한 경우에만 Submit버튼이 활성화되도록 설정 2️⃣ 비동기작업을 수행하고 반환된 값을 사용하여 View를 Update할 방법과 대상을 선택할 수 있음 3️⃣ 사용자가 텍스트필드에 동적으로 입력하고 입력한 내용을 기반으로 사용자 인터페이스 View를 Update함 ✅ 장점 1️⃣ System Level에 통합되어 있음. 2️⃣ delegate, closure를 만들 필요 없음. 3️⃣ 동일한 interface를 쓰기 때문에 재사용성이 좋음. 4️⃣ operator를 조합하기 좋음. 5️⃣ 비동기 코드에서도 비즈니스 로직에 집중할 수 있음. ✅ Combine의 3가지 주요 부분 Publisher Operator Subscriber ✅ Key points Combine은 비동기 Event를 위한 선언적, 반응형 프레임워크 비동기 프로그래밍의 기존 문제를 해결하는 것이 목표 주요 3 타입 흐름 : publisher(Event 발행) 👉 operator(Event처리, 조작) 👉 subscriber(결과물 소비) ☘️ Publisher value들을 내보내는(emit) 역할 Publisher가 emit할 수 있는 Event 종류 1️⃣ Output 2️⃣ Completion : successful completion 3️⃣ Failure : completion with an error ✅ 참고 Publisher는 Output을 안보내고 있거나 여러번 보낼 수 있으며, Completion이나 Failure를 한번 보내고 나면 더 이상의 Event를 보낼 수 없음 구독이 없는 경우 Publisher는 데이터를 제공하지 않음 ✅ 특징 1️⃣ 3가지 Event로 모든 종류의 동적 데이터를 표현 가능 2️⃣ delegate를 추가하거나 completion callback 주입이 필요 없음 3️⃣ Publisher는 error handling이 내장 4️⃣ Publisher는 2개의 Generic을 기반으로 구성 Generic 첫 번째 Publisher.Ouput 👉 output value Generic 두 번째 Publisher.Failure 👉 Error전달, Error가 발생할 일이 없으면, Never라는 type으로 정의하면 됨 ☘️ Operator Event를 처리하고, 조작하는 역할 Publisher Protocol에 선언되어 있음 같거나 새로운 Publisher를 반환하는 메소드 Operator를 체이닝해서 사용할 수 있기 때문에 유용함 ✅ 장점 1️⃣ Operator들은 독립적이고 조합가능 하기 때문에, 복잡한 로직을 구현하는데 조합(Combine) 가능. 2️⃣ 항상 Input &amp; Output(Upstream &amp; DownStream)을 가지기 때문에 shared state를 피할 수 있음. 즉, 동시성 이슈로 인해 비동기 코드가 끼어들어 데이터를 중간에 변경할 일이 없음 ☘️ Subscribers 결과물을 소비하는 역할 전달받은 value나 completion event로 작업을 수행 모든 구독은 subscriber로 끝남 ✅ 2개의 내장된 subscriber 1️⃣ sink 👉 output value와 completion을 받을 수 있는 클로저를 제공할 수 있음. receiveCompletion 👉 stream이 성공, 실패로 종료되었음을 알려줌 receiveValue 👉 값을 받을 때 실행되는 Closure 2️⃣ assign 👉 output을 key path를 통해 data model의 property나 UI control에 바로 binding할 수 있음. ☘️ Subscriptions publisher, operator, subcriber의 전체 chain ✅ 중요 subscription의 끝에 subscriber를 추가 👉 chainning의 맨 앞에 있는 publisher를 활성화 output을 수신해줄 subscriber가 없으면 publisher는 어떤 value도 전달하지 않음 ✅ 장점 1️⃣ Subscription은 비동기 Event들의 Chain을 Custom 코드와 Error handling과 함께 한번에 선언 가능 2️⃣ Full-Combine이면, 앱 전체의 로직을 subscription들로 표현 가능 3️⃣ Subscription이 한번 선언되고 나면 Callback을 호출할 필요 없이 System이 다 알아서 해줌 ☘️ 메모리 관리 Cancellable Protocol을 사용해서 메모리 관리 Subscriber들은 Cancellable을 준수하고 있음 Object를 메모리에서 해제 👉 모든 subscription은 취소 👉 리소스를 메모리로부터 해제 ✅ subscirber가 더 이상 값을 받을 필요 없을 때 cancel() 사용 ❗️ cancel()을 직접 호출하지 않으면, deinit될 때까지 구독됨 ✅ 장점 1️⃣ Subscription의 수명을 View Controller같은 Object에 binding 기능 2️⃣ 유저가 View Controller를 View Stack에서 dismiss 👉 subscription 취소 해줌 " }, { "title": "React-Native Redux Middleware", "url": "/posts/Reat-Native-Redux-Middleware/", "categories": "React-Native, Redux", "tags": "redux, react-native, redux-middleware", "date": "2022-11-30 16:42:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Redux Middleware에 대하여 알아보도록 하겠습니다.Redux Middleware는 REST API 요청 상태를 관리하기 위해 주로 사용합니다.Redux Middleware를 사용하면 Action이 Dispatch된 다음, Reducer에서 해당 Action을 받아와서 Update하기 전에 추가적인 작업을 할 수 있습니다.자세한 건 밑에서 알아보도록 하겠습니다.🍀 Redux Middleware Action을 Dispatch했을 때 Reducer에서 이를 처리하기에 앞서 사전에 지정된 작업을 실행할 수 있게 해줌 즉, Action과 Reducer사이의 중간자 특정 조건에 따라 Action이 무시되게 만들 수 있음 Action을 console에 출력하거나, 서버쪽에 logging을 할 수 있음 Action이 Dispatch 되었을 때 이를 수정해서 Reducer에게 전달되도록 할 수 있음 특정 Action이 발생했을 때 이에 기반하여 다른 Action이 발생되도록 할 수 있음 특정 Action이 발생했을 때 특정 Javascript 함수를 실행시킬 수 있음 ✅ Redux Middleware는 비동기 작업을 처리할 때 주로 사용 비동기 작업에 관련된 Middleware 라이브러리 redux-thunk 함수를 기반으로 작동 redux-toolkit에 내장되어 있어 적용하기가 간단 redux에서 type을 지닌 객체가 아닌, 함수 타입을 Dispatch 할 수 있게 해줌 redux-saga Generator를 기반으로 사용 특정 경우에 특정 Action을 모니터링 할 수도 있음 특정 Action이 Dispatch 되었을때 원하는 함수를 호출하거나, 또는 라우터를 통해 다른 주소로 이동하는 것이 가능 redux-observable RxJs를 기반으로 작동 특정 경우에 특정 Action을 모니터링 할 수도 있음 특정 Action이 Dispatch 되었을때 원하는 함수를 호출하거나, 또는 라우터를 통해 다른 주소로 이동하는 것이 가능 redux-promise-middleware ☘️ Redux-Thunk redux에서 비동기 작업을 처리 할 때 가장 많이 사용하는 middleware 함수를 기반으로 작동 action객체가 아닌 함수를 Dispatch할 수 있게 해줌. Redux DevTools와 함께 사용 적용 👉 yarn add redux-thunk 1️⃣ 예제 ) redux-thunk middleware 적용 &gt; App.tsx 👇 import rootReducer from \"./src/modules\";import { applyMiddleware, createStore } from \"redux\";import thunk from \"redux-thunk\";const store = createStore(rootReducer, applyMiddleware(thunk)); 2️⃣ 예제 ) thunk 함수 생성 &gt; Redux Module 에 작성 👇 // ✅ thunk 함수 생성export const increaseAsync = () =&gt; (dispatch: Dispatch&lt;CounterAction&gt;) =&gt; { setTimeout(() =&gt; dispatch(increase()), 1000);};export const decreaseAsync = () =&gt; (dispatch: Dispatch&lt;CounterAction&gt;) =&gt; { setTimeout(() =&gt; dispatch(decrease()), 1000);}; 설명 👉 CounterAction 을 AnyAction으로 교체해도 상관 없음 3️⃣ 사용 ) thunk 함수 사용 👇 /** * ✅ 현재 상태를 조회 * 상태를 조회할 때는 state의 타입을 RootState로 지정해야함 */const counter = useSelector((state: RootState) =&gt; state.counter);// Dispatch 함수를 가져옴 (action을 발생시켜 상태를 업데이트)const dispatch = useDispatch();function onIncrease() { dispatch(increaseAsync());}function onDecrease() { dispatch(decreaseAsync());} ☘️ Redux-Thunk + Promise ⚠️ Promise를 다루는 Redux Module을 다룰 때 주의 사항 1️⃣ Promise가 시작(start), 성공(success), 실패(failure)했을 때 다른 Action을 Dispatch 해야함 2️⃣ 각 Promise마다 thunk 함수를 만들어주어야 함 3️⃣ Reducer에서 Action에 따라 로딩중(loading), 결과(result), 에러(error) 상태를 변경해주어야 함 1️⃣ 예제 ) modules/posts.tsx &gt; Redux Module 작성 👇 import { AnyAction, Dispatch } from \"redux\";import * as postsAPI from \"../api/posts\"; // api/posts 안의 함수 모두 불러오기// ✅ 밑의 대문자 상수는 모두 Action Type임// 포스트 여러개 조회하기const GET_POSTS = \"GET_POSTS\"; // 요청이 시작됨const GET_POSTS_SUCCESS = \"GET_POSTS_SUCCESS\"; // 성공const GET_POSTS_ERROR = \"GET_POSTS_ERROR\"; // 실패// 포스트 하나 조회하기const GET_POST = \"GET_POST\"; // 요청이 시작됨const GET_POST_SUCCESS = \"GET_POST_SUCCESS\"; // 성공const GET_POST_ERROR = \"GET_POST_ERROR\"; // 실패/** * thunk 를 사용할 때, 꼭 모든 Action들에 대하여 Action 생성함수를 만들 필요는 없음 * 그냥, thunk 함수에서 바로 action 객체를 만들어 주어도 괜찮음 */export const getPosts = () =&gt; async (dispatch: Dispatch&lt;AnyAction&gt;) =&gt; { dispatch({ type: GET_POSTS }); try { const posts = await postsAPI.getPosts(); dispatch({ type: GET_POSTS_SUCCESS, posts }); } catch (error) { dispatch({ type: GET_POSTS_ERROR, error: error }); }};// ✅ thunk 함수에서도 파라미터를 받아와서 사용 가능export const getPost = (id: number) =&gt; async (dispatch: Dispatch&lt;AnyAction&gt;) =&gt; { dispatch({ type: GET_POST }); try { const post = await postsAPI.getPostById(id); dispatch({ type: GET_POST_SUCCESS, post }); } catch (error) { dispatch({ type: GET_POST_ERROR, error: error }); } };// ✅ 초깃값const initialState = { posts: { loading: false, data: null, error: null, }, post: { loading: false, data: null, error: null, },};// ✅ Reducer 함수export default function posts(state = initialState, action) { switch (action.type) { case GET_POSTS: return { ...state, posts: { loading: true, data: null, error: null, }, }; case GET_POSTS_SUCCESS: return { ...state, posts: { loading: false, data: action.posts, error: null, }, }; case GET_POSTS_ERROR: return { ...state, posts: { loading: false, data: null, error: action.error, }, }; case GET_POST: return { ...state, post: { loading: true, data: null, error: null, }, }; case GET_POST_SUCCESS: return { ...state, post: { loading: true, data: action.post, error: null, }, }; case GET_POST_ERROR: return { ...state, post: { loading: true, data: null, error: action.error, }, }; default: return state; }} 2️⃣ 예제 ) thunk 사용 👇 const { data, loading, error } = useSelector((state) =&gt; state.posts.posts);const dispatch = useDispatch();// 컴포넌트 마운트 후 포스트 목록 요청useEffect(() =&gt; { dispatch(getPosts());}, [dispatch]); " }, { "title": "React-Native Redux + TypeScript", "url": "/posts/React-Native-Redux-With-TypeScript/", "categories": "React-Native, Redux", "tags": "redux, react-native, redux-typescript", "date": "2022-11-30 11:54:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번시간에는 Redux를 TypeScript와 함께 사용하는 법에 대하여 간단한 예제를 통하여 알아보도록 하겠습니다.🍀 Redux + TypeScript Redux + TypeScript 적용 👉 yarn add redux react-redux @types/react-redux 1️⃣ 예제 ) Redux Module 작성 👇 /** * ✅ Action Type * as const 👉 나중에 Action 객체를 만들게 action.type 의 값을 추론하는 과정에서 * action.type 이 string 으로 추론되지 않고 'INCREASE'와 같이 실제 문자열 값으로 추론 되도록 해줌 */const INCREASE = \"INCREASE\" as const;const DECREASE = \"DECREASE\" as const;// ✅ Action 생성 함수export const increase = () =&gt; ({ type: INCREASE });export const decrease = () =&gt; ({ type: DECREASE });/** * ✅ 모든 Action 객체들에 대한 타입을 준비 * ReturnType&lt;typeof _____&gt; 👉 특정 함수의 반환값을 추론해줌 * Action Type 을 선언 할 떄 as const 를 하지 않으면 이 부분이 제대로 작동하지 않음 */type CounterAction = | ReturnType&lt;typeof increase&gt; | ReturnType&lt;typeof decrease&gt;;// ✅ 이 리덕스 모듈에서 관리 할 State의 Type을 선언type CounterState = { count: number;};// ✅ 초깃값 (상태가 객체가 아니라 그냥 숫자여도 상관 없음)const initialState: CounterState = { count: 0,};/** * ✅ Reducer를 작성 * Reducer 에서는 state 와 함수의 반환값이 일치하도록 작성해야함 * Action 에서는 CounterAction 을 타입으로 설정 */export default function counter( state: CounterState = initialState, action: CounterAction): CounterState { switch (action.type) { case \"INCREASE\": return { count: state.count + 1 }; case \"DECREASE\": return { count: state.count - 1 }; default: return state; }} 2️⃣ 예제) Root Reducer 작성 👇 import { combineReducers } from \"redux\";import counter from \"./counter\";// ✅ Root Reducer 생성const rootReducer = combineReducers({ counter });export default rootReducer;/** * Root Reducer 의 반환값을 유추해줌 * 추후 이 타입을 컨테이너 Component에서 불러와서 사용해야 하므로 내보냄 */export type RootState = ReturnType&lt;typeof rootReducer&gt;; 3️⃣ 예제 ) useSelector, useDispatch 사용 👇 import React from \"react\";import Counter from \"./Counter\";import { RootState } from \"../modules\";import { useSelector, useDispatch } from \"react-redux\";import { increase, decrease } from \"../modules/counter\";const CounterContainer = () =&gt; { /** * ✅ 현재 상태를 조회 * 상태를 조회할 때는 state의 타입을 RootState로 지정해야함 */ const counter = useSelector((state: RootState) =&gt; state.counter); // Dispatch 함수를 가져옴 (action을 발생시켜 상태를 업데이트) const dispatch = useDispatch(); function onIncrease() { dispatch(increase()); } function onDecrease() { dispatch(decrease()); } const props = { count: counter.count, onIncrease, onDecrease, }; return &lt;Counter {...props} /&gt;;};export default CounterContainer; 4️⃣ 예제 ) Counter.tsx 👇 import React from \"react\";import { Pressable, Text, View } from \"react-native\";type CounterProps = { count: number; onIncrease: () =&gt; void; onDecrease: () =&gt; void;};const Counter = ({ count, onIncrease, onDecrease }: CounterProps) =&gt; { return ( &lt;View style= &gt; &lt;Text style=&gt;{count}&lt;/Text&gt; &lt;Pressable onPress={onIncrease} style=&gt; &lt;Text&gt;{+1}&lt;/Text&gt; &lt;/Pressable&gt; &lt;Pressable onPress={onDecrease} style=&gt; &lt;Text&gt;{-1}&lt;/Text&gt; &lt;/Pressable&gt; &lt;/View&gt; );};export default Counter; 5️⃣ 예제 ) Provier를 사용하여 App.tsx에 적용 👇 import { Provider } from \"react-redux\";import { createStore } from \"redux\";import CounterContainer from \"./src/components/CounterContainer\";import rootReducer from \"./src/modules\";const store = createStore(rootReducer);const App = () =&gt; { const isDarkMode = useColorScheme() === \"dark\"; const backgroundStyle = { backgroundColor: isDarkMode ? Colors.darker : Colors.lighter, }; return ( &lt;Provider store={store}&gt; &lt;SafeAreaView style={backgroundStyle}&gt; &lt;CounterContainer /&gt; &lt;/SafeAreaView&gt; &lt;/Provider&gt; );};export default App; " }, { "title": "iOS Swift 직렬화, 역직렬화 Codable / Decodable", "url": "/posts/iOS-Swift-Codable-Decodable/", "categories": "Swift, Grammar", "tags": "codable, decodable, encodable", "date": "2022-11-25 15:26:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 에서 직렬화, 역직렬화를 하는 방법에 대하여 알아보고자 합니다.Android 에서는 다음 방식으로 진행합니다.✅ 직렬화 : data class 👉 json✅ 역질렬화 : json 👉 data classSwift 에서는 다음 방식으로 진행합니다.✅ 직렬화(Encodable) : struct 👉 json✅ 역직렬화(Decodable) : json 👉 struct자세한 사항은 밑에서 알아보도록 하겠습니다.🍀 Data Codable, Decodable, Encodable을 알아보기전 필수 개념 Memory 안의 Byte가 저장될 수 있는 Byte Buffer Byte Buffer 👉 운영체제의 커널이 관리하는 시스템 메모리를 직접 사용할 수 있기 때문에 데이터의 저장, 로드가 가능 Swift는 URLSession으로 dataTask를 만들어, Network 호출(request)을 하면 응답(response)으로 Data형을 받는데, 이는 저장, 로드, 변환이 쉽기 떄문에 Data로 받음 ✅ 즉, 자주 사용되는 것은 json 데이터를 struct형으로 변경하거나, 반대로 struct형에서 json으로 변경할 때 먼저 Data형으로 변경한 다음 원하는 데이터형으로 변경하여 사용🍀 Encodable Data형으로 변형할 수 있는 타입(JSON 형) ✅ 즉, Model을 json 형으로 변경( 직렬화 ) 1️⃣ 예제 ) Encodable을 준수하고 있는 Sample struct 생성 👇 struct Sample: Encodable { let a: Int let b: Int} ✅ 설명 Sample은 Encodable을 준수하고 있으므로, Sample객체는 Data형의 객체로 변형 가능 2️⃣ 예제 ) struct 👉 json 으로 변환 (직렬화) 👇 let sample = Sample(a: 0, b: 0)// JSON 타입으로 인코딩할 수 있는 객체let jsonEncoder = JSONEncoder()jsonEncoder.outputFormatting = .prettyPrinted // 줄바꿈과 들여쓰기 삽입jsonEncoder.outputFormatting = .sortedKeys // 키 정렬 (사전순)// 위의 2가지 설정을 함께 쓰는 경우jsonEncoder.outputFormatting = [.sortedKeys, .prettyPrinted]let data = try jsonEncoder.encode(sample)print(data) // 13 bytesprint(String(data: data, encoding: .utf8)) // \"{\\n \\\"a\\\" : 0,\\n \\\"b\\\" : 0\\n}\" ✅ 설명 JSONEncoder 👉 JSON 타입으로 인코딩할 수 있는 객체 🍀 Decodable Data형을 sturct와 같은 것으로 변환할 수 있는 타입 주로 서버에서 받아온 response를 struct에 매칭 시킬 때 많이 사용 ✅ 즉, Json을 Model 형으로 변경( 역직렬화 ) 1️⃣ 예제 ) Decodable을 준수하고 있는 Sample2 struct 생성 👇 struct Sample2: Decodable { let aVal: Int let bVal: Int enum CodingKeys: String, CodingKey { case aVal = \"a\" case bVal = \"b\" }} ✅ 설명 Sample2는 Decodable을 준수하고 있기 때문에, Data형을 Sample2에서 정의한 프로퍼티에 매핑이 가능 CodingKey 👉 json key가 아닌 내가 원하는 이름으로 지정해줄 수 있게 해주는 프로토콜 즉, Android Gson @SeriallizeName과 역할이 같음 서버에서 내려오는 response 의 각 이름이 마음에 안들때 내가 원하는 이름으로 매핑시켜 주기 위해 사용 여기서는 aVal 이 a의 이름을 가진 response 와 매칭되고, bVal은 b의 이름을 가진 response와 매칭됨. 2️⃣ 예제 ) json 👉 struct로 변환 (역직렬화) 👇 let data = try jsonEncoder.encode(smaple)let jsonDecoder = JSONDecoder()let sample2 = try jsonDecoder.decode(Sample2.self, from: data)print(sample2) // Sample2(aVal: 0, bVal: 0) 🍀 Codable Decodable과 Encodable을 동시에 가지고 있는 타입 ✅ 즉, Decodable과 Encodable이 합쳐진 것 struct, enum, class 전부 채택 가능 1️⃣ 예제 ) Codable을 채택하고 있는 Track struct생성 👇 struct Track: Codable { let title: String let artistName: String let isStreamable: Bool} 2️⃣ 예제 ) 직렬화 - struct 인스턴스를 JSONEncoder를 사용하여 Data로 인코딩 👇 let sampleInput = Track(title: \"New Rules\", artistName: \"Choi young jun\", isStreamable: true)do { let encoder = JSONEncoder() // 직렬화 struct -&gt; data let data = try encoder.encode(sampleInput) print(data) // 65 Bytes // data -&gt; string 형태로 변환 if let jsonString = String(data: data, encoding: .utf8) { print(jsonString) // {\"title\":\"New Rules\",\"isStreamable\":true,\"artistName\":\"Dua Lipa\"} }} catch { print(error)} 3️⃣ 예제 ) 역직렬화 - Data를 struct로 변경 👇 let jsonData = \"\"\"{ \"artistName\" : \"Dua Lipa\", \"isStreamable\" : true, \"title\" : \"New Rules\"}\"\"\".data(using: .utf8)!do { let decoder = JSONDecoder() let data = try decoder.decode(Track.self, from: jsonData) print(data) // Track(title: \"New Rules\", artistName: \"Dua Lipa\", isStreamable: true) print(data.title) // New Rules} catch { print(error)} 3️⃣ 예제 ) Handling Dates - decoder.dateDecodingStrategy 속성 사용 👇 struct Track: Codable { let title: String let artistName: String let isStreamable: Bool let releaseDate: Date}let jsonData = \"\"\"{ \"artistName\" : \"Dua Lipa\", \"isStreamable\" : true, \"title\" : \"New Rules\", \"releaseDate\": \"2017-06-02T12:00:00Z\"}\"\"\".data(using: .utf8)!do { let decoder = JSONDecoder() // Serialize 날짜가 date 형태로 변환되게 하는 설정 decoder.dateDecodingStrategy = .iso8601 let data = try decoder.decode(Track.self, from: jsonData) print(data) print(data.releaseDate)} catch { print(error)} 4️⃣ 예제 ) api response가 Wrapper Key를 포함하는 경우 👇 struct Response: Codable { let resultCount: Int let results: [Track]}struct Track: Codable { let title: String let artistName: String let isStreamable: Bool}let jsonData = \"\"\"{ \"resultCount\": 50, \"results\": [{ \"artistName\" : \"Dua Lipa\", \"isStreamable\" : true, \"title\" : \"New Rules\" }]}\"\"\".data(using: .utf8)!do { let decoder = JSONDecoder() let data = try decoder.decode(Response.self, from: jsonData) print(data.results[0]) // Track(title: \"New Rules\", artistName: \"Dua Lipa\", isStreamable: true)} catch { print(error)} 5️⃣ 예제 ) api response가 Root Level Arrays를 가질 경우 👇 struct Track: Codable { let title: String let artistName: String let isStreamable: Bool}let jsonData = \"\"\"[{ \"artistName\" : \"Dua Lipa\", \"isStreamable\" : true, \"title\" : \"New Rules\"}]\"\"\".data(using: .utf8)!do { let decoder = JSONDecoder() // 넣을때 []로 감싸서 사용 let data = try decoder.decode([Track].self, from: jsonData) print(data[0]) // Track(title: \"New Rules\", artistName: \"Dua Lipa\", isStreamable: true)} catch { print(error)} 5️⃣ 예제 ) struct에서 enum 을 type으로 가질 경우 👇 struct Track: Codable { let title: String let artistName: String let isStreamable: Bool let primaryGenreName: Genre}enum Genre: String, Codable { case Pop case KPop = \"K-Pop\" case Rock case Classical case HipHop = \"Hip-Hop\"}let jsonData = \"\"\"{ \"artistName\" : \"Dua Lipa\", \"isStreamable\" : true, \"title\" : \"New Rules\", \"primaryGenreName\": \"Pop\"}\"\"\".data(using: .utf8)!do { let decoder = JSONDecoder() let data = try decoder.decode(Track.self, from: jsonData) print(data) print(data.primaryGenreName) // Pop} catch { print(error)} " }, { "title": "iOS Swift 문법 - Struct / Class 선택 기준", "url": "/posts/iOS-Swift-Struct-Class-Standard/", "categories": "Swift, Grammar", "tags": "struct, class", "date": "2022-11-22 17:43:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 지난 Struct / Class 강의에 이어 Struct과 Class의 선택 기준을 알아보도록 하겠습니다.🍀 Struct / Class 선택기준 ✅ 기준 1️⃣ 기본적으로 Struct를 사용함 안전성 측면에서 가능한 한 struct를 사용 2️⃣ Object-C코드와 연계가 필요하면 class를 사용 3️⃣ Data의 identity를 다뤄야 한다면 class를 사용 (참조방식) 4️⃣ 상속이 필요할 경우 👉 struct + protocol 조합을 사용 protocol은 class와 달리, sturct, class, enum 모두와 상속 관계를 지을 수 있어 선호됨 5️⃣ 상속이 필요하지 않고 모델이 크지 않으면 struct 사용 6️⃣ DB연결 처럼 App 전체 코드에서 상황을 공유해야 할 때 class 사용 7️⃣ json파싱할 경우 struct사용 8️⃣ serialize해서 전송하거나 파일로 저장할 일이 있다면 class 사용 ☘️ 기본적으로 struct 사용 일반적인 종류의 Data를 보여줄 때 struct를 사용하면 됨 Swift에서 struct는 다른 언어에서 class에게만 허용하는 여러 feature들을 사용할 수 있음 struct를 사용하면 app의 전체 상태를 고려할 필요없이 코드의 일부에 대해 더 쉽게 추론할 수 있음 struct는 값 타입 이기 때문에 struct의 지역적인 변화는 의도적으로 알리지 않는 한 app의 다른 부분에서는 보이지 않음. ✅ 결과 적으로 code section에서는 인스턴스에 변화를 줄 수 없기에 code의 한 부분에만 집중할 수 있음 참조 타입인 class를 사용하는데 만약 system이 크고 복잡하다면, 서로를 뒤죽박죽 참조해댈 수도 있고 아무곳에서나 Instance를 변경할 수 있기에 코드 전체에 신경을 써야함☘️ Object-C 코드와 연계가 필요할 경우 class 사용 만약 data를 처리하기 위해 Objective-C API를 사용해야 한다거나, Objective-C Framework에 “class로 정의된” 타입으로 data modeling을 해야 한다면, class와 class 상속을 사용☘️ Data의 identity를 다뤄야 한다면 class를 사용 (참조방식) app간 class instance를 공유할 때, 이 instance를 변경하면 이를 참조하는 코드의 다른 모든 부분에서도 이 변화가 보이길 원한다면 class사용 file handles, network connections, shared hardware intermediaries 등등.. 만약 local DB연결을 나타내는 타입을 가지고 있다면, DB접근을 관리하는 코드는 DB의 상태를 완전히 제어해야함 이 경우 class를 사용하는게 적절함 identity를 가지더라도 제어할 필요가 없으면 struct를 사용 modeling 중인 data가 entity에 대한 정보이며, 이 entity에 identity가 들어있지만 control이 필요없다면 struct를 사용 ☘️ 상속이 필요할 경우 struct + protocol 조합을 사용 protocol 상속 + struct 조합으로 상속계층을 만들 수 있음 protocol은 class, struct, enum 모두가 상속에 참여할 수 있도록 허용 class 상속은 class 끼리만 가능 ✅ data를 어떻게 modeling할지 고르고 있다면, 우선 protocol 상속을 쓰고 struct가 채택하도록 설정" }, { "title": "iOS Swift 문법 - Extension", "url": "/posts/iOS-Swift-Extension/", "categories": "Swift, Grammar", "tags": "Extension", "date": "2022-11-22 13:18:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 Extension에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Extension Kotlin의 확장 함수와 유사 기존 Class, Struct, Enum, Protocol에 새 기능을 추가 하위 Class를 생성하거나 참조하지 않고 그저 기능을 추가하기 위해 사용 ✅ 특징 계산된 instance property 및 계산 유형 속성 추가 instance method 및 type method 정의 새 initializer 제공 Subscript 정의 새 중첩 타입 정의 및 사용 기존 타입을 Protocol에 맞게 설정 ✅ Extention 선언 👇 extension 기존 타입이름 { //새로운 기능}// 익스텐션은 기존에 존재하는 타입이 추가적으로 다른 프로토콜을 채택할 수 있도록 확장할 수도 있음extension 확장 타입이름: 프로토콜1, 프로토콜2, 프로토콜3 { //새로운 기능} Double Type에 Extension 적용 예제 👇extension Double { var squared: Double { return self * self }}let myValue:Double = 3.5print(myValue.squared)print(3.5.squared) 설명 👇 Double 타입의 변수나 상수를 생성하면 squared라는 property의 기능을 사용할 수 있게 됨 ⚠️ 기존 타입에 새로운 기능을 추가하기 위해 확장을 정의한다면, 새로운 기능은 기존 타입의 instnace에서만 가능 ☘️ Protocol을 채택할 때 사용하는 Extenstion Extenstion은 Protocol 채택할 때 많이 사용됨 하나의 ViewController 클래스를 만들고 이 클래스는 UIViewController, UIPickerViewDelegate, UIPickerViewDataSource Protocol을 채택 받는 예제 👇class ViewController: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource {} 설명 👇 위의 코드와 같이 소스를 작성하게 된다면 Class가 너무 비대해진다는 단점 이 생김. 이때 Extention을 이용하여 Class를 나누게 되면 소스가 깔끔하고 이해하기 쉬워짐 ✅ 위 코드 개선 예제 👇class ViewController: UIViewController{}extension ViewController: UIPickerViewDelegate{}extension ViewController: UIPickerViewDataSource{}" }, { "title": "iOS Swift 에서 Singleton 사용하기", "url": "/posts/iOS-Swift-Singleton/", "categories": "Swift, SwiftUi", "tags": "singleton, static", "date": "2022-11-22 13:14:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift에서 Singleton 패턴을 사용하는 법에 대하여 알아보도록 하겠습니다.🍀 Singleton Kotlin의 compainion object와 유사함 👍 장점 단 한번의 instance만 새성하므로 메모리 낭비를 방지할 수 있음 Singleton instance는 전역 instance로 다른 클래스들과 자원 공유 가 쉬움 DBCP(Database Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용 Thread Pool, Cache, 대화상자, 사용자 설정, Registry 설정, Log 기록 객체 등.. 👎 단점 Singleton Instance가 너무 많은 일을 하거나, 많은 데이터를 공유시킬 경우 다른 클래스의 Instance들 간 결합도가 높아져 개방=폐쇄 원칙을 위배함(객체 지향 설계 원칙에 어긋남) 따라서 유지 보수 측면에서 어려워짐 수정과 Test가 어려워짐 ☘️ Swift 에서 Singleton 사용 Static을 사용해 Type Property로 Instance를 생성하면, 사용 시점에 초기화(Lazy) 가 되기 때문에 Singleton Instance가 최소 생성되기 전까진 메모리에 올라가지 않고, Dispatch_once도 자동 적용됨 ✅ 별도의 코드 없이 Instance가 여러 개 생성되지 않는, Thread-Safe한 방법이 됨 혹시라도 init()을 호출하여 Instance를 또 생성하는 것을 막기 위해 init() 함수 접근 제어자를 private로 지정 예제 👇class UserInfo { static let shared = UserInfo() var id: String? var password: String? var name: String? private init() {}}let userInfo = UserInfo.shareduserInfo.id = \"YoungJun\"" }, { "title": "iOS Swift 문법 - Type Method", "url": "/posts/iOS-Swift-TypeMethod/", "categories": "Swift, Grammar", "tags": "Type Method", "date": "2022-11-22 11:13:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 Type Method에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Type Method Type 자체에서 호출되는 Method instance를 생성하지 않고도 타입 자체에서 Method를 호출할 수 있음 kotlin 의 singleton 인 object/companion object와 비슷 method 앞에 static 이나 class의 키워드가 붙음 static func class func 서브 클래스에서 override 할 수 없음 서브 클래에서 override 가능 ☘️ class func class는 상속이 가능하나 Struct/Enum에서는 상속이 불가능하여 class func을 사용할 수 없음 ❗️ Struct/Enum에서는 오로지 Static func만 사용 가능 override 가능 예제class Print { class func printMessage() { print(\"Hello!!\") }}// Type Method로 instance를 생성해줄 필요 없이 타입 자체에서 호출할 수 있음Print.printMessage()☘️ static func override 불가 예제class Print { static func printMessage() { print(\"Hello!!\") }}Print.printMessage()" }, { "title": "iOS Swift 문법 - Closure", "url": "/posts/iOS-Swift-Closure/", "categories": "Swift, Grammar", "tags": "closure", "date": "2022-11-22 11:13:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 Closure에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Closure 이름 없는 함수 (Kotlin 의 람다와 비슷, 즉 익명 함수) 일반 함수 👉 이름이 있는 Closure 함수 인자들을 넣을 수 있고, 반환타입까지 설정을 해줄 수 있음 함수의 내용 👉 in 다음에 수행 내용 적기 일반함수 예제 👇func add(x:Int, y:Int) -&gt; Int { return (x+y)}print(add(x:10, y:20)) Closure 함수 예제 👇let add1 = {(x: Int, y:Int) -&gt; Int in return(x+y)}print(add(10, 20))☘️ 후행 클로저(trailing closure) closure가 함수의 마지막 argument라면 마지막 매개변수 이름을 생략한 후 함수 소괄호 외부에 closure를 구현할 수 있게 ✅ Kotlin 의 람다와 같음 예제 👇//후행 클로저 미사용let onAction = UIAlertAction(title: \"On\", style: UIAlertAction.Style.default, handler: { //실행 코드})//후행 클로저 사용let onAction = UIAlertAction(title: \"On\", style: UIAlertAction.Style.default) { //실행 코드})☘️ Closure 의 축약 표현 1️⃣ 타입 생략 👉 closure는 method에서 요구하는 형태로 전달해야 함 👉 swift는 이러한 문맥을 이용해 타입을 유추할 수 있음(타입 추론) 👉 매개변수의 타입이나 반환 타입을 생략해서 closure를 사용할 수 있게 됨 2️⃣ return 생략 👉 return 도 생략 가능 3️⃣ 매개변수 생략 👉 매개변수의 이름도 생략 가능 👉 매개변수의 이름을 명시하지 않아도 $와 숫자의 조합으로 단축 인자 이름을 사용할 수 있음 👉 $0 첫 번째 매개변수 👉 $1 두 번째 매개변수 👉 in 키워드도 생략 가능 4️⃣ 연산자만 표기 👉 매개변수의 타입과 반환 타입이 연산자를 구현한 함수의 모양과 동일하다면, 연산자만 표기하더라도 알아서 연산하고 반환해줌 예제 👇let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]// 일반 closurelet reversed = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2})// 1️⃣ 매개 변수 타입, 반환 타입 생략let reversed2 = names.sorted(by: { (s1, s2) in return s1 &gt; s2})// 2️⃣ Return 생략let reversed3 = names.sorted(by: { (s1, s2) in \ts1 &gt; s2})// 3️⃣ 매개변수, in 키워드 생략let reversed4 = names.sorted(by: { return $0 &gt; $1})// 4️⃣ 연산자만 표기let reversed5 = names.sorted(by: &gt;)" }, { "title": "iOS Swift 문법 - Optional Binding", "url": "/posts/iOS-Swift-Optional-Binding/", "categories": "Swift, Grammar", "tags": "Optional Binding, Optional, if let, guard let", "date": "2022-11-22 10:21:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 Optional Binding에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Optional Binding 강제로 Optional을 여는 방식(!)가 아닌 안전하게 확인을 해보고 unwrapping을 하는 방법 if문을 이용하여 Optional에 할당된 값을 임시 변수 또는 상수에 할당을 해주는 방식 Force unwrapping Optional Binding !를 써서 상제로 Optional추출 if let, guard let을 써서 Optional추출 만약 Optional에 값이 있다면 if문 안으로 들어가게 되고, nil이라면 그냥 통과하게 되는 방식☘️ if let (지역 변수로만 사용가능) 지역 변수로만 사용 가능 즉, if 문 블럭 내부에서만 사용 가능 할당 상수를 if문 안에서만 사용 예제 👇let x: Int? = 10let y: Int? = nilif let xx = x { print(\"x = \\(xx)\")} else { print(\"x is Optional\")}if let yy = y { print(\"y = \\(yy)\")} 설명 👇 값이 있는 x는 xx에 대입되어 if문을 수행하게 되고, 값이 nil인 y는yy에 대입하지 못하고 그냥 통과함 ☘️ 여러 Optional Binding Optional Binding 할때는 여러 변수나 상수 또한 같이 할 수 있음 ,로 구분지어서 사용 예제 👇let name1: String?let name2: String?name1 = \"choi\"name2 = \"kim\"if let nameFirst = name1, let nameSecond = name2 { // name1, name2 가 Optinal이 아닌 경우 해당 로직 실행 print(nameFirst, nameSecond)}☘️ guard let (전역 변수로 사용가능) guard let 에서는 else인 부분만 작성 이 가능 즉, 값이 nil이여서 Optional 추출이 되지 않을때만 어떠한 행동을 취할 수 있음 만약 nil값이 아닐 걸 확인하고 Optional을 성공적으로 추출했다면 guard let문을 통과 ✅ 전역변수로 사용 가능 즉, guard let문 밖에서도 할당 상수를 자유롭게 사용 가능 guard let의 else문 ❗️항상 return 이나 throw문이 와야함 예제 👇let x: Int? = 10let y: Int? = nilfunc opbinding() { guard let xx = x else { return print(\"x is Optional\") } print(xx) guard let yy = y else { return print(\"y is Optional\") } print(yy)}opbinding()" }, { "title": "iOS Swift 문법 - Mutating", "url": "/posts/iOS-Swift-Mutating/", "categories": "Swift, Grammar", "tags": "Mutating", "date": "2022-11-22 10:21:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 Mutating에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Mutating 값 타입인 Struct에서는 instance method 내에서 property들을 수정할 수 없게 되어 있음 ❗️ Error ❗️ Cannot assign property 👉 값 타입인 Struct에서는 method안의 값을 수정할 수 없기 때문에 발생 이러한 property들을 Struct안의 method에서 수정을 해주기 위해 mutating이라는 키워드를 사용 ✅ mutating 👉 특정 method내에서 Struct 또는 Enum property를 수정해야 하는 경우 해당 method의 동작을 변경하도록 하는 것 Struct나 Enum을 쓸때는 정말 중요한 키워드 예제 👇struct Person { let name: String var age: Int init (name: String, age: Int) { self.name = name.uppercased() self.age = age } // mutating 키워드를 사용하지 않으면 Cannot assign property Error 발생 mutating func changeAge() { age = 10 }}var choi = Person(name: \"choi\", age: 29)choi.changeAge()print(choi.age)" }, { "title": "iOS Swift 문법 - Protocol", "url": "/posts/iOS-Swift-Protocol/", "categories": "Swift, Grammar", "tags": "protocol", "date": "2022-11-22 10:02:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 Protocol에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Protocol Kotlin 의 interface 와 비슷합니다. 특정 작업 또는 기능에 적합한 메서드, 속성 및 기타 요구 사항의 Blueprint를 정의한다 Protocol 👉 요구사항 Protocol에는 구현 내용은 들어가 있지 않고, 채용한 타입이 직접 구현 Protocol을 채용한 형식은 요구사항을 반드시 모두 구현 Protocol은 Protocol간 상속을 지원, class와 달리 다중 상속 도 지원 ℹ️ 사용 이유 swift는 protocol 지향 프로그래밍임 protocol 초기 구현이 protocol 지향 프로그래밍의 핵심 swift에서는 class만 상속이 가능하고 class는 참조 타입이므로 참조 추적에 비용이 많이 발생 따라서 비교적 비용이 적은 값 타입을 활용하고 싶어도, 상속을 할 수 없으므로 때마다 기능을 다시 구현해 주어야 한다는 불편함이 있음 protocol을 사용하면 상속이라는 한계점을 탈피할 수 있음 초기에 구현해 놓은 많은 property나 method를 우리가 쉽게 채택하여서 사용을 할 수 있다는 큰 장점이 있음 ☘️ Protocol property Protocol에서 property(속성)를 정의할 때에는 get 과 set 키워드를 사용해 property(속성)가 읽기 전용 property(속성)인지 쓰기 property(속성)인지를 반드시 명시 를 해줘야 함 {get, set} 👉 읽기 / 쓰기 property { get } 👉 읽기 전용 property 예제 👇protocol SomeProtocol { var mustBeSettable: Int { get set } var doesNotNeedToBeSettable: Int { get }}☘️ Protocol method method 의 본문은 포함하지 않음 예제 👇protocol RandomNumberGenerator { func random() -&gt; Double}class LinearCongruentialGenerator: RandomNumberGenerator { var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double { lastRandom = ((lastRandom * a + c) .truncatingRemainder(dividingBy:m)) return lastRandom / m }}" }, { "title": "iOS Swift 문법 - Class / Struct", "url": "/posts/iOS-Swift-Class-Struct/", "categories": "Swift, Grammar", "tags": "class, struct", "date": "2022-11-22 09:02:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번시간에는 Swift 문법에 중에서도 class와 struct에 대하여 알아보는 시간을 가지도록 하겠습니다.🍀 Class Swift에서는 class를 정의하여 객체(Object)를 만들고 사용할 수 있음 class 하나를 만든다면 class에서 생성된 객체인 instance 를 만들어 실제 작업에 쓰일 수 있게 해야함 instance 👉 클래스 초기화, (타입 캐스팅 허용) 상속 가능 ✅ 참조 타입 변수나 상수에 할당하거나 함수에 넘길 때 복사하지 않음 복사 대신에 기존에 같은 instance에 참조가 사용됨 즉, 값이 복사되는 것이 아닌 메모리를 참조하는 것 ✅ 즉, class는 레퍼런스 타입이기 때문에 아무리 여러 번 전달하더라도 단 하나의 instance만 존재 하고, 따라서 그 하나의 instnace를 참조하는 어느 한 군데에서 instance에 변화를 주게 되면 다른 모든 곳에서도 바뀌게 되는 특성이 있음 속성(property) 👉 클래스 안의 변수 메서드(method) 👉 클래스 안의 함수 ✅ init 👉 instance를 만들때 생성자에 인수를 넣을 때 사용 self 👉 Kotlin 의 this 와 유사 예제 👇class Name { var name = \"Choi\" var age: Int init(name: String, age: Int) { // 초기화 self.name = name self.age = age } func myName() { print(\"my name is \\(name) and \\(age) year's old\") }}// instance 화let name1: Name = Name(name: \"choi\", age: 29)let name2: Name = Name(name: \"kim\", age: 31)// 프로퍼티 호출print(name1.name)// 메서드 호출name1.myName()print(name2.name)name2.myName()🍀 Struct instance의 값(프로퍼티)를 저장하거나 기능(메서드)를 제공하고 이를 캡슐화할 수 있는 Swift가 제공하는 Type임 class 처럼 instance화를 하여 실제 작업에도 쓸 수 있음 (타입 캐스팅 허용 안함) 불변성(Immutable) 구현에 유리 Multi Thread 에 안전함 속성(property) 👉 구조체(Struct) 안의 변수 메소드(method) 👉 구조체(Stuct) 안의 함수 ✅ 값 타입 상수나 변수에 할당하거나 함수에 넘겨질 때 복사가 됨 ✅ Stuct에는 상속할 수 없음 ✅ class 처럼 init()메소드를 사용할 필요 없이 자동으로 초기화 코드를 만들어줌 프로퍼티 속성값을 선언하지 않고 instance 선언시 매개변수로 넣어줌 구조체 멤버를 패러미터 네임으로하여 Swift가 자동으로 초기화 코드를 만들어 줌 ✅ 사용 기준 하나라도 해당되면 Stuct 사용 1️⃣ 몇몇 단순 데이터 값을 캡슐화하는 경우 2️⃣ 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때 3️⃣ Stuct에 저장된 프로퍼티가 값 타입이며, 참조하는 것보다 복사하는 것이 합당할 때 4️⃣ 다른 기존 타입으로부터 상속받거나 자신을 상속할 필요가 없을 때 예제 👇struct Name { // 프로퍼티 속성값을 선언하지 않고 instance 선언시 매개변수로 넣어줌 var name: String func myName() { print(\"my name is \\(name)\") }}// instance 생성var choi: Name = Name(name: \"choi\")print(choi.name) // 프로퍼티 호출choi.myName() // 메서드 호출🍀 Class / Struct 공통점 및 차이점☘️ 공통점 여러 변수(property)와 함수(method)를 담을 수 있는 하나의 집합 데이터를 용도에 맞게 묶어서 사용할때 편리하고 가독성을 높여줌 초기화(init())를 정의하여 여러 매개변수에 대해 다양한 instance를 생성 가능 기본적인 구현을 넘어선 기능을 확장시킬 수 있도록 확장 가능 .을 사용하여 instance생성이 가능하고 생성 방법이 같음 특정 종류의 표준 기능을 제공하는 protocal을 사용 가능 새로운 데이터 타입을 만들어 주는 것☘️ 차이점 Struct에는 init() method 없이 자동으로 초기화 함수를 만들어 줌 Class 👉 상속 가능, Struct 👉 상속 불가 Class 👉 값 타입 , Struct 👉 참조 타입 TypeCasting(타입캐스팅)은 Class의 instance 에만 허용 Deinitializer는 class의 instance에만 활용 가능 참조 횟수 계산(Reference Counting)은 Class의 instance에만 적용☘️ 값 타입 / 참조 타입 값 타입 Stuct, enum 에 해당 상수나 변수에 할당하거나 함수에 넘겨질 때 복사가 됨 참조 타입 Class 에 해당 변수나 상수에 할당하거나 함수에 넘길 때 복사하지 않음 복사 대신에 기존에 같은 instance에 참조가 사용됨 즉, 값이 복사되는 것이 아닌 메모리를 참조하는 것 예제 👇struct A { // 구조체 (상속이 안됨) var a = 10}class B { // 클래스 (상속 가능) var a = 10}// instance 선언var str_1: A = A() // 값을 복사 - a 값을 바꿔도 struct 안의 a는 변화 없음var cls_1: B = B() // 값을 참조 - a 값을 바꾸면 class 안의 a도 바뀜var str_2 = str_1var cls_2 = cls_1str_1.a = 20cls_1.a = 20// 구조체에는 변화 없지만 클래스에는 변화가 있음print(\"\\(str_2.a) \\(cls_2.a)\") // 결과 : 10 20 설명 Struct(구조체)는 그저 복사를 하여 str_1과 str_2의 관계는 참조되지 않고 각각의 개별의 관계 Class(클래스)는 서로 참조하는 관계를 가지므로 cls_1과 cls_2는 참조 관계가 되어 서로에게 영향을 줌 " }, { "title": "iOS SwiftUi ViewModel", "url": "/posts/iOS-SwiftUi-ViewModel/", "categories": "Swift, SwiftUi", "tags": "ObservableObject, ObservedObject, Published, StateObject, ViewModel", "date": "2022-11-21 16:02:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Swift 에서 ViewModel 을 사용하여 MVVM 패턴을 사용하는 방법에 대하여 알아보도록 하겠습니다.🍀 MVVM (Model - View - ViewModel) Model 👉 Application 에서 사용되는 데이터와 그 데이터를 처리하는 부분 서버에서 들어오는 데이터, 디바이스에 저장되는 Local 데이터 View 👉 사용자에게 보여지는 UI 부분 ViewModel의 데이터가 변경된 것을 감지해 UI를 Update함 ViewModel 👉 View를 표현하기 위해 만든 View를 위한 Model View와 Model 을 연결 시켜 주는 곳 데이터의 변경사항을 알려주는 LiveData를 가지고 있음 Model 이 변경된 것을 감지하여 UI를 위한 데이터를 변경해야함 View는 Model을 모르지만 ViewModel을 알고 있음 ViewModel은 View를 모르지만 Model을 알고 있음 View를 통해 들어온 사용자 인터렉션은 ViewModel에게 전달되어 특정 로직이 실행됨 ✅ 즉, 의존성 분리 View와 Model 사이의 의존성이 없음 (View의 부담을 줄여줌) ViewModel은 Data Binding을 통해 View와 Model을 이어줌 각각의 부분은 독립적 이기 때문에 모듈화 하여 개발할 수 있음. ✅ 장점 View 와 data 가 완전 분리된다. View가 data관리를 할 필요가 없으므로 UI update에만 집중할 수 있음 각 View 간에 data 공유가 훨씬 쉬워진다. 유지보수의 장점 👉 의존성이 분리되므로, View의 코드를 변경할 때 다른 부분의 코드를 변경할 필요가 없음 ✅ 동작 순서 1️⃣ 사용자의 action이 View를 통해 들어옴 2️⃣ command 패턴을 사용하여 ViewModel에 Action을 전달함 3️⃣ ViewModel이 Model에서 data를 요청하고, Model은 ViewModel에서 요청받은 데이터를 ViewModel에 전달함 4️⃣ ViewModel은 응답받은 데이터를 가공, 저장함 5️⃣ View는 ViewModel과의 Data Binding을 이용해 화면을 갱신함 (Observer 패턴) 🍀 Swift with ViewModel ObservableObject를 이용하여 Data Model과 View를 쉽게 Binding할 수 있음 ObservableObject로 ViewModel을 설정하고, View 단에서는 ViewModel에 @ObservedObject를 붙여줌으로서 ViewModel의 변화를 관찰 할 수 있고, 그 변화에 반응할 수 있음☘️ @ObservableOjbect 해당 클래스의 인스턴스를 관찰하고 있다가 값이 변경되면 View를 Update한다. 예제 👇 class MainviewModel: ObservableObject {} ☘️ @Published ObservableOject 에서 속성을 선언할 때 사용 하는 PropertyWrapper 해당 속성이 업데이트 될 때마다 View를 Update, $ operator를 붙여 게시자에 엑세스 가능 @Published가 붙어있는 변수가 변경 되면 이를 지켜보고 있는 View에게 ViewModel이 변경되었음을 알려주고, View는 새로운 객체를 바탕으로 View를 Refresh 한다. Android 의 LiveData와 유사 예제 👇 class MainviewModel: ObservableObject { @Published var youngjun = Person(name: \"영준\", birthday: Date()) var name: String { youngjun.name } var age: String { return \"29\" } func changeName(_ name: String) { youngjun.name = name }} ☘️ @ObservedObject ObservableObject를 구독하고 값이 Update될 때 마다 View를 갱신하는 PropertyWrapper View를 만료시키고 새로 그림 ⚠️ View가 새로 그려질 때 마다 인스턴스가 새로 초기회됨 예제 👇 struct ContentView: View { @ObservedObject var viewModel = MainViewModel()} ☘️ @StateObject 단 한 번 인스턴스가 생성 View를 처음부터 새로 그리지 않고, ObservableObject에서의 데이터가 변할 때, 그 ObservableObject의 데이터가 들어간 부분만 View를 다시 그 림 View가 얼마나 다시 그려지든 상관없이 별개의 객체로 관리 예제 👇 struct ContentView: View { @StateObject var viewModel = MainViewModel()} ☘️ SharedViewModel 구현 ✅ 추천 Observable Object를 처음 초기화 할 때는 StateObject 를 사용하고, 이미 객체화된 것을 넘겨 받을 때는 ObservedObject를 사용 StateObject 와 ObservedObject를 사용하여 SharedViewModel을 사용가능 상위 View에서 객체로 만들어서 따로 저장해두고, 하위 View도 이 Observable Object의 변화를 감지하고, 같은 정보에 접근 할 수 있도록 할 수 있음 예제 👇 struct UpperView: View { @StateObject var viewModel: MainViewModel = MainViewModel() var body: some View { LowerView(viewModel: viewModel) }}struct LowerView: View { @ObservedObject var viewModel: ViewModel var body: some View { Text(\"Hello\") }} ☘️ @State DataBinding을 위해 사용 $ 키워드를 붙혀 DataBinding $가 붙으면 값을 수정가능한 Binding타입 참조 @State는 View 외부로는 사용할 수가 없고 private 형태로 내부에서만 사용 예제 👇 struct ContentView: View { @State var isToggleOn: Bool = true var body: some View { VStrck { Toggle(isOn: $isToggleOn) { Text(\"글자를 가립니다.\") }.padding() if isToggleOn { Text(\"그으으을자!\") } } }} ☘️ @Binding 2개의 View가 동시에 하나의 State를 참조 해야하는 경우 사용 예제 👇 struct Toggole: View { @Binding var isOn: Bool var body: some View { // TODO.. }} " }, { "title": "자료구조 Cookie, Session", "url": "/posts/Data-Structure-Cookie-Session/", "categories": "DataStructure", "tags": "cookie, session, data structure", "date": "2022-11-21 09:02:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 쿠키(Cookie)와 세션(Session)에 대하여 알아보고자 합니다.🍀 사용 이유 Cookie와 Session은 주로 자주 사용되는 데이터를 꺼내사용해야 하는 경우 사용됨 HTTP의 특징으로 인해 사용 👇 Connectionless(비 연결지향) 👉 HTTP는 기본적으로 요청&amp;응답만 하고 끊어버림 Stateless(상태정보유지안함) 👉 HTTP는 상태정보를 저장하지 않음, 따라서 Session 혹은 Cookie로 데이터를 저장함 🍀 Cookie (쿠키) 브라우저에 휘발성 데이터 를 저장하는 방식 유저들의 효율적이고 안전한 웹 사용을 보장하기 위하여 사용 웹 사이트 접속시 접속자의 개인 장치에 다운로드되고, 브라우저에 저장되는 작은 Text파일 웹 사이트는 쿠키를 통해 접속자의 장치를 인식하고, 접속자의 설정과 과거 이용내역에 대한 일부 데이터를 저장 참고 👉 특정 사이트에 가면, 자동적으로 아이디와 비밀번호가 입력 되는 경우 이름, 값, 만료날짜, 경로 정보가 들어있음 참고 👉 일정 시간동안 데이터를 저장할 수 있어서 로그인 상태를 유지 하거나, 사용자 정보를 일정 시간 동안 유지해야 하는 경우 에 주로 사용 Cookie가 생성되면 브라우저는 Request Header에 자동적으로 Cookie 정보를 넣어서 보내게 됨 참고 👉 매 요청마다 Cookie를 담아서 보냄 ✅ 사용 경우 1️⃣ Session관리 👉 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리 2️⃣ 개인화 👉 사용자 선호 테마 등의 세팅 3️⃣ 트래킹 👉 사용자의 행동을 기록하고 분석하는 용도 ❗️ 단점 ❗️ 사용자 정보가 누출될 수 있음. (보안성 낮음) ☘️ Cookie 의 Flow (흐름) 1️⃣ 웹 브라우저(Client)에서 서버로 요청(request) 2️⃣ 서버에서 상태를 유지하고 싶은 값을 Cookie로 생성 3️⃣ 서버가 응답(response)할 때 HTTP Header에 Cookie를 포함해서 Client에게 전송 4️⃣ Cookie는 Client에 파일 단위로 저장 5️⃣ 이후 Client에서 이 Cookie를 포함하여 요청(request)🍀 Session (세션) 서버 메모리에 저장되는 정보 참고 👉 서버에 저장되기 때문에 Cookie와는 달리 사용자 정보가 노출되지 않음 수명 👉 Client가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 끝날 때 까지의 기간 서버에 Session에 대한 정보(Session 상태, Client 상태, Session 데이터 등)를 저장해 놓고 Session Cookie(고유한 Session ID 값)를 Client에게 주어 서버가 Client를 식별할 수 있도록 하는 방식 자체를 의미 ✅ 특징 1️⃣ 따로 용량의 제한이 없음(서버의 능력에 따라 다를 수 있음) 2️⃣ 서버에 Session 객체를 생성하며, 각 Client 마다 고유한 Session ID 값을 부여함. 3️⃣ Cookie를 사용하여 Session ID 값을 Client에 보냄 4️⃣ 웹 브라우저가 종료되면 Session, Cookie는 삭제됨 ☘️ Session 의 Flow (흐름) 1️⃣ 웹 브라우저(Client)에서 서버로 요청(request) 2️⃣ 서버내부에서 해당 Client에게 Session ID를 부여 3️⃣ 서버가 응답(response)할 때 HTTP Header에 Session ID를 포함해서 Client에게 전송 4️⃣ 웹 브라우저(Client)는 이후 웹 브라우저(Client)를 닫기까지 부여된 Session ID를 기억함 5️⃣ 이후 Client에서 이 Session ID를 포함하여 요청(request) 6️⃣ 브라우저를 종료하면 Session ID를 삭제🍀 Cookie 와 Session 의 차이   Cookie Session 저장 위치 브라우저(Local) 서버 보안성 낮음 높음 수명 반영구 브라우저 종료시 삭제 속도 빠름 느림 " }, { "title": "Android Jetpack Compose DropDownMenu", "url": "/posts/Android-Jetpack-Compose-DropDownMenu/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, snackbar", "date": "2022-11-02 15:41:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 Compose에서 지원하는 펼쳐지는 메뉴인 DropDownMenu에 대하여 간다한 예제로 알아보도록 하겠습니다.🍎 DropDownMenu 버튼을 눌렀을 때 선택지를 보여주는 Menu item 구성요소 expanded 👉 DropDownMenu가 펼쳐졌는지 여부 onDismissRequest 👉 DropDownMenu를 닫으라는 명령이 떨어졌을 때의 Callback offset 👉 DropDownMenu를 호출하는 Composable의 기준점으로부터의 거리(offset)을 설정 ⚠️주의⚠️ DropDownMenu는 내부에서 DropDownMenuPositionProvider에 의해 자동으로 위치가 조정되어 화면 상에 표시됨 properties 👉 Back Button을 눌렀을 때 DropDownMenu를 Dismiss할 것인지, DropDownMenu의 바깥쪽을 눌렀을 때 Dismiss할 것인지 등의 DropDownMenu의 기본 동작을 정의 content 👉 DropDownMenu안에 들어갈 Menu Item을 넣는 공간, @Composable 넣기, 람다 형식 🍀 DropDownMenuItem onClick 👉 Menu Item을 눌렀을 때 Callback enabled 👉 Menu Item을 클릭 가능하게 할 것인지 여부 contentPadding 👉 DropDownMenuItem에 적용할 Padding 값 interactionSource 👉 DropDownMenuItem과 사용자와의 Interaction에 대한 Event를 관리. content 👉 DropDownMenuItem에 표기할 요소 관리, @Composable넣기, 람다 형식 예제 DropDownMenu + DropDownMenuItem 을 사용 필수 3가지 요소 DropDownMenu가 펼처지는지 제어할 수 있는 변수 필요 DropDownMenu의 펼처짐 상태를 제어하기 위한 버튼 혹은 onClick Event를 포함한 Composable 필요 DropDownMenu 정의 @Composablefun ButtonWithDropDownMenu() { // 1. DropDownMenu 펼처짐 여부 상태 val isExpanded = remember { mutableStateOf(false) } // 2. DropDownMenu 를 Controller 할 버튼 및 Event 생성 Button(onClick = { isExpanded.value = true }) { Text(text = \"Show Menu\") } // 3. DropDownMenu 정의 DropdownMenu( modifier = Modifier.wrapContentSize(), expanded = isExpanded.value, offset = DpOffset(0.dp, 12.dp), onDismissRequest = { isExpanded.value = false } ) { // 4. DropDownMenuItem 을 정의 DropdownMenuItem(onClick = { println(\"Hello\") }) { Text(text = \"Print Hello\") } DropdownMenuItem(onClick = { println(\"Compose Dropdown\") }) { Text(text = \"Print Compose Dropdown\") } }}" }, { "title": "Android Jetpack Compose Snackbar", "url": "/posts/Android-Jetpack-Compse-Snackbar/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, snackbar", "date": "2022-11-02 14:09:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 Android Jetpack Compose 에서 snackbar 를 사용하는 방법에 대하여 간단한 예제를 통해 알아보고자 합니다.🍎 Scaffold 를 사용하여 Snackbar 만들기 Compose 에서 Snackbar를 기존 Snackbar의 동작대로 이용하기 위해서는 Scaffold State로 감싸야 함 ⚠️ 주의 ⚠️ 최상단 Component를 Scaffold로 감싸줘야 rememberScaffoldState()를 사용하여 snackbar 사용가능 만약 Scaffold로 감싸지 않으면 보통의 Composable과 같이 동작함 Coroutine Builder 내부에서 Snackbar가 불려야함 rememberScaffoldState() 👉 Scaffold를 사용 예제 👇@Composablefun NoteScreen( navController: NavController, scaffoldState: ScaffoldState, onActionButtonClick: () -&gt; Unit) { Scaffold( topBar = { TopAppBar( title = { Text(text = stringResource(id = R.string.app_name)) }, actions = { IconButton( onClick = { navController.navigate(route = NavigationType.SEARCH_SCREEN.name) } ) { Icon(imageVector = Icons.Default.Search, contentDescription = \"Search\") } }, backgroundColor = Color.White ) }, scaffoldState = scaffoldState, // state 연결 floatingActionButton = { onActionButtonClick() }, floatingActionButtonPosition = FabPosition.End, ) { // TODO:: do something... }}fun NoteNavigation(viewModel: NoteViewModel) { val navController = rememberNavController() // SnackBar val scaffoldState = rememberScaffoldState() val coroutineScope = rememberCoroutineScope() NavHost( navController = navController, startDestination = NavigationType.HOME_SCREEN.name ) { composable (route = NavigationType.HOME_SCREEN.name) { NoteScreen( navController = navController, scaffoldState = scaffoldState, ) { scaffoldState.snackbarHostState.showSnackbar(\"Floating Action Button Click\") } } }}" }, { "title": "Android Jetpack Compose Tab + ViewPager", "url": "/posts/Android-Jetpack-Compose-Tab-ViewPager/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, viewpager, tab", "date": "2022-11-02 13:47:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 Android Jetpack Compose 에서 Tab + ViewPager 를 사용하는 방법에 대하여 예제를 통해 알아보고자 합니다.🍎 Tab + ViewPager 기존 TabLayout + ViewPager2 를 Compose 에서 사용하기🍀 1. Dependency 추가 (build.gradle)implementation \"com.google.accompanist:accompanist-pager:0.20.1\"implementation \"com.google.accompanist:accompanist-pager-indicators:0.20.1\"🍀 2. rememberPagerState rememberPagerState 👉 TabRow 와 Pager 객체에서 공유할 데이터 현재 몇 페이지에 있는지 저장 rememberCoroutineScrope 👉 Composable에서 페이지를 이동하는 동작은 CoroutineScope에서 수행되어야 함 TabRow 👉 기존 TabLayout 과 같음 selectedTabIndex 👉 현재 선택된 페이지 Index indicator 👉 indicator 설정 HorizontalPager 👉 기존 ViewPager2 와 같음@Composablefun TabViewPagerScreen( pages: List&lt;String&gt; = listOf(\"페이지1\", \"페이지2\", \"페이지3\")) { val pagerState = rememberPagerState() val coroutineScope = rememberCoroutineScope() Surface( modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background, ) { Column( modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.Center, ) { TabRow( selectedTabIndex = pagerState.currentPage, indicator = { tabPositions: List&lt;TabPosition&gt; -&gt; TabRowDefaults.Indicator( Modifier.pagerTabIndicatoroffset(pagerState, tabPositions) ) } ) { // pages 개수 만큼 Tab 만들기 pages.forEachIndexed { index, title -&gt; Tab( text = { Text(text = title) }, selected = pagerState.currentPosition == index, onClick = { // Tab 클릭 시 해당 페이지로 스크롤링 coroutineScope.launch { pagerState.scrollToPage(index) } } ) } } } // ViewPager2 HorizontalPager(count = pagers.size, state = pagerState) { page -&gt; Text( modifier = Modifier.wrapContentSize(), text = page.toString(), textAlign = TextAlign.Center, fontSize = 30.sp ) } }}" }, { "title": "Android Jetpack Compose Navigation", "url": "/posts/Android-Jetpack-Compose-Navigation/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, navigation", "date": "2022-11-02 13:06:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 Compose 의 화면전화에 사용되는 Compose Navigation에 대하여 알아보겠습니다.🍎 Compose Navigation🍀 1. Dependency 추가 (build.gradle)implementation \"androidx.navigation:navigation-compose:2.5.3\"🍀 2. rememberNavController navigation 구성요소의 중심 API Stateful 이며, 앱의 화면과 각 화면 상태를 구성하는 Composable Back Stack을 추적함 모든 Composable이 접근할 수 있는 곳에 만들어야 함 즉, 최상위 함수 예제 👇 처음 시작 시 HomeScreen 을 보여주고 Click 시 DetailScreen 으로 이동 NavGraph 설정 @Composablefun MovieNavigation() { val navController = rememberNavController() // Navigation Graph 를 그림 NavHost( navController = navController, startDestination = MovieScreen.HomeScreen.name // 처음 시작화면 설정 ) { composable(route = MovieScreen.HomeScreen.name) { HomeScreen(navController = navConttoller) } // \"/{movie}\" -&gt; DetailScreen 에서 사용할 파라미터 이름 (데이터를 넘김) // 하나의 DetailScreen 을 여러군데에서 재사용하므로 Unique Key 필요 composable( route = MovieScreen.DetailScreen.name + \"/{movie}\", argument = listOf(navArgument(name = \"movie\") { type = NavType.StringType }) ) { DetailScreen( navController = navController, it.argument?.getString(\"movie\") ) } }}enum class MovieScreen { HomeScreen, DetailScreen} 예제 👇 Navigation을 활용하여 HomeScreen -&gt; DetailScreen 이동 navController.navigate(route = MovieScreens.DetailScreen.name + \"/$보내는 값\") 예제 👇 Navigation 뒤로가기 navController.popBackStack()🍀 3. Navigation + Dialog 예제 👇 Custom Dialog 를 생성하여 Navigation 으로 띄우기 NavGraph에 Custom Dialog 등록 @Composablefun NoteNavigation(viewModel: NoteViewModel) { val navController = rememberNavController() val coroutineScope = rememberCoroutineScope() // CustomDialog val customDialogTitle = viewModel.customDialogTitle.collectAsState() val customDialogConfirmText = viewModel.customDialogConfirmText.collectAsState() val customDialogCancelText = viewModel.customDialogCancelText.collectAsState() NavHost( navController = navController, startDestination = NoteNavigation.HomeScreen.name ) { composable(route = NoteNavigation.HomeScreen.name) { NoteScreen(navController = navController) } dialog( route = NoteNavigation.CustomDialog.name, dialogProperies = DialogProperties( dismissOnBackPress = true, dismissOnClickOutside = true, ) ) { CustomDialog( navController = navController, value = customDialogTitle.value.first, valueRes= customDialogTitle.value.second, confirmText = customDialogConfirmText.value, cancelText = customDialogCancelText.value, ) { coroutineScope.launch { if (customDialogTitle.value.second == R.string.dialog_all_remove_title) { viewModel.removeAllNote() return@launch } viewModel.currentNote.value?.let { if (customDialogTitle.value.second == R.string.dialog_modify_title) { viewModel.updateNote(it) scaffoldState.snackbarHostState.showSnackbar(\"${it.title}를 수정하였습니다.\") return@launch } viewModel.removeNote(it) scaffoldState.snackbarHostState.showSnackbar(\"${it.title}를 삭제하였습니다.\") } } } } }} 예제 👇 Custom Dialog 생성 참고 @Composablefun CustomDialog( navController: NavController, value: String, @StringRes valueRes: Int? = null, @StringRes confirmText: Int, @StringRes cancelText: Int, onConfirmClick: () -&gt; Unit,) { Surface( shape = RoundedCornerShape(16.dp), color = Color.White ) { Box(contentAlignment = Alignment.Center) { Column { Row( modifier = Modifier .fillMaxWidth() .padding(10.dp), horizontalArrangement = Arrangement.End, ) { Icon(imageVector = Icons.Filled.Cancel, contentDescription = \"\", modifier = Modifier .width(30.dp) .height(30.dp) .clickable { navController.popBackStack() }) } Row( modifier = Modifier .fillMaxWidth() .padding(10.dp), horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically ) { Text( text = if (valueRes != null) { stringResource(id = valueRes, value) } else { value }, style = TextStyle( fontSize = 20.sp, fontFamily = FontFamily.Default, fontWeight = FontWeight.Bold ) ) } Spacer(modifier = Modifier.height(20.dp)) Row( modifier = Modifier .fillMaxWidth() .padding(20.dp) ) { Button( onClick = { navController.popBackStack() /** * navController.currentBackStackEntry?.destination?.route * -&gt; 현재 Navigation Route 이름 가져오기 */ if (navController.currentBackStackEntry?.destination?.route == NavigationType.DETAIL_SCREEN.name) { navController.popBackStack() } onConfirmClick() }, shape = RoundedCornerShape(50.dp), modifier = Modifier .height(50.dp) .padding(end = 10.dp) .weight(1f) ) { Text(text = stringResource(id = confirmText)) } Button( onClick = { navController.popBackStack() }, shape = RoundedCornerShape(50.dp), modifier = Modifier .height(50.dp) .padding(start = 10.dp) .weight(1f), colors = ButtonDefaults.buttonColors( backgroundColor = Color.White, contentColor = Color.Black, ) ) { Text( text = stringResource(id = cancelText), style = TextStyle(color = Color.Black) ) } } } } }}🍎 Compose BottomSheet Navigation🍀 1. Dependency 추가 (build.gradle) Jetpack Navigation Compose Material 사용 공식 홈페이지 자세한 설명 implementation \"com.google.accompanist:accompanist-navigation-material:0.27.0\"🍀 2. rememberNavController, rememberBottomSheetNavigator rememberBottomSheetNavigator, rememberNavController를 사용하여 NavGraph 작성@Composablefun MovieNavigation(mainViewModel: MainViewModel) { val bottomSheetNavigator = rememberBottomSheetNavigator() val navController = rememberNavController(bottomSheetNavigator) ModalBottomSheetLayout( bottomSheetNavigator = bottomSheetNavigator, sheetShape = RoundedCornerShape(topEnd = 16.dp, topStart = 16.dp), ) { NavHost( navController = navController, startDestination = NavigationType.HomeScreen.name ) { composable(route = NavigationType.HomeScreen.name) { HomeScreen(navController = navController) } bottomSheet(route = NavigationType.BottomSheet.name) { Text(\"This is a cool bottom sheet!\") } } }} 예제 👇 화면 전환navController.navigate(route = NavigationType.BottomSheet.name) 예제 👇 뒤로가기navController.popBackStack()🍀 3. Navigating with Arguments bottomSheet 에 데이터 전달 예제 👇@Composablefun MyNavigation(mainViewModel: MainViewModel) { val navController = rememberNavController() val bottomSheetNavigator = rememberBottomSheetNavigator() navController.navigatorProvider += bottomSheetNavigator ModalBottomSheetLayout(bottomSheetNavigator) { NavHost(navController, startDestination = \"home\") { composable(route = \"home\") { Button(onClick = { navController.navigate(\"sheet?message=hellow_world\") }) { Text(\"Click me to see something cool!\") } } bottomSheet(route = \"sheet?message={message}\") { backStackEntry -&gt; val message = backStackEntry.arguments?.getString(\"message\") Text(\"This is a cool bottom Sheet\") if (message != null) { Text(\"Magic message: $message\") } Button(onClick = { navController.navigate(\"home\") }) { Text(\"Take me back, please\") } } } }}" }, { "title": "Android Jetpack Compose Side Effect", "url": "/posts/Android-Jetpack-Compose-SideEffect/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, side-effect", "date": "2022-11-02 11:16:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 Side-Effect에 대하여 알아보도록 하겠습니다.🍎 Side Effect Composable 범위 밖에서 발생하는 앱 상태에 대한 변경 Composable은 각각의 Lifecycle을 가지고 있음 Composable은 단방향으로만 State를 전달 Composable을 사용할 떄 여러 Composable들을 겹쳐서 사용함. 그러면 System은 각 Composable에 대한 Lifecycle을 만들고 Composable별로 재구성이 필요할때만 재구성 시킨다. Composable은 기본적으로 바깥쪽 Composable이 안쪽 Composable로 State를 내려줌. 이로 인해 단방향으로만 의존성이 생김 ⚠️ 하지만, 만약 안쪽에 있는 Composable에서 바깥쪽에 있는 Composable의 상태에 대한 변경을 준다면??혹은 Composable에서 Composable 이 아닌 앱 State에 대한 변화를 준다면?? 👇 양방향 의존성으로 인해 예측할 수 없는 Effect가 생긴다. 이를 Side Effect라 부름 🍎 Side Effect 처리하기 LaunchedEffect 👉 Composable Lifecycle Scope에서 suspend fun을 실행하기 위해 사용 DisposableEffect 👉 Composable이 Dispose될 때 정리되어야 할 Side Effect를 정의하기 위해 사용 SideEffect 👉 Composable의 State를 Compose에서 관리하지 않는 객체와 공유하기 위해 사용 Compose는 위 3가지와 함께 사용할 수 있는 여러 CoroutineScope와 State관련 함수를 제공 rememberCoroutineScope 👉 Composable의 CoroutineScope를 참조하여 외부에서 실행할 수 있도록 해줌 rememberUpdatedState 👉 Launded Effect는 Composable의 State가 변경되면 재실행되는데 재실행되지 않아도 되는 State를 정의하기 위해 사용 produceState 👉 Compose State가 아닌 것을 Compose의 State로 변환 derivedStateOf 👉 State를 다른 State로 변환하기 위해 사용, Composable은 변환된 State에만 영향을 미침 snapshotFlow 👉 Composable의 State를 Flow로 변환 🍀 1. Launched Effect Composable 에서 Composition이 일어날 때 suspend fun을 실행해주는 Composable 임 ⚠️ Recomposition은 Composable의 State가 바뀔때마다 일어나므로 Recomposition이 일어날때마다 이전 Launched Effect가 취소되고 다시 수행된다면 매우 비효율적 ✅ 이를 해결하기 위해 LaunchedEffect는 key라 불리는 기준값을 두어 key가 바뀔때만 LaunchedEffect의 suspend fun을 취소하고 재실행함 예제 👇 LaunchedEffect 에서 한번만 실행되어야 하는 동작 처리 한번만 실행해야 하는 경우 key값에 true나 Unit을 넘겨주는 방향으로 설계 @Composablefun KotlinWorldScreen(oneTimeEffect: () -&gt; String) { LaunchedEffect(true) { onTimeEffect() }} 예제 👇 LaunchedEffect 에서 한번만 실행되어야 하는데 동작이 길때 긴 동작의 람다식을 처리할 때 👉 rememberUpdatedState 를 사용하여 launch를 기억해야 함 fun KotlinWorldScreen(longTimeJob: suspend () -&gt; String) { val rememberLongTimeJob by rememberUpdatedState(longTimeJob) LaunchedEffect(true) { println(rememberLongTimeJob()) }}🍀 2. Disposable Effect Composable이 Dispose된 후에 정리해야 할 Side Effect가 있는 경우에 사용되는 Effect Composable의 Lifecycle에 맞춰 정리되어야 하는 Listener나 작업이 있는 경우에 Listener나 작업을 제거하기 위해 사용되는 Effect ⚠️ Lifecycle에 따라 Side Effect를 발생시킨 다음 정리되어야 하는 부분이 많을 경우 제대로 Side Effect에 대한 정리를 하지 않으면 Memory Leak(메모리 누수)가 발생할 수 있음 첫 번쨰 인자 key 👉 key 값이 바뀔때 마다 effect 호출 두 번째 인자 effect Effect 블럭은 처음에는 초기화 로직만 수행하고 이후에는 key 값이 바뀔때마다 onDispose 블록을 호출한 후 초기화 로직을 다시 호출함 onDispose 블록의 return값이 바로 DisposableEffect 여서 onDispose블록은 effect람다식의 맨 마지막에 무조건 와야함 예제 👇DisposableEffect(key) { // Composable 이 제거될 때 Dispose 되어야 하는 효과 초기화 onDispose { // Composable 이 Dispose 될 때 호출되어 Dispose 되어야 하는 효과 제거 }} 예제 👇 사용자의 사용 패턴 분석을 위한 로깅 (Activity 의 onStart()에서 시작되어 onStop()에서 끝나야 함) Lifecycle 이 바뀔 때 새로운 Observer가 Lifecycle에 붙어 변화를 구독하고 Composable이 제거될 떄 Observer 또한 제거되도록 구현 @Composablefun HomeScreen( lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current, _onStartLogging: () -&gt; Unit, _onStopLogging: () -&gt; Unit,) { val startLoggingOnStart by rememberUpdatedState(_onStartLogging) val stopLoggingOnStop by rememberUpdatedState(_onStopLogging) DisposableEffect(lifecycleOwner) { val observer = LifecycleEventObserver { _, event -&gt; if (event == Lifecycle.Event.ON_START) { startLoggingOnStart() } else { stopLoggingOnStop() } } lifecycleOwner.lifecycle.addObserver(observer) onDispose { lifecycleOwner.lifecycle.removeObserver(observer) } }}🍀 3. SideEffect Composable의 Composition이 성공적으로 되었을 때 발생하는 Effect Compose에서 관리하지 않는 객체와 Compose 내부의 데이터를 공유하기 위해 사용 ⚠️ SideEffect 의 한계점 SideEffect로 수행하는 Effect는 Composable이 Dispose될 때 정리가 불가능 SideEffect는 LaunchedEffect or DisposableEffect로 충분히 대체 가능 예제 👇 FocusRequester 의 requestFocus는 Composable이 아닌 System의 Event이므로 Composable 이 관리하는 Event 가 아님 따라서, Composable의 구성이 완료된 이후에 requestFocus가 호출되도록 보장하려면 SideEffect를 사용해야 함 @Composablefun HomeScreen() { var isVisible by remember { mutableStateOf(false) } // Composable 이 아닌 System의 Event val focusRequester = remember { FocusRequester() } Column (modifier = Modifier.fillMaxSize()) { Button(onClick = { isVisible = true }) { Text(text = \"버튼 클릭\") } if (isVisible) { OutlinedTextField( modifier = Modifier.fillMaxSize() .focusRequester(focusRequester), value = \"\", onValueChange={} ) } } SideEffect { if (isVisible) { focusRequester.requestFocus() } }}" }, { "title": "Android Jetpack Compose Remember, State<T>", "url": "/posts/Android-Jetpack-Compose-State/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, remember, state", "date": "2022-11-02 10:05:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Jetpack Compose 에서 사용되는 remember 와 state 에 대하여 알아보도록 하겠습니다.🍎 State / Remember🍀 1. State 상태 변경에 대응하는 것은 Compose의 핵심 Compose앱은 Composable함수를 호출하여 데이터를 UI로 변환하는데, 데이터가 변경되면 새 데이터로 이러한 기능을 호출하여 Update 된 UI를 만든다 recomposing Compose는 기존의 Observer 패턴과 같이 앱 데이터의 변경 사항을 관찰하기 위한 도구를 제공한다. Compose는 데이터가 변경된 구성 요소만 재구성 하고, 영향을 받지 않은 구성을 건너 뛸 수 있도록 개별 구성에 필요한 데이터를 확인한다. ⚠️ 주의 ⚠️ @Composable 함수는 recompose되기 때문에 변수를 함수 내부에서 선언하면 안됨 (함수가 재시작될때마다 초기화되기 때문) Compose 는 State 값이 변경되면 해당 요소가 다시 그려짐(Recomposing) 하나의 Component에서 State 변화가 일어나면 해당 Component는 recomposing 을 거치고 이때 remember 키워드를 통해 state 를 기억함으로써 성공적으로 UI를 업데이트 한다.🍀 2. Remember 이 변수는 initial composition에서 메모리에 저장되어, recompose때에 값을 반환받아 사용 가능 recompose로 인한 함수의 재호출과 상관없이 변숫 값이 유지될 수 있다. Composition 이 유지되는 동안에만 적용 즉, Composition 이 그려지는 밑바닥의 activity/fragment의 Lifecycle이 변경되면 State 또한 초기화됨 해당 Composable function이 composition 에서 제걸될 때 마다 같이 제거된다. ⚠️ 주의 ⚠️ Configuration change 발생 시 값이 유지되지 않음. (기기 회전, 다크 모드적용 등등..) rememberSaveable 👉 Configuration Change에도 State가 살아 있도록 해줌🍀 3. MutableState mutableStateOf(defaultValue) 를 사용하여 만듬 State&lt;T&gt; 타입의 변수를 Runtime 에 Observing 할 수 있다 State의 value 가 변경되면 이 값을 읽어가는 Compose 들은 Recompose 대상이 된다. 예제 👇 MutableState 객체를 Composable function 내부에 선언하는 3가지 방법val mutableState = remember { mutableStateOf(기본값) }var value by remember { mutableStateOf(기본값) }val (value, setValue) = remember { mutableStateOf(기본값) } 예제 👇@Composablefun MyScreenContent(names: List&lt;String&gt; = listOf(\"android\", \"compose\")) { val counterState = remember { mutableStateOf(0) } Column { names.forEach { Greeting(name = it) Divder(color = Color.Black) } Divider(color = Color.Transparent, thickness = 32.dp) Counter(counterState.value) { counterState.value = it } }}@Composablefun Counter(counte: Int, updateCount: (Int) -&gt; Unit) { Button(onClick = { updateCount(count + 1) }) { Text(text = \"$count 번 클릭하셨어요!\") }}🍀 4. ViewModel 에 State 사용 Compose에서는 State 변화시에 해당 State와 연결된 Composable이 Recomposition을 거치기 때문에 ViewModel에서 State와 이를 Update하는 함수를 직접 선언하고 Composable 함수 매개변수로 ViewModel을 받아 사용 LiveData, Flow -&gt; State 변환 LiveData 👉 LiveData.observeAsState() Flow 👉 Flow.collectAsState() 예제 👇class TodoViewModel : ViewModel() { var todoItems = mutableStateListOf&lt;TodoItem&gt;() private set fun addItem(item: TodoItem) { todoItems.add(item) } fun removeItem(item: TodoItem) { todoItems.remove(item) }} 예제 👇 위 ViewModel 사용✅ state holder 설정 만약 실제 UI를 그리는 TodoScreen 에 직접 ViewModel 을 전달하면 Preview 기능을 사용하기 어려워지고 테스트 가능성이 떨어짐 따라서, UI 를 직접 그리는 Composable에는 ViewModel 을 직접 주입하지 않고 State Holder 를 담당하는 Composable 을 한 단계 거치도록 함 // MyScreen -&gt; state holder 를 담당하는 @Composable@Composablefun MyScreen(todoViewModel: TodoViewModel) { TodoScreen( items = todoViewModel.todoItems, onAddItem = todoViewModel::addItem, onRemoveItem = todoViewModel::removeItem, )} 예제 👇 Flow&lt;T&gt;.collectAsState() 사용 ViewModel 에서 StateFlow 등록 후 .collectAsState()를 사용 시 Configuration Change 발생 시에도 값을 유지할 수 있음 class NoteViewModel : ViewModel() { private val _searchValue = MutableStateFlow(\"\") val searchValue = _searchValue.asStateFlow() fun setSearchValue(query: String) { _searchValue.value = query }}@Composablefun NoteNavigation(viewModel: NoteViewModel) { val navController = rememberNavController() val searchValue = viewModel.searchValue.collectAsState() // TODO:: something do..}🍎 Stateless 를 위한 State Hoisting stateful - state를 갖고 있으며 이를 직접 변경할 수 없는 Composable stateless - state를 갖고있지 않고, state를 선언하는 것이 아닌 주입받는 방식 state hoisting 개발자는 최대한 stateful composable을 줄이고, 이들을 stateless로 변경하는 것이 이상적 하위의 Composable에 선언된 State들을 이들의 공통 조상인 상위 Composable로 옮기는 방식으로 수행 장점 state를 한 곳에서만 관리함으로써 버그 방지에 도움이됨 Hoisting 한 State를 여러 Composable과 공유할 수 있음 🍀 State 를 어느 수준의 Composable 까지 끌어올려야 할지 쉽게 파악할 수 있는 규칙 3가지 읽기 👉 State는 적어도 이를 사용하는 모든 Composable의 가장 낮은 공통 상위 요소로 끌어 올려야함 쓰기 👉 State는 최소한 이를 변경할 수 있는 Composable중 가장 상위 Composable로 끌어올려야 함 동일한 Event에 대한 응답으로 두 State가 변경되는 경우 두 State를 같이 끌어 올려야함 예제 👇 Button을 통해 Component를 숨기고 표시@Composablefun MyScreen() { val visible = remember { mutableStateOf(true) } Column() { if (visible.value) MyCard() MyButton(onClick = { visible.value = !visible.value }, visible = visible.value) }}@Composablefun MyButton(onClic: () -&gt; Unit, visible: Boolean) { Button(onClick = onClick) { Text(if(visible) \"show\" else \"hide\") }} 🍬 참고 🍬 MyButton에 State를 선언할 필요없이, 적당한 상단 Composable에 State를 선언한 뒤 State의 Value나 State를 변경하는 함수만 전달해주면 stateless를 유지한 채 구현할 수 있음 🍎 Composable 에서 올바른 CoroutinScope Composable 내부에서 Coroutine을 수행할 경우 Composable에 대한 Recomposition이 일어날 때 정리되어야 하는 Coroutine이 정리가 안된 상태로 계속해서 Coroutine이 쌓일 수 있음 Composable 에서 Coroutine을 생성한다면 Recomposition이 일어날 때 취소되어야 함 rememberCoroutineScope Composable의 Lifecycle을 따르는 CoroutineScope 를 반환 Composable 이 파괴되면 자동으로 Coroutine Job 파괴 Composable 이 파괴될 때 파괴되는 Coroutine을 생성해야될 때에는 rememberCoroutineScope 사용 " }, { "title": "Android Compose Animation 기초", "url": "/posts/Android-Compose-Animation/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, animation, alpha", "date": "2022-11-02 09:19:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Compose에서 Animation 을 사용하는 법에 대하여 알아보고자 합니다.Animation에 대한 이해가 아직 부족하여 보다 자세히 알고 싶으시면 밑의 링크를 참고하세요.Simple AnimationDeep Animation🍎 1. animateColorAsState UI 변경시의 Animation 사용 animatedColorAsState(Color 값 넣기) 예제 animateColorAsState 를 사용하여 텍스트가 클릭된 상태면 빨간색, 아니라면 투명색 배경 지정 👇@Composablefun Greeting(name: String) { var isSelected by remember { mutableStateOf(false) } val backgroundColor by animatedColorAsState(if (isSelected) Color.Red else Color.Transparent) Text( text = \"안녕하세요 $name\", modifier = Modifier .padding(24.dp) .backgroundColor(color = backgroundColor) .clickable(onClick = { isSelected = !isSelected }) )}🍎 2. CompositionLocalProvider alpha 값을 설정하기 위해 사용 해당 블럭안에 있는 모든 하위 계층의 Composable 들에게 영향을 줌 LocalContentAlpha Material Theme Level 에서 사용하는 Text, Icon 을 위한 alpha 값 기본값 👉 1f, 투명도가 없이 보여짐 예제 👇@Composablefun PhotoGrapherCard() { Coloumn { Text(text = \"안드로이드\", fontWeight = FontWeight.Bold) CompositionLocalProvider(LocalContentAlpha provides ContentAlpha.medium) { Text(text = \"3 minutes ago\", style = MaterialTheme.typography.body2) } }}🍎 3. Animatable animateTo 를 통해 값이 변경될 때 자동으로 값에 Animation 을 적용하는 값 홀더 첫 번째 인자 initialValue 👉 초기 값 두 번째 인자 typeConverter 👉 Animation 객체에 사용할 AnimationVector 세 번째 인자 visibilityThreshold 👉 가시성 임계값 내부 필드 value 👉 Animation 의 현재 값 targetValue 👉 현재 Animation 의 대상 animateTo 👉 targetValue 값을 향해 Animation 을 시작 animateTo 인자 targetValue, animationSpec, initialVelocity, block 이 있음 targetValue 👉 Animation 도달 값, 이 값이 작을 수록 Animation 이 작아짐 initialVelocity 👉 Animation 의 시작 값을 의미 block 👉 매 Animation 프레임 마다 호출됨 예제 Splash 화면👇원이 커졌다가 작아지는 Animation, Animation 이 끝나면 다음 화면으로 진입@Composablefun WeatherSplashScreen(navController: NavController) { val scale = remember { Animatable(initialValue = 0f) } // LaunchedEffect : key1 이 바뀔때마다 블록내의 동작을 중지하고 다시 시작함 // LaunchedEffect 에서 한 번만 실행되어야 하는 동작을 처리하기 위해 true를 넣음 LaunchedEffect(key1 = true) { scale.animateTo( targetValue = 0.9f, // 이 값이 작을 수록 Animation 이 작아짐 animationSpec = tween( durationMillis = 800, // 이 값이 커질수록 Animation 이 늦게 끝남 easing = { OvershootInterpolator(8f).getInterpolation(it) } ) ) // Animation 이 끝나고 2초 뒤 MainScreen 으로 이동 delay(2000L) navController.navigate(WeatherScreens.MainScreen.name) } Surface( modifier = Modifier .padding(15.dp) .size(330.dp) .scale(scale.value), shape = CircleShape, color = Color.White, border = BorderStroke(width = 2.dp, color = Color.LightGray) ) { Column( modifier = Modifier.padding(1.dp), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center ) { Image( painter = painterResource(id = R.drawable.sun), contentDescription = \"sunny icon\", contentScale = ContentScale.Fit, modifier = Modifier.size(95.dp) ) Text( text = \"Find the Sun?\", style = MaterialTheme.typography.h5, color = Color.LightGray ) } }}" }, { "title": "Android Compose 기초", "url": "/posts/Android-Jetpack-Compose/", "categories": "Android, Jetpack-Compose", "tags": "android, jetpack, compose, surface, modifier, row, column", "date": "2022-11-01 16:19:00 +0900", "snippet": "녕하세요. Narvis2 입니다.이번 시간에는 Android jetpack Compose 에 대하여 알아보겠습니다.🍎 Jetpack Compose 선언형 UI, 특정 상태에 따라 UI가 무엇을 보여주면 되는지 상태에 따른 UI를 작성하기 위해 훨씬 적은 코드를 사용 유지보수 측면에서 유리 View의 속성등의 구현을 할 경우 경우에 따라 상세하게 작성하지 않아도 되므로 재사용, 확장성에 용이 Fragment를 더 이상 사용하지 않아도 됩니다.🍀 1. @Composable 데이터를 받아서 UI요소로 Emit 하는 함수 컴파일러에게 데이터가 UI를 변한하기 위한 함수임을 알림 파라미터로 데이터를 받아서 사용할 수 있음 아무것도 return 하지 않는다 명등원이며, Side-Effect가 없음 🍬참고🍬 명등성 👉 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질 Composable 함수는 순서와 관계없이 실행 가능하다. 즉, @Composable 이 붙어있는 함수 내부에 다른 @Composable 함수 호출이 포함되어 있는 경우 Composable 함수는 순서와 관계없이 실행 가능 재구성은 최대한 많은 수의 Composable 함수 및 람다를 건너뜀 재구성은 낙관적이며, 취소가 될 수 있음 Composable 함수는 Animation 의 모든 프레임과 같은 빈도로 매우 자주 실행될 수 있음 데이터 변경 시 데이터가 변경된 위젯만 새로 그려짐 SharedPreference에서 값을 읽어오는 것과 같이 비용이 많이드는 작업은 Background Thread에서 실행하여 결과값을 Composable 함수의 파라미터로 전달해야함 Composable 외부에서 Background Thread에서 실행하고 LiveData 나 StateFlow 등을 사용하여 결과 받기 🍀 2. Surface 요소를 감싸는 Container 와 같은 역할을 하는 요소, 배경의 색상을 변경할 수 있음 예제 👇@Composablefun Greeting(name: String) { Surface(color = Purple200) { Text(text=\"Hello $name\") }}🍀 3. Modifiers 구성요소의 크기, 마진등을 변경하거나 클릭이나 스크롤등의 이벤트를 제어할 수 있도록 함 UI를 꾸미고 상호작용 Surface와 Text와 같은 대부분의 UI Component의 위치를 지정할 수 있음(위치, 색상, 스타일 수정) Modifier의 순서는 결과에 영향을 주므로 중요 예제 👇@Composablefun Greeting(name: String) { Text(text=\"Hello $name\", modifier = Modifier.Padding(2.dp))}🍀 4. Divider 수평 구분선 역할🍀 5. Column 내부 Component들을 수평방향으로 배치 예제 👇@Composablefun MyScreenContent(name: List&lt;String&gt; = listOf(\"안드로이드\", \"컴포즈\")) { Column { names.forEach { Greeting(name = it) Divider(color = Color.Black) } }}🍀 6. Row 내부 Component들을 수직방향으로 배치 예제 👇@Composablefun ComposeRow() { Row { Text(text= \"Text1\") Text(text= \"Text2\") }}🍀 7. Box 구성요소를 다른 구성요소 위에 배치fun ComposeBox() { Box { Text(text=\"Text1\") Text(text=\"Text2\") }}🍀 8. LazyColumn, LazyRow RecyclerView와 동일한 기능 LazyColumn 👉 RecyclerView orientation Vertical LazyRow 👉 RecyclerView orientation Horizontal View를 재활용하지는 않음, 스크롤할때 새로운 Composable을 내보냄 참고 👉 새로운 Composable을 내보내는 것이 기존의 방법인 View를 instance하는 것에 비해 상대적으로 효율적임 예제 👇 LazyColumn@Composablefun MyScreenContent(names: List&lt;String&gt; = List(100) {\"안드로이드 $it\"}) { val counterState = remember { mutableStateOf(0) } Column(modifier = Modifier.fillMaxHeight()) { NameList(names = names, Modifier.weight(1f)) Counter(counterState.value) { counterState.value = it } }}@Composablefun NameList(names: List&lt;String&gt;, modifier: Modifier = Modifier) { LazyColumn(modifier = modifier) { items(items = names) { name -&gt; Greeting(name = name) Divider(color = Color.Black) } }} 예제 👇 LazyColumn Scroll Controll rememberLazyListState() 사용 LazyColum, LazyRow 의 스크롤 위치를 기억 맨위로 끌어당기기, 맨 아래로 넘기기 등에 사용 @Composablefun SimpleLazyColumn() { val listSize = 100 val scrollState = rememberLazyListState() val scrollCoroutineScope = rememberCoroutineScope() Column { Row { Button(onClick = { scrollCoroutineScope.launch { scrollState.animateScrollToItem(index = 0) } }) { Text(text = \"Scroll to Top\") } Button(onClick = { scrollCoroutineScope.launch { scrollState.animateScrollToItem(index = listSize - 1) } }) { Text(text = \"Scroll to Bottom\") } } } LazyColumn( state = scrollState, contentPadding = PaddingValues(horizantal = 16.dp, vertical = 8.dp), verticalArrangment = Arrangement.spaceBy(4.dp) // 각 Item 사이의 간격 ) { items(listSize) { index -&gt; ImageListItem(index) } }}🍀 9. Weight Modifier 특정 아이템의 위치를 지정 아이템의 Weight를 지정하는 방법 👉 전체를 감싸는 Colum의 Modifier.fillMaxHeight()를 사용해야 함 Modifier.fillMaxHeight() 👉 Colum 이 최대의 높이를 가지도록 함 예제 👇@Composablefun MyScreenContent(names: List&lt;String&gt; = listOf(\"Android\", \"Compose\")) { val countState = remember { mutableStateOf(0) } Column(modifier = Modifier.fillMaxHeight()) { Column(modifier = Modifier.weight(1f)) { names.forEach { Greeting(name = it) Divider(color = Color.Black) } } Counter(counterState.value) { counterState.value = it } }} 예제 버튼 색상 변경 👇@Composablefun Counter(count: Int, updateCount: (Int) -&gt; Unit) { Button( onClick = { updateCount(count + 1) }, colors = ButtonDefaults.buttonColor( backgroundColor = if (count &gt; 5) Color.Cyan else Color.White ) ) { Text(text = \"$count 번 클릭\") }}🍀 10. Scaffold 기본으로 제공되는 Material Component Composable중 가장 높은 레벨의 Composable TopAppBar, BottomBar, SnackBar, FloatingActionButton 및 Drawer 용 slot이 있음 slot 👉 여러가지 속성들을 개발자가 정의하여 사용하도록 하기위해 제공하는 빈공간 뼈대 역할 주로 Main 화면 만들때 사용 예제 앱바 + 앱바 오른쪽 끝 Icon 👇@Composablefun ScaffoldEx() { Scaffold(topBar = { TopAppBar( title = { Text(text = \"앱 바 타이틀\") }, actions = { IconButton(onClick = {}) { Icon(Icons.Filled.Favorite, contentDescription = null) } } ) }) { innerPadding -&gt; BodyContent(Modifier.padding(innerPadding).padding(8.dp)) }}🍎 번외🍀 1. Custom Button@Composablefun CreateButton() { Button(onClick = {}) { Row() { Image(painter = painterResource(R.drawable.something), contentDescription = \"\") Text( \"버튼\", fontWeight = FontWeight.Bold, modifier = Modifier.padding(4.dp).align(Alignment.CenterVerticall) ) } }}🍀 2. UI 꾸미기 padding 으로 클릭 영역 늘리기 👉 clickable전에 padding을 하는 경우 클릭 영역은 늘러나지 않음@Composablefun PhotographerCard(modifier: Modifier = Modifier) { Row( modifier.padding(8.dp) .clip(RoundedCornerShape(4.dp)) // Row 에 코너 추가 (Radius) .backgroundColor = MaterialTheme.colors.surface .clickable {} .padding(16.dp) ) { // size 가 50인 원 만들기 Surface( modifier = Modifier.size(50.dp), shape = CircleShape, color = MaterialTheme.colors.onSurface.copy(alpha = 0.2f), border = BorderStroke(width = 2.dp, color = Color.LightGray) // 테두리 ) { // TODO :: something view... } }}" }, { "title": "React-Native React-Query", "url": "/posts/React-Native-Query/", "categories": "React-Native, React-Query", "tags": "react-query, react-native, useQuery, useMutation", "date": "2022-10-27 16:19:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 서버의 값을 client 에 가져오거나 캐싱, 값 업데이트, 에러 핸들링 등 비동기 과정을 더욱 편하게 하는데 사용하는 react-query에 대하여 알아보겠습니다.🚩 React-Query 🍬 서버의 값을 client 에 가져오거나 Caching, value updating, error handling 등 비동기 과정을 더욱 편하게 하는데 사용됨 서버와 클라이언트를 분리합니다.🍀 1. React-Query 장점 캐싱 get을 한 데이터에 대해 update를 하면 자동으로 get을 다시 수행한다. Ex 👉 게시판의 글을 가져왔을 때 게시판의 글을 생성하면 게시판 글을 get하는 api를 자동으로 실행할 수 있음 데이터가 오래되었다고 판단되면 다시 get (invalidateQueries) 동일 데이터를 여러번 요청하면 한번만 요청한다. (Option 에 따라 중복 호출, 허용 시간 조절 가능) 무한 스크롤 Infinite Queries를 사용하여 pagination 처리 가능 비동기 과정을 선언적으로 관리가 가능하다. react 의 Hook과 사용하는 구조가 비슷하다.🍀 2. useQuery 데이터를 get 하기 위한 api (post, update 는 useMutation 을 사용) 첫 번째 파라미터 Unique Key가 들어감, 요청의 결과물이 특정 변수에 따라 달라진다면 꼭 Unique key에 포함해야 함 Unique key는 String 과 []을 받는다. 배열로 넘기면 0번 값은 String 값으로 다른 Component에서 부를 값이 들어가고 두 번째 값을 넣으면 Query 함수 내부에 파라미터로 해당 값이 전달됨 두 번째 파라미터 비동기 함수(api 호출 함수)가 들어감 (promise가 들어가야 함) 이 Component 가 랜더링될 때 해당 함수를 호출하고, 이에 대한 상태가 관리됨 첫 번째 파라미터로 설정한 Unique Key는 다른 Component 에서도 해당 key를 사용하면 호출 가능 Return 값 Api 요청의 성공, 실패 여부 및 Api 결과 값을 포함한 객체 status 👉 API의 요청 상태를 문자열로 나타냄 loading 👉 아직 데이터를 받아오지 않고, 현재 데이터를 요청 중 error 👉 오류 발생 success 👉 데이터 요청 성공 idle 👉 비활성화된 상태(따로 설정해 비활성화한 경우) isLoading 👉 status === ‘loading’ 과 같음 isError 👉 status === ‘error’ 와 같음 isSuccess 👉 staus === ‘success’ 와 같음 isIdle 👉 staus === ‘idle’ 과 같음 error 👉 오류가 발생했을 때 오류 정보를 가지고 있음 data 👉 요청 성공한 데이터를 가리킴 isFetching 👉 데이터가 요청 중일 때 true가 됨 데이터가 이미 존재하는 상태에서 재요청할 때 isLoading 은 false 이지만, isFetching 은 true 임 refetch 👉 다시 요청을 시작하는 함수 비동기로 작동 여러개의 비동기 Query가 있다면 useQuery 보다는 useQueries 를 사용하는 것이 좋음 enabled 를 사용하면 useQuery 를 동기적으로 사용 가능 useQuery의 3번째 인자로 Option 값이 들어가는데 그 Option의 enabled에 값을 넣으면 enabled 값이 true 일때 useQuery를 실행함 useQuery Option enable 👉 boolean 타입의 값을 설정, 이 값이 false 이면 Component 가 마운트될 때 자동으로 요청하지 않음. refetch 함수로만 요청이 시작됨 retry 👉 boolean or number or (failureCount: number, error: TError) =&gt; boolean 타입의 값을 설정 요청이 실패했을 때 재요청할지 설정할 수 있음 이 값을 true로 했을때 👉 실패했을 때 성공할 때까지 계속 반복 요청 이 값을 false로 했을때 👉 실패했을 떄 재요청하지 않음 이 값을 3 으로 하면 👉 3번까지만 재요청 이 값을 함수 타입으로 설정하면 👉 실패 횟수와 오류 타입에 따라 재요청할지 함수 내에서 결정할 수 있음 retryDelay 👉 number or (retryAttempt: number, error: TError) =&gt; number 타입 값을 설정 시간 단위는 ms(밀리세컨드 0.001초)임 기본값 👉 (retryAttempt) =&gt; Math.min(1000 * 2 ** failureCount, 30000) 실패 횟수 n 에 따라 2의 n 제곱 초만큼 기다렸다가 재요청하고 최대 30초까지 기다림 staleTime 👉 데이터의 유효 시간을 ms 단위로 설정, 기본값 0 (데이터를 조회한 순간 데이터는 바로 유효하지 않게 됨) cacheTime 👉 데이터의 캐시 시간을 ms 단위로 설정, 기본값은 5분, 캐시 시간은 Hook을 사용하는 Component 가 언마운트되고 나서 해당 데이터를 얼마나 유지할지 결정함 🍀 참고 🍀 staleTime 과 cacheTime 의 차이 👇 useQuery 를 사용할 때 staleTime 옵션은 기본값이 0 임. 즉, 데이터를 조회한 순간 데이터는 바로 유효하지 않게됨. 데이터가 유효하지 않다면 기회가 주어졌을 때 다시 요청하여 데이터를 최신화 해야함 재요청 기회가 주어지는 시점 : 똑같은 Cache key 를 사용하는 useQuery 를 사용중인 Component 가 마운트될 때 cacheTime은 useQuery Hook을 사용한 Component가 언마운트되고 나서 해당 데이터를 얼마 동안 유지할지에 대한 설정, 기본값은 5 만약 useQuery를 사용한 Component 가 언마운트되고 나서 5분안에 다시 마운트된다면 isLoading 값이 true로 되지 않고, 처음 렌더링하는 시점부터 data 값이 이전에 불러온 데이터로 채워져 있게 된다. 그리고 staleTime에 따라 해당 데이터가 유효하다면 재요청하지 않고, 유효하지 않다면 재요청한다. refetchInterval 👉 false or number 타입값을 설정 이 설정으로 n초마다 데이터를 새로고침하도록 설정할 수 있음 시간 단위는 ms 임 refetchOnmount 👉 boolean or ‘always’ 타입의 값을 설정 이 설정으로 Component가 마운트될 때 재요청하는 방식을 설정할 수 있음 기본 값: true true일 때는 데이터가 유효하지 않을 때 재요청함 false일 때는 Component가 다시 마운트되어도 재요청하지 않음 ‘always’일 때는 데이터의 유효 여부와 관계없이 무조건 재요청함 onSuccess 👉 (data: Data) =&gt; void 타입의 함수를 설정, 데이터 요청이 성공하고 나서 특정 함수를 호출하고 싶을 때 사용 onError 👉 (error: Error) =&gt; void 타입의 함수를 설정, 데이터 요청이 실패하고 나서 특정 함수를 호출하고 싶을 때 사용 onSettled 👉 (data?: Data, error?: Error) =&gt; void 타입의 함수를 설정, 데이터 요청의 성공 여부와 관계없이 요청이 끝나면 특정 함수를 호출하도록 설정 initialData 👉 Data () =&gt; Data 타입의 값을 설정, Hook 에서 사용할 데이터의 초깃값을 지정하고 싶을 때 사용 refetchOnWindowFocus 👉 React-Query는 사용자가 사용하는 윈도우가 다른 곳을 갔다가 다시 화면으로 돌아오면 이 함수를 재실행함, 그 재실행 여부 옵션 예제 👇 기본 설정 &gt; index.js 에 작성 import { QueryClient, QueryClientProvider } from \"react-query\";import { ReactQueryDevtools } from \"react-query/devtools\";const queryClient = new QueryClient();const root = ReactDOM.createRoot(documnet.getElementById(\"root\"));root.Render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client={queryClient}&gt; &lt;ReactQueryDevtools initialIsOpen={true} /&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;); 예제 👇 useQuery 사용 const Todo = () =&gt; { const { isLoading, isError, data, error } = useQuery(\"todos\", fetchTodoList, { refetchOnWindowFocus: false, retry: 0, onSuccess: (data) =&gt; { console.log(data); }, onError: (e) =&gt; { console.log(e.message); }, }); if (isLoading) { return ( &lt;View&gt; &lt;Text&gt;{\"Loading\"}&lt;/Text&gt; &lt;/View&gt; ); } if (isError) { return ( &lt;View&gt; &lt;Text&gt;{\"에러\"}&lt;/Text&gt; &lt;/View&gt; ); } // Something...};🍀 3. useQueries useQuery를 비동기로 여러개 실행할 경우 사용 promise.all과 마찬가지로 하나의 배열에 각 Query에 대한 상태 값이 객체로 들어옴 예제 👇 useQueries 사용 (lol 룬과 스펠을 받아오는 예시) const result = useQueries([ /** * getRune -&gt; Unique Key * riot.version -&gt; 파라미터 */ { queryKey: [\"getRune\", riot.version], queryFn: () =&gt; api.getRunInfo(riot.version), }, { queryKey: [\"getSpell\", riot.version], queryFn: () =&gt; api.getSpellInfo(riot.version), },]);useEffect(() =&gt; { console.log(result); const loadingFinishAll = result.some((result) =&gt; result.isLoading); console.log(loadingFinishAll);}, [result]); 예제 👇 useQueries 사용 &gt; Unique Key 활용 &gt; Unique Key를 배열로 넣으면 queryFn(쿼리 함수) 내부에서 변수로 사용 가능 const result = useQueries([ { queryKey: [\"getRune\", riot.version], queryFn: (params) =&gt; { // 결과 -&gt; {queryKey: ['getRune', '12.1.1'], pageParam: undifined, meta: undifined} console.log(params); return api.getRunInfo(riot.version); }, }, { queryKey: [\"getSpell\", riot.version], queryFn: () =&gt; api.getSpellInfo(riot.version), },]);🍀 4. useMutation 값을 바꿀 때 사용하는 api 데이터를 생성(POST), 수정(UPDATE), 삭제(DELETE)할 떄 사용하는 Hook 특정 함수에서 우리가 원하는 때에 직접 요청을 시작하는 형태 요청 관련 상태의 관리와 요청 처리 전/후로 실행할 작업을 쉽게 설정할 수 있음 첫 번쨰 인자 👉 Promise를 반환하는 함수 두 번째 인자 👉 이 작업이 처리되기 전후로 실행할 함수를 넣음(생략가능) onMutate 👉 요청 직전 처리, 여기서 반환하는 값은 하단 함수들의 context로 사용 onError 👉 데이터 요청이 실패하고 나서 특정 함수를 호출하고 싶을 때 사용 onSuccess 👉 데이터 요청이 성공하고 나서 특정 함수를 호출하고 싶을 때 사용 onSettled 👉 데이터 요청의 성공 여부와 관계없이 요청이 끝나면 특정 함수를 호출하도록 설정 return 값 👉 useQuery 와 동일 mutate 👇 요청을 시작하는 함수 첫 번째 인자 👉 API 함수에서 사용할 인자 두 번쨰 인자 {onSuccess, onSettled, onError} 객체, (생략가능) option 에 설정된 함수가 먼저 호출되고, mutate 두 번째 파라미터에 넣은 함수가 호출됨 mutateAsync 👉 mutate와 인자는 동일, 함수를 호출했을 때 반환 값이 Primse staus 👉 요청 상태를 문자열로 변환(idle, loading, error, success) error 👉 오류 정보 data 👉 요청 성공 시 데이터가 담겨있음 reset 👉 상태를 모두 초기화하는 함수 예제 👇 useMutation 사용 const Index = () =&gt; { const [id, setId] = useState(''); const [password, setPassword] = useState(''); const loginMutation = useMutation(loginApi, { // variable -&gt; {loginId: xxx, password: xxx} onMutate: variable =&gt; { console.log(\"onMutate\", variable); }, onError: (error, variable, context) =&gt; { // TODO: Error 핸들링 }, onSuccess: (data, variables, context) =&gt; { console.log(\"success\", data, varibles, context); }, onSettled: () =&gt; { console.log('end); }, }); // API 호출에 사용될 인자 const onSubmit = () =&gt; { loginMutation.mutate({loginId: id, password: password}); }} 예제 👇 invalidateQueries를 사용하여 UPDATE 후 GET 함수를 간단하게 실행mutation 함수가 성공할 때, unique key로 맵핑된 GET함수를 invalidateQueries에 넣어주면 됨만약 mutation에서 return된 값을 이용해서 GET함수의 파라미터를 변경해야 할 경우 setQueryData를 사용 const mutation = useMutation(postTodo, { onSuccess: () =&gt; { // postTodo 가 성공하면 todos 로 맵핑된 useQuery API 함수를 실행 queryClient.invalidateQueries(\"todos\"); },});// 만약 mutation에서 return된 값을 이용해서 GET 함수의 파라미터를 변경해야할 경우 setQueryData를 사용const queryClient = useQueryClient();// data 가 fetchTodoById 로 들어감const mutation = useMutation(editTodo, { onSuccess: (data) =&gt; { queryClient.setQueryData([\"todo\", { id: 5 }], data); },});const { status, data, error } = useQuery([\"todo\", { id: 5 }], fetchTodoById);mutation.mutate({ id: 5, name: \"nkh\",});🍀 5. react-suspense 와 react-query 사용 비동기를 좀 더 선언적으로 사용할 수 있음. suspense 를 사용하여 loading 을, Error bundary를 사용하여 error handling을 더욱 직관적으로 할 수 있음. suspense 를 사용하기 위해 QueryClient 에 option 을 하나 추가해야 함 예제 👇 Global 하게 suspense 를 사용한다고 정의 &gt; src/index.js 에 선언 const queryClient = new QueryClient({ defaultOptions: { queries: { retry: 0 suspense: true } }})ReactDom.render( &lt;React.StrictMode&gt; &lt;QueryClientProvider client={queryClient}&gt; &lt;App /&gt; &lt;/QueryClientProvider&gt; ...) 예제 👇 함수마다 suspense를 사용하는 예시 const { data } = useQuery(\"test\", testApi, { suspense: ture });return ( &lt;Suspense fallback={&lt;div&gt; loading... &lt;/div&gt;}&gt; &lt;ErrorBoundary fallback={&lt;div&gt;에러발생&lt;/div&gt;}&gt; &lt;div&gt;{data}&lt;/div&gt; &lt;/ErrorBoundary&gt; &lt;/Suspense&gt;);🍀 6. React-Query Cache 데이터 새로고침 React-Query에는 useQuery를 사용할 때 입력한 Unique Key를 통해 데이터를 만료시키고, 새로 불러올 수 있도록 처리할 수 있다. invalidateQueries 👇 캐시를 만료시켜 데이터를 새로 고침 Unique Key를 사용하여 데이터를 만료시키고, API를 재요청하는 방식 useQueryClient 👉 이 Hook은 이전에 App Component에서 QueryClientProvider에 넣었던 queryClient를 사용할 수 있게 해줌 getQueryData 👇 Unique Key를 사용하여 Cache Data 를 조회할 수 있음 데이터가 undifined일 수 있으니, 만약 데이터가 존재하지 않는다면 빈 배열을 사용하도록 준비 TypeScript 환경에서는 Generic을 지정하면 반환값의 데이터 type 을 설정할 수 있음 setQueryData 👇 Cache Data 를 업데이트하는 메서드 데이터를 두 번째 인자에 넣어도되고, 업데이트 함수형태의 값을 인자로 넣을 수 있음 만약 업데이트 함수 형태로 넣는다면 getQueryData는 생략 가능 예제 👇 QueryClient를 사용하여 데이터 새로고침 const queryClient = useQueryClient();const { mutate: write } = useMutation(writerArticle, { onSuccess: () =&gt; { queryClient.invalidateQueries(\"articles\"); navigation.goBack(); },}); 예제 👇 QueryClient로 Cache Data를 직접 UPDATE하기API를 재요청하지 않고 Cache Data를 UPDATE const queryClient = useQueryClient();const { mutate: write } = useMutation(writeArticle, { onSuccess: (article) =&gt; { const articles = queryClient.getQueryData&lt;Article[]&gt;(\"articles\") ?? []; queryClient.setQueryData(\"articles\", articles.concat(article)); },}); 예제 👇 getQueryData 생략, UPDATE 함수 형태의 값을 인자로 넣음Unique Key로 데이터 조회 후 그 데이터를 UPDATE 함수를 사용하여 UPDATE const queryClient = useQueryClient();const { mutate: write } = useMutation(writeArticle, { onSuccess: (article) =&gt; { queryClient.setQueryData&lt;Article[]&gt;(\"articles\", (articles) =&gt; (articles ?? []).concat(article) ); },});🍀 7. useInfiniteQuery React-Query에서 Pagenation을 구현할 때 사용 함수 부분에서 pageParam을 사용하고, option부분에 getNextPageParam을 설정해줘야 함 getNextPageParam 👉 (lastPage, allPages) =&gt; unknown | undefined 타입 함수 이 함수에서는 pageParam으로 사용할 값을 결정 getNextPageParam 에서 더 이상 조회할 수 있는 데이터가 없는 경우 undefined 를 반환해야 함 allPages 👉 지금까지 불러온 모든 페이지를 가리킴, 배열로 이루어진 배열ex) Article[][] lastPage 👉 가장 마지막으로 불러온 페이지, 현재 data typeex) Article[] return 값 data 👉 {pageParams, pages} 타입을 가지고 있음 pageParams 👉 각 페이지에서 사용된 파라미터 배열 pages 👉 각 페이지들을 배열 타입으로 나타냄 ex) Article[][] fetchNextPage 👉 다음 페이지를 불러오는 함수 hasNextPage 👉 다음 페이지의 존재 유무를 알려줌만약 getNextPageParam 에서 undefined 를 반환했다면 이 값은 false가 되고 그렇지 않으면 true가 된다. isFetchingNextPage 👉 다음 페이지를 불러오고 있는지 여부를 알려줌 그 외에 useQuery에서 반환되는 모든 필드들이 존재 예제 👇 useInfiniteQuery 사용 const ArticlesScreen = () =&gt; { const {data, isFetchingNextPage, fetchNextPage} = useInfiniteQuery( 'articles', ({pageParam}) =&gt; getArticle({cursor: pageParam}), { getNextPageParam: (lastPage) =&gt; lastPage.length === 10 ? lastPage[lastPage.length - 1].id : undefined, }, ); /** * [][] =&gt; [] 으로 변경 * [] as Aritlce[] 이라고 입력하여 해당 배열이 Article의 배열이란 것을 명시하고, concat을 해줌 * concat 에는 배열 타입을 넣으면 해당 배열을 해체해서 앞부분의 배열에 붙여주기 때문에, 해당 방식으로 * 하면 배열들이 하나의 배열로 합쳐짐 */ const item = useMemo(() =&gt; { if (!data) return null; return ([] as Article[]).concat(...data.length) }, [data]); const [user] = useUserState(); if (!items) { return ( &lt;ActivityIndicator size=\"large\" style={styles.spinner} color=\"black\"&gt; ); } return ( &lt;Articles articles={items} showWriteButton={!!user} isFetchingNextPage={isFetchingNextPage} fetchNextPage={fetchNextPage} &gt; );} 예제 👇 useInfiniteQuery 사용 &gt; FlatList 연결 interface ArticlesProps { articles: Article[]; showWriteButton: boolean; isFetchingNextPage: boolean; fetchNextPage(): void;}const Articles({ articles, showWriteButton, isFetchingNextPage, fetchNextPage}: ArticlesProps) { return ( &lt;FlatList data={articles} renderItem={({item}) =&gt; ( &lt;ArticleItem id={item.id} title={item.title} publishedAt={item.published_at} username={item.user.username} /&gt; )} keyExtractor={(item) =&gt; item.id.toString()} style={styles.list} ItemSeparatorComponent={() =&gt; &lt;View style={styles.separator} /&gt;} ListHeaderComponent={() =&gt; (showWriteButton ? &lt;WriteButton /&gt; : null)} ListFooterComponent={() =&gt; ( &lt;&gt; {articles.length &gt; 0 ? &lt;View style={styles.separator} /&gt; : null} {isFetchingNextPage &amp;&amp; ( &lt;ActivityIndicator size=\"small\" color=\"black\" style={styles.spinner} /&gt; )} &lt;/&gt; )} onEndReachedThrehold={0.5} onEndReached={fetchNextPage} /&gt; );}const styles = StyleSheet.create({ list: { flex: 1, }, separator: { width: '100%', height: 1, backgroundColor: '#cfd8dc', }, spinner: { backgroundColor: 'white', paddingTop: 32, paddingBottom: 32, },})" }, { "title": "React-Native Redux로 전역 상태 관리하기", "url": "/posts/React-Native-Redux/", "categories": "React-Native, Redux", "tags": "redux, react-native", "date": "2022-08-25 16:19:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Redux를 사용하여 전역 상태를 관리하는 방법에 대하여 알아보겠습니다.기존에는 React의 Context API를 사용하여 전역 상태를 관리했습니다.Context API를 사용하면 웬만한 기능은 모두 구현할 수 있습니다. 하지만 전역적으로 다뤄야 할 상태가 다양해지고 복잡해질수록 준비해야 할 코드가 많아집니다.특히 최적화가 필요한 경우에는 상태를 가져오는 Context와 상태를 업데이트하는 Context를 따로 관리해야 해서 준비할 코드의 양이 더욱 많아질 수 있습니다.따라서 Redux에 관하여 알아보도록 하겠습니다.🚩 Redux (리덕스) Redux의 상태 업데이트 방법은 useReducer와 비슷합니다. 상태를 업데이트하는 리듀서 함수를 기반으로 작동합니다. ✅ 참고 action: 변화를 정의하는 객체이며 type필드를 반드시 지니고 있어야 합니다. state: 상태를 나타냅니다.주의 ❗️ 리듀서 함수에서는 state와 action값을 참조하여 업데이트된 상태를 반환해야 합니다.예제 👇 function reducer(state, action) {// action에 따라 업데이트된 상태를 반환} Context API보다 더 적은 코드로 기능을 구현할 수 있고, 선응을 최적화하기에도 용이합니다. 미들웨어라는 기능도 사용할 수 있습니다.1. Module(모듈) 작성하기 Reduc에서 상태 관리를 하기 위해 Module을 작성해야 합니다. action 의 type: action type은 문자열입니다. 여기서의 type은 TypeScript와는 다릅니다. action객체를 만들 때 type으로 사용될 값입니다. ✅ 참고 : action type은 주로 대문자로 선언합니다.예제 👇 // action 의 typeconst INCREASE = 'increase';const DECREASE = 'decrease';const INCREASE_BY = 'increase_by';const DECREASE_BY = 'decrease_by'; action 생성 함수 ✅ 참고 action 생성 함수는 action 객체를 만들어주는 함수입니다. action 객체를 만들때마다 직접 객체를 작성하는 게 아니라, 함수를 재사용하여 생성할 수 있도록 action 생성 함수를 만듭니다. action 생성 함수는 추후 Component에서 불러와야 하므로 export해야 합니다.예제 👇 // action 생성 함수export const increase = () =&gt; ({ type: INCREASE });export const decrease = () =&gt; ({ type: DECREASE });export const increaseBy = (by) =&gt; ({ type: INCREASE_BY, by });export const decreaseBy = (by) =&gt; ({ type: DECREASE_BY, by }); 초기 상태 예제 👇 const initialState = { value: 1}; 리듀서 함수 ✅ 참고 state와 action 파라미터를 받아와서 업데이트된 상태를 반환합니다. useReducer의 리듀서와 다른점은 초기 상태를 기본 파라미터 문법을 사용해 state = initialState 형식으로 지정해줘야 하며, default : 케이스에서는 오류를 발생시키지 않고 state를 반환하도록 만들어야 한다는 점입니다. 리듀서 함수에서는 상태의 불변성을 유지하면서 업데이트 해줘야 합니다. 따라서 state를 직접 수정하면 안 되고, 새로운 값을 만들어서 반환해줘야 합니다. 주의 ❗️ 객체에 여러 값이 있다면 {...state, value: state.value + 1}과 같은 형식으로 불변성을 유지해야 합니다. 만약 배열인 경우에는 push, splice 처럼 배열에 직접 변화를 일으키는 함수를 사용하지 말고 concat, filter처럼 새로운 배열을 생성시키는 함수를 사용해야 합니다. 리듀서 함수는 추후 여러 리듀서를 합쳐야 하므로 이 또한 export해줘야 합니다. 주로 export default로 내보내줍니다.예제 👇 // 리듀서 함수export function counter(state= initialState, action) {switch (action.type) { case INCREASE: return { value: state.value + 1 }; case DECREASE: return { value: state.value - 1}; case INCREASE_BY: return { value: state.value + action.by }; case DECREASE_BY: return { value: state.value - action.by }; default: return state;}} 전체 코드// action 의 typeconst INCREASE = 'increase';const DECREASE = 'decrease';const INCREASE_BY = 'increase_by';const DECREASE_BY = 'decrease_by';// action 생성 함수export const increase = () =&gt; ({ type: INCREASE });export const decrease = () =&gt; ({ type: DECREASE });export const increaseBy = (by) =&gt; ({ type: INCREASE_BY, by });export const decreaseBy = (by) =&gt; ({ type: DECREASE_BY, by });// 초기 상태const initialState = { value: 1};// 리듀서 함수export function counter(state= initialState, action) { switch (action.type) { case INCREASE: return { value: state.value + 1 }; case DECREASE: return { value: state.value - 1}; case INCREASE_BY: return { value: state.value + action.by }; case DECREASE_BY: return { value: state.value - action.by }; default: return state; }}2. Root 리듀서 만들기 Redux를 사용할 때는 기능별로 Module을 작성해야 합니다. 각 Module에 있는 여러 리듀서를 하나의 리듀서로 합쳐야 합니다. 리듀서를 하나로 합칠 때는 combineReducers라는 함수를 사용합니다. 여러 리듀서를 합친 리듀서를 루트 리듀서라고 부릅니다.// 3개의 리듀서가 있다고 가정counter : { value: 1 }todos: [{ id: 1, text: '리덕스', done: false}]setting: { filter: 'all' }// 리듀서를 하나로 합침 combineReducers 사용import {combineReducers} from 'redux'// combineReducers에 합치고 싶은 reducer 함수 넣기const rootReducer = combineReducers({ counter, todos, setting});export default rootReducer;3. Store(스토어) 만들기 Root Reducer를 만든 다음에는 store를 만들어야 합니다. React Project에서는 단 하나의 store를 생성합니다. Redux store에서는 Redux에서 관리하는 모든 상태가 들어있으며, 현재 상태를 조회할 수 있는 getState함수와 action을 일으킬 수 있는 dispatch함수가 들어있습니다. ✅ 참고 : dispatch(increase())와 같이 action객체를 인자에 넣어서 함수를 호출하면 준비한 reducer가 호출되면서 상태가 업데이트 됩니다.예제 👇 import {createStore} from 'redux'import rootReducer from './modules/'const store = createStore(rootReducer);export default store; 4. Provider로 React Project에 Redux 적용 React Project에서 작성한 store를 사용하려면 Provider Component를 사용하여 전체 앱을 감싸줘야 합니다.import {createStore} from 'redux';import {Provider} from 'react-native';import rootReducer from './modules';const store = createStore(rootReducer);function App() { return ( &lt;Provider store={store}&gt; {/* .. */} &lt;/Provider&gt; );}export default App;5. useSelector과 useDispatch로 Component에서 Redux 연동하기 Provider를 사용하여 Redux를 적용 ✅ 참고 useSelector : Hook을 사용해 리덕스의 상태를 조회할 수 있습니다. useSelector Hook 에서는 셀렉터 함수를 인자로 넣어줍니다. 이 함수에서 state 파라미터는 store가 지니고 있는 현재 상태를 가리킵니다. 셀렉터 함수에서는 이 Component에서 사용하고 싶은 값을 반환하면 됩니다. useDispatch : action을 발생시켜 상태를 업데이트할 수 있습니다. 셀렉터를 사용해 조회한 상태가 바뀔 때마다 Component가 렌더링됩니다. useSelector는 최적화되어 있기 때문에 우리가 원하는 상태가 바뀔 때만 리렌더링합니다. 주의 ❗️ 이 component에서 의존하지 않는 Redux에서 관리하는 다른 상태가 변경됐을 때는 렌더링되지 않습니다. 이 점이 Context를 사용했을 때와 가장 다른 차이점 입니다. import {useSelector, useDispatch} from 'react-redux';import {increase, decrease} from './modules/counter/';function Counter() { const value = useSelector(state =&gt; state.counter.value); const dispatch = useDispatch(); const onPressIncrease = () =&gt; { dispatch(increase()); }; const onPressDecrease = () =&gt; { dispatch(decrease())); };}export default Counter;🚩 Redux (리덕스) 개념 정리 Redux를 사용할 때는 상태의 종류별로 Module을 작성해야 합니다. Module에는 action type, action 생성 함수, Reducer를 선언합니다. 여러 Reducer를 combineReducers로 합쳐 Root Reducers를 만듭니다. createStore를 사용하여 store를 만듭니다. Provider를 사용하여 React Project에 Redux를 적용합니다. useSelector와 useDispatch를 사용하여 Redux의 상태를 조회하거나 업데이트합니다.🚩 마치며이번 포스팅에서는 Redux에 관하여 알아보았습니다.Redux는 useReducer와 비슷하며 Redux를 통해 전역 상태를 관리하면 더 적은양의 코드로 최적화된 상태를 관리할 수 있습니다.다음 포스팅에서는 Redux Toolkit에 대하여 알아보도록 하겠습니다." }, { "title": "React-Native Redux Toolkit 사용", "url": "/posts/React-Native-Redux-Toolkit/", "categories": "React-Native, Redux", "tags": "redux-toolkit, redux, react-native", "date": "2022-08-25 16:19:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Redux Toolkit에 대하여 알아보도록 하겠습니다.Redux를 사용하면 action type을 선언하고, action 생성 함수를 선언하고, Reducer에서 해당 action을 위한 케이스를 작성해야 합니다. 그리고 Module의 상태가 복잡해지면 불변성을 유지하면서 상태를 업데이트하기 위해 적상해야 할 코드의 양도 많아질 수 있습니다.이런 상황에 Redux Toolkit을 사용하면 Module을 작성할 때 action type, action 생성 함수, reducer를 한번에 작성할 수 있어 편리합니다.자세한 설명은 밑에서 하도록 하겠습니다.Redux에 대하여 잘 모르시면 해당 포스팅을 참고하세요. 👉 React-Native Redux에 대하여🚩 Redux Toolkit Module을 작성할 때 action type, action 생성 함수, reducer를 한번에 작성할 수 있어 편리합니다. 상태를 업데이트할 때 불변성에 대해 신경 쓰지 않아도 됩니다. 상태를 직접 업데이트했을 때 내장된 라이브러리 immer를 사용하여 불변성을 유지하면서 업데이트해줍니다. createSlice : action 생성 함수와 reducer를 합친 개념입니다. ✅ 참고 createSlice를 사용하면 action 생성 함수와 reducer를 동시에 만들 수 있기 때문에 action type을 따로 선언하지 않아도 됩니다. 만약 action type을 조회해야 할 일이 생기면 action 생성 함수의 type 필드를 확인하면 됩니다. counterSlice.actions: action 생성 함수들이 들어있는 객체 counterSlice.reducer: reducer 함수 action의 payload : Redux Toolkit에서는 action에 추가로 넣어줄 값의 이름이 playload로 통일되며, 액션 생성 함수의 파라미터를 통해 정해집니다. 예) increaseBy(5) 라고 action 생성 함수를 호출하면 action.payload의 값은 5가 됩니다. 자동으로 이루어지는 불변성 관리 createSlice에서 사용하는 Reducer 메서드에서는 불변성을 신경쓰지 말고 state값을 직접 수정해도 됩니다. 라이브리 자체에서 immer라는 라이브러리가 내장되어 있어 불변성을 자동으로 관리해줍니다. slice를 만들 때는 name을 지정해야 합니다. name : action type이 만들어질 때 name/액션 이름 형태로 만들어 집니다. 예) slice 의 name이 counter일 경우, increase의 action type은 counter/increase가 됩니다. import {createSlice} from '@reduxjs/toolkit';const initialState = {value: 1};const counterSlice = createSlice({ name: 'counter', initialState, reducers: { increase(state, action) { state.value += 1; }, decrease(state, action) { state.value -= 1; }, increaseBy(state, action) { state.value += action.playload; }, decreaseBy(state, action) { state.value -= action.playload; } }});export const {increase, decrease, increaseBy, decreaseBy} = counterSlice.actions;export default counterSlice.reducer; 위의 코드에서 increase(state, action)은 Shorthand method names라는 문법으로 객체의 메서드를 선언하는 문법입니다.해당 코드는 아래의 코드와 같습니다. 👇 increase: function(state, action) { state.value += 1;} 🚩 Typescript 와 함꼐 Redux Toolkit 사용하기 initialState에 타입을 달아줘야 합니다. action type에 PlayloadAction을 사용해야 합니다. playload 값의 type은 PlayloadAction의 Generic으로 지정해줄 수 있습니다.import {createSlice, PlayloadAction} from '@reduxjs/toolkit';interface CounterState { value: number};const initialState: CounterState = {value: 1};const counterSlice = createSlice({ name: 'counter', initialState, reducers: { increase(state, action) { state.value += 1; }, decrease(state, action) { state.value -= 1; }, increaseBy(state, action: PlayloadAction&lt;number&gt;) { state.value += action.payload; }, decreaseBy(state, action: PlayloadAction&lt;number&gt;) { state.value -= action.payload; } }});export const {increase, decrease, increaseBy, decreaseBy} = counterSlice.actions;export default counterSlice.reducer;🚩 마치며이번 시간에는 Redux Toolkit에 대하여 알아보고 또한 TypeScript을 통해 Redux Toolkit을 사용하는 방법에 대하여 알아보았습니다.다음 시간에는 더욱 유용한 글로 찾아뵙겠습니다." }, { "title": "Typescript 로 React-Navigations 사용하기", "url": "/posts/React-Native-Using-React-Navigation-With-Typescript/", "categories": "React-Native, TypeScript", "tags": "typescript, react-navigation, react-native", "date": "2022-08-25 16:19:00 +0900", "snippet": "안녕하세요. NarviS2 입니다.이번시간에는 TypeScript로 React-Navigations을 사용하는 방법에 대하여 알아보도록 하겠습니다.타입 설정을 잘 하면 새로운 화면을 띄우는 과정에서 화면의 이름을 자동 완성 하고, route 파라미터의 타입을 검증할 수 있습니다.또한 화면 Component에서는 해당 화면에서 받아올 파라미터들의 타입을 확인할 수 있습니다.🚩 라이브러리 설치 TypeScript가 공식적으로 지원되기 때문에 별도로 해야할 작업은 없습니다. 명령어 👇 $ yarn add @react-navigation/native react-native-screens react-native-safe-area-context @react-navigation/native-stack @react-navigation/bottom-tabs 🚩 NavigationContainer 적용 App.tsx 에서 NavigationContainer를 설정합니다. 👇import React from 'react';import {NavigationContainer} from '@react-navigation/native';function App() { return &lt;NavigationContainer&gt;{/* TODO: 화면 추가 */}&lt;/NavigationContainer&gt;;}export default App;🚩 Native Stack Navigation 사용하기 RootStack.tsx 에서 native-stack을 사용합니다. 👇import React from 'react';import {Button, Text, View} from 'react-native'import {createNativeStackNavigator} from '@react-navigation/native-stack';import {useNavigation} from '@react-navigation/native';const Stack = createNativeStackNavigator();function HomeScreen() { const navigation = useNavigation(); const onPress = () =&gt; { navigation.navigate('Detail'); }; return ( &lt;View&gt; &lt;Text&gt;Home&lt;/Text&gt; &lt;Button title=\"Open Detail\" onPress={onPress} /&gt; &lt;/View&gt; );}function DetailScreen() { return ( &lt;View&gt; &lt;Text&gt;Detail&lt;/Text&gt; &lt;/View&gt; );}function RootStack() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen component={HomeScreen} name=\"Home\" /&gt; &lt;Stack.Screen component={DetailScreen} name=\"Detail\" /&gt; &lt;/Stack.Navigator&gt; );}export default RootStack; TypeScript를 사용할 경우 이 코드에서 navigation.native('Detail')을 할 때 Detail 부분에 빨간 줄이 그어지게 됩니다.주의 ❗️ TypeScript에서 native-stack navigation을 사용할 때는 어떤 화면에 어떤 파라미터가 필요한지 StackParamList타입을 정의해줘야 합니다.이 타입을 사용하면 다른 화면을 띄울 때 화면의 이름과 route 파라미터를 검증할 수 있습니다. Native Stack Navigation에서 사용할 화면 타입 선언하기 createNativeStackNavigator 의 Generic으로 사용합니다.주의 ❗️ RootStackParamList 타입을 선언할 때는 interface가 아닌 type을 사용하여 선언해야 합니다. type RootStackParamList = { Home: undefined; Detail: { id: number; };};const Stack = createStackNavigator&lt;RootStackParamList&gt;(); 🚩 useNavigation 사용하기 useNavigation을 사용할 때는 NavigationPop을 선언해야 합니다. 선언한 타입을 useNavigation 의 Generic으로 지정해줘야 합니다. native-stack의 경우에는 NativeStackNavigationProp을 불러와서 선언할 수 있습니다. 주의 ❗️ TypeScript를 사용하는 환경에서는 NativeStackNavigationProp을 사용하여 선언된 NavigationProp이 useNavigation의 Generic으로 설정되어 있지 않으면 navigation.push,navigation.pop 등의 함수를 사용할 수 없습니다. import React from 'react';import {Button, Text, View} from 'react-native';import { createNativeStackNavigator, NativeStackNavigationProp,} from '@react-navigation/native-stack';import {useNavigation} from '@react-navigation/native';type RootStackParamList = { Home: undefined; Detail: { id: number; };};// export를 붙여 다른 파일에서 이를 불러와 사용할 수 있게 설정(추후 내비게이션을 감싸는 방법을 다룰 때 불러와서 사용)export type RootStackNavigationProp = NativeStackNavigationProp&lt;RootStackParamList&gt;;const Stack = createStackNavigator&lt;RootStackParamList&gt;();function HomeScreen() { // Generic 을 사용하면 특정 화면으로 navigate할 때 route 파라미터의 타입을 검증할 수 있습니다. const navigation = useNavigation&lt;RootStackNavigationProp&gt;(); const onPress = () =&gt; { navigation.navigate('Detail', {id: 1}); }; return ( &lt;View&gt; &lt;Text&gt;Home&lt;/Text&gt; &lt;Button title=\"Open Detail\" onPress={onPress} /&gt; &lt;/View&gt; );}🚩 useRoute 사용하기 이 Hook을 사용할 때는 RouteProp을 사용하여 선언한 타입을 Generic으로 설정해야 합니다. ✅ 설명 RouteProp 👇 첫 번째 Generic: 현재 사용 중인 내비게이션의 route 파라미터 타입을 위해 선언한 RooteStackParamList를 넣습니다. 두 번째 Generic: 화면 이름을 넣습니다. import React from 'react';import {Button, Text, View} from 'react-native';import { createNativeStackNavigator, NativeStackNavigationProp,} from '@react-navigation/native-stack';import {useNavigation, RouteProp, useRoute} from '@react-navigation/native';type RootStackParamList = { Home: undefined; Detail: { id: number; };};// export를 붙여 다른 파일에서 이를 불러와 사용할 수 있게 설정(추후 내비게이션을 감싸는 방법을 다룰 때 불러와서 사용)export type RootStackNavigationProp = NativeStackNavigationProp&lt;RootStackParamList&gt;;const Stack = createStackNavigator&lt;RootStackParamList&gt;();type DetailScreenRouteProp = RouteProp&lt;RootStackParamList, 'Detail'&gt;();function HomeScreen() { // Generic 을 사용하면 특정 화면으로 navigate할 때 route 파라미터의 타입을 검증할 수 있습니다. const navigation = useNavigation&lt;RootStackNavigationProp&gt;(); const onPress = () =&gt; { navigation.navigate('Detail', {id: 1}); }; return ( &lt;View&gt; &lt;Text&gt;Home&lt;/Text&gt; &lt;Button title=\"Open Detail\" onPress={onPress} /&gt; &lt;/View&gt; );}function DetailScreen() { const {params} = useRoute&lt;DetailScreenRouteProp&gt;(); return ( &lt;View&gt; &lt;Text&gt;Detail {params.id}&lt;/Text&gt; &lt;/View&gt; );}function RootStack() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen component={HomeScreen} name=\"Home\" /&gt; &lt;Stack.Screen component={DetailScreen} name=\"Detail\" /&gt; &lt;/Stack.Navigator&gt; );}export default RootStack; App.tsx에서 사용import React from 'react';import {NavigationContainer} from '@react-navigation/native';import Rootstack from './screens/RootStack';function App() { return ( &lt;NavigationContainer&gt; &lt;RootStack /&gt; &lt;/NavigationContainer&gt; );}export default App;🚩 Navigation 감싸기 여러개의 navigation을 감쌀 때는 CompositeNavigationProp을 사용하여 NavigationPop을 합칩니다. 하단 탭 네이게이션의 타입을 지정할 때 예제 👇 ✅ 설명 Native Stack Navigation 없이 하단 탭 내비게이션만 단독으로 사용한다면 type MainTabNavigationProp = BottomTabNavigationProp&lt;MainTabParamList&gt;;으로 충분합니다. 하단 탭 내비게이션에서 그 상위에 있는 RootStack의 DetailScreen에 접근하려면 NavigationProp들을 합쳐줘야 합니다. import React from 'react';import { BottomTabNavigationProp, createBottomTabNavigator,} from '@react-navigation/bottom-tabs';import {Button, Text, View} from 'react-native';import { CompositeNavigationProp, NavigatorScreenParams, useNavigation} from '@react-navigation/native';import {RootStackNavigationProp} from './RootStack/';type MainTabParamList = { Home: undefined; Account: undefined;};export type MainTabNavigationProp = CompositeNavigationProp&lt; RootStackNavigationProp, BottomTabNavigationProp&lt;MainTabParamList&gt;&gt;;// 추후 RootStack 내부 화면에서 navigation.navigate('MainTap', {screen: 'Account'})가 가능하게 해줍니다.export type MainTapNavigationScreenParams = NavigatorScreenParams&lt;MainTabParamList&gt;;const Tab = createBottomTabNavigator&lt;MainTapParamList&gt;();function HomeScreen() { const navigation = useNavigation&lt;MainTabNavigationProp&gt;(); const onPress = () =&gt; { navigation.navigate('Detail', {id: 1}) }; return ( &lt;View&gt; &lt;Text&gt;Home&lt;/Text&gt; &lt;Button title=\"Open Detail\" onPress={onPress} /&gt; &lt;/View&gt; );}function AccountScreen() { return ( &lt;View&gt; &lt;Text&gt;Account&lt;/Text&gt; &lt;/View&gt; );}function MainTab() { return ( &lt;Tab.Navigator&gt; &lt;Tab.Screen name=\"Home\" component={HomeScreen} /&gt; &lt;Tab.Screen name=\"Account\" component={AccountScreen} /&gt; &lt;/Tab.Navigator&gt; );}export default MainTab;🚩 RootStack 에서 HomeSceen 지우고 MainTab으로 대체import React from 'react';import {Text, View} from 'react-native';import { createNativeStackNavigator, NativeStackNavigationProp,} from '@react-navigation/native-stack';import {RouteProp, useRoute} from '@react-navigation/native';import MainTab, {MainTabNavigationScreenParams} from './MainTab';type RootStackParamList = { MainTab: MainTabNavigationScreenParams; Detail: { id: number; };};export type RootStackNavigationProp = NativeStackNavigationProp&lt;RootStackParamList&gt;;const Stack = createNativeStackNavigator&lt;RootStackParamList&gt;();type DetailScreenRouteProp = RouteProp&lt;RootStackParamList, 'Detail'&gt;;function DetailScreen() { const {params} = useRoute&lt;DetailScreenRouteProp&gt;(); return ( &lt;View&gt; &lt;Text&gt;Detail {params.id}&lt;/Text&gt; &lt;/View&gt; );}function RootStack() { return ( &lt;Stack.Navigator&gt; &lt;Stack.Screen component={MainTab} name=\"MainTab\" options= /&gt; &lt;Stack.Screen component={DetailScreen} name=\"Detail\" /&gt; &lt;/Stack.Navigator&gt; );}export default RootStack;🚩 마치며이번 포스팅에서는 Typescript 로 React-Navigations를 사용하는 방법에 대하여 알아보았습니다.해당 내용은 충분히 헷갈릴 수 있으므로 여러번 반복해서 보시는걸 추천합니다." }, { "title": "Typescript 에서 Context API 사용하기", "url": "/posts/React-Native-How-To-Use-Context-Api-With-Typescript/", "categories": "React-Native, TypeScript", "tags": "typescript, context-api, react-native", "date": "2022-08-25 15:19:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 지난 포스팅에 이어 TypeScript에서 Context API를 사용하는 방법에 대하여 알아보겠습니다.지난 포스팅 👉 Typescript 에서 Hook 사용하기🚩 TypeScript 로 Context API 사용하기 createContext 함수를 호출할 때 Generic을 설정해줘야 합니다. AuthContext.Provider를 사용하지 않았을 경우에는 기본 값이 null 이므로 AuthContextValue | null을 createContext의 Generic으로 설정해야 합니다. 예제 👇 interface User { id: number; username: string;}interface AuthContextValue { user: User | null; setUser(user: User): void;}const AuthContext = createContext&lt;AuthContextValue | null&gt;(null); Context 전용 Provider Component를 따로 만들 때 해당 Component 에서 children Props를 사용하기 때문에 해당 타입도 파라미터 부분에서 지정해줘야 합니다. 예제 👇 export function AuthContextProvider({children}: {children: React.ReactNode}) { // TODO: AuthContext.Provider 렌더링} 전용 Hook을 만들 때 유효성 검사를 한 후 에러를 throw해줘야 함수의 반환값 타입이 AuthContextValue가 됩니다. 나중에 해당 Context를 더 편하게 사용할 수 있습니다. 그렇지 않으면 Hook을 사용할 때 따로 유효성 검사를 해줘야 합니다.예제 👇 export function useAuth() { const auth = useContext(AuthContext); if (!auth) { throw new Error('AuthContextProvider is not used'); } return auth;} auth의 유효성을 검사해줘야, useAuch의 반환값 타입이 AuthContextValue로 되고, throw 하여 null 타입을 제외합니다. 전체 코드 AuthContext.tsx 작성import React, {createContext, useContext, useState} from 'react';interface User { id: number; username: string;}interface AuthContextValue { user: User | null; setUser(user: User): void;}const AuthContext = createContext&lt;AuthContextValue | null&gt;(null);export function AuthContextProvider({children}: {children: React.ReactNode}) { const [user, setUser] = userState&lt;User | null&gt;(null); return ( &lt;AuthContext.Provider value=&gt; {children} &lt;/AuthContext.Provider&gt; );}export function useAuth() { const auth = useContext(AuthContext); // auth의 유효성을 검사해줘야 useAuth의 반환값 타입이 AuthContextValue로 됨 if (!auth) { // throw 하여 null 타입 제외 throw new Error('AuthContextProvider is not used'); } return auth;}🚩 마치며이번 포스팅에서는 Typescript 에서 Context API 사용하는 방법에 대하여 알아보았습니다.다음 포스팅에서는 Typescript 로 React-Navigations를 사용하는 방법에 대하여 알아보도록 하겠습니다.Typescript로 React-Navigations를 사용하는 방법" }, { "title": "Typescript 에서 Hook 사용하기", "url": "/posts/React-Native-Using-Hooks-In-Typescript/", "categories": "React-Native, TypeScript", "tags": "typescript, hook, react-native", "date": "2022-08-25 13:57:00 +0900", "snippet": "안녕하세요. NarviS2 입니다.지난 포스팅에서는 TypeScript에 관하여 기초적인 문법을 알아보았습니다.지난 포스팅을 안보신 분들은 👉 Typescript에 관하여를 통해 참고하시길 추천드립니다.또한 이번 포스팅에서는 TypeScript로 Hook을 사용하는 방법을 예제를 통하여 알아보도록할텐데 Hook에 관하여 모르시는 분들은👉 React-Native Hook을 참고하시길 권장합니다.🚩 React Component를 TypeScript로 작상하기 props에 type이 붙는 것 말고는 달라질 것이 없습니다. (props 가 없는 Component는 JavaScript로 작성할 때와 똑같습니다.) 주의❗️ React Component를 작성할 때는 tsx확장자, JSX를 사용하지 않는 코드는 ts확장자를 사용합니다. 1. Props 사용하기 Props가 필요해지면 Props를 위한 type을 선언해줘야 합니다. Props를 위한 type은 interface를 사용하여 선언합니다. 예제👇import React from 'react';import {View, Text} from 'react-native';interface Props { name: string;}function Profile({name}: Props) { return ( &lt;View&gt; &lt;Text&gt;{name}&lt;/Text&gt; &lt;/View&gt; );}export default Profile;2. 옵셔널 Props 사용하기 interface에서 특정 필드에 ?를 붙여서 타입을 선언합니다. 참고 : 옵셔널 Props란 생략가능한 Props라는 뜻입니다. import React from 'react';import {View, Text, StyleSheet} from 'react-native';interface Props { name: string; isActive?: boolean;}function Profile({name, isActive}: Props) { return ( &lt;View style={isActive &amp;&amp; styles.activeStyle}&gt; &lt;Text&gt;{name}&lt;/Text&gt; &lt;/View&gt; );}const styles = StyleSheet.create({ activeStyle: { backgroundColor: 'yellow', },});export default Profile; Profile Component를 사용할 때 isActive Props를 생략해도 TypeScript오류가 발생하지 않습니다.3. 기본값 Props 사용하기 defaultProps 사용 👇import React from 'react';import {View, Text, StyleSheet, Image} from 'react-native';interface Props { name: string; isActive?: boolean; image: string;}function Profile({name, isActive, image}: Props) { return ( &lt;View style={isActive &amp;&amp; styles.activeStyle}&gt; &lt;Image source= /&gt; &lt;Text&gt;{name}&lt;/Text&gt; &lt;/View&gt; );}Profile.defaultProps = { image: ''.};const styles = StyleSheet.create({ activeStyle: { backgroundColor: 'yellow', },});export default Profile; JavaScript 기본값 매개변수 문법 사용 Props 파라미터가 구조분해되는 과정에서 특정 값의 기본값을 지정할 수 있습니다. 해당 필드에 옵셔널 ?를 붙혀주셔야 합니다.예제 👇 import React from 'react';import {View, Text, StyleSheet, Image} from 'react-native';interface Props { name: string; isActive?: boolean; image?: string;}function Profile({name, isActive, image='이미지 주소 넣기'}: Props) { return ( &lt;View style={isActive &amp;&amp; styles.activeStyle}&gt; &lt;Image source= /&gt; &lt;Text&gt;{name}&lt;/Text&gt; &lt;/View&gt; );}const styles = StyleSheet.create({ activeStyle: { backgroundColor: 'yellow', },});export default Profile;4. children Props 사용하기 (React.ReactNode) JSX 타입의 Props를 받아오는 상황에서는 React.ReactNode 타입을 사용 ✅ 참고 : 만약 children Props가 반드시 필요하지 않다면 children ?: React.ReactNode 라고 입력하여 이 Props를 생략해도 된다는 것을 명시해야함예제 👇 import React from 'react';import {View, Text, StyleSheet, Image} from 'react-native';interface Props { name: string; isActive?: boolean; image?: string; children: React.ReactNode;}function Profile({ name, isActive, image='이미지 주소 넣기', children,}: Props) { return ( &lt;View style={isActive &amp;&amp; styles.activeStyle}&gt; &lt;Image source= /&gt; &lt;Text&gt;{name}&lt;/Text&gt; &lt;View&gt;{children}&lt;/View&gt; &lt;/View&gt; );}const styles = StyleSheet.create({ activeStyle: { backgroundColor: 'yellow', },});export default Profile; App.tsx 에서 사용 👇import React from 'react';import {Text} from 'react-native';import Profile from './profile/';function App() { return ( &lt;Profile name=\"NarviS2\"&gt; &lt;Text&gt;Hello World&lt;/Text&gt; &lt;/Profile&gt; );}export default App;🚩 TypeScript 에서 useState 사용하기 Generic을 사용하여 상태의 타입을 지정해줄 수 있습니다. ✅ 참고 : useState에 넣은 인자의 타입을 유추할 수 없거나 여러 타입을 지닌 경우에는 Generic을 꼭 설정해줘야 합니다.예제 👇 import React, {useState} from 'react';import {Button, Text, TextInput, View} from 'react-native';function MessageForm() { // 해당 제네릭은 생략가능 const [text, setText] = useState&lt;String&gt;(''); // 여러 타입을 지닌 경우 const [lastMessage, setLastMessage] = useState&lt;{ message: string; date: Date; } | null&gt;(null); const onPress = () =&gt; { setLastMessage({ message: text, date: new Date(), }); setText(''); }; return ( &lt;View&gt; &lt;TextInput value={text} onChangeText={setText} /&gt; &lt;Button title=\"PRESS ME\" onPress={onPress} /&gt; {lastMessage &amp;&amp; ( &lt;View&gt; &lt;Text&gt; 마지막 메시지: {lastMessage.message} ( {lastMessage.date.toLocaleString()} ) &lt;/Text&gt; &lt;/View&gt; )} &lt;/View&gt; );}export default MessageForm;🚩 TypeScript 에서 useRef 사용하기 useRef에 담을 값의 타입을 Generic으로 설정할 수 있습니다.import React, {useState, useRef, useEffect} from 'react';import {Button, Text, TextInput, View} from 'react-native';function MessageForm() { // 해당 제네릭은 생략가능 const [text, setText] = useState&lt;String&gt;(''); // 여러 타입을 지닌 경우 const [lastMessage, setLastMessage] = useState&lt;{ id: number; message: string; date: Date; } | null&gt;(null); // useRef 사용 const nextId = useRef&lt;Number&gt;(1); // 처음 렌더링될 때는 null이고 한번 렌더링된 뒤에는 TextInput의 인스턴스가 담깁니다. const inputRef = useRef&lt;TextInput | null&gt;(null); const onPress = () =&gt; { setLastMessage({ id: nextId.current, message: text, date: new Date(), }); setText(''); nextId.current += 1; }; // useEffect를 통해 이 컴포넌트가 보여지는 순간 TextInput에 포커스가 잡히도록 설정 useEffect(() =&gt; { if (!inputRef.current) { retrun; } inputRef.current.focus(); }, []); return ( &lt;View&gt; &lt;TextInput value={text} onChangeText={setText} ref={inputRef}/&gt; &lt;Button title=\"PRESS ME\" onPress={onPress} /&gt; {lastMessage &amp;&amp; ( &lt;View&gt; &lt;Text&gt; 마지막 메시지: {lastMessage.message} ( {lastMessage.date.toLocaleString()} ) &lt;/Text&gt; &lt;/View&gt; )} &lt;/View&gt; );}export default MessageForm;🚩 TypeScript 에서 useReducer 사용하기 useReducer를 사용할 때는 리듀서에서 관리할 state와 action타입을 선언해야 합니다. state 선언 (interface 사용) 예제 👇 interface CounterState { value: number;}const initialState: CounterState = { value: 1,}; type 선언 (Type Alias 사용) 예제 👇 type CounterAction = {type: 'increment'} | {type: 'decrement'; by: number}; 만약 action의 갯수가 많아질 경우 (여러줄로 작성) 예제 👇 type CounterAction = | {type: 'increment'}| {type: 'decrement'; by: number}| {type: 'random'}| {type: 'nothing'}; 또는 각 action 마다 interface 타입을 선언한 뒤 Type Alias로 합칠 수도 있음 interface IncrementAction { type: 'increment';}interface DecrementAction { type: 'decrement'; by: number;}type CounterAction = IncrementAction | DecrementAction; reducer() 함수 선언 state와 action을 파라미터로 받아와 그다음 상태를 반환하는 함수입니다.예제 👇 function reducer(state: CounterState, action: CounterAction) { switch (action.type) { case 'increment': return { value: state.value + 1 }; case 'decrement': return { value: state.value - action.by }; default: throw new Error('Unhandled action type'); }} 사용 및 전체 코드 interface CounterState { value: number;}const initialState: CounterState = { value: 1,};type CounterAction = {type: 'increment'} | {type: 'decrement'; by: number};function reducer(state: CounterState, action: CounterAction) { switch (action.type) { case 'increment': return { value: state.value + 1 }; case 'decrement': return { value: state.value - action.by }; default: throw new Error('Unhandled action type'); }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;View&gt; &lt;Text&gt;{state.value}&lt;/Text&gt; &lt;Button title:\"+1\" onPress={() =&gt; dispatch({type: 'increment'})} /&gt; &lt;Button title:\"-1\" onPress={() =&gt; dispatch({type: 'decrement'})} /&gt; &lt;/View&gt; );}export default Counter; 마치며이번 포스팅에서는 React Component에서 TypeScript를 작성하는법과 TypeScript로 Hook을 작성하는 법에 대하여 알아보았습니다.다음 시간에는 TypeScript로 Context API를 사용하는 법에 대하여 알아보도록 하겠습니다." }, { "title": "React-Native Hook", "url": "/posts/React-Native-Hook/", "categories": "React-Native, Hook", "tags": "react-native, hook", "date": "2022-08-23 13:37:00 +0900", "snippet": "안녕하세요. Narvis2입니다.이번 시간에는 React-Native Hook 에 관하여 알아볼까 합니다.React 에는 use로 시작하는 다양한 함수가 내장되어 있는데, 이 함수들을 Hook이라고 부릅니다.Hook을 사용하여 상태 관리, 최적화, 컴포넌트 작동 흐름 관리 등 다양한 기능을 구현할 수 있습니다.🚩 Hook 의 규칙 Hook은 Component 최상위 레벨에서만 사용해야 합니다. 주의❗️ Hook은 조건문이나 반복문 또는 중첩 함수에서 호출하면 안됩니다. 만약 함수의 흐름 중간에 return을 하는 경우에는 Hook은 함수가 return되기 전에 사용되어야 합니다. 여러 Hook을 사용하여 직접 Hook을 만들 수 있습니다. 이를 Custom Hook이라고 부릅니다. react패키지외에서 불러오는 Hook은 모두 Custom Hook입니다. Hook은 Custom Hook 또는 함수 Component 에서만 사용할 수 있습니다. 주의❗️ Class에서는 사용이 불가능하며, react와 관련없는 일반적인 JavaScript 함수에서 사용하면 Error가 발생합니다. useState - 상태 값을 관리하는 함수 useState 가 호출되면 두 가지 원소가 들어있는 배열을 반환합니다. 첫 번째 원소 : 상태 값 두 번째 원소 : 상태를 업데이트하는 함수 해당 코드에서 사용한 문법은 배열 구조 분해 할당을 사용중이며, Button Click 시 visible을 바꿔주는 코드입니다.👇import React, {useState} from 'react';import {SafeAreaView, Button} from 'react-native';function App() { const [visible, setVisible] = useState(true); const onPress = () =&gt; { setVisible(!visible); }; return ( &lt;SafeAreaView&gt; &lt;Button title=\"토글\" onPress={onPress} /&gt; &lt;/SafeAreaView&gt; );}; useState 를 사용해 Boolean 뿐만 아니라 숫자, 객체, 배열 등의 형태를 가진 상태를 관리할 수도 있습니다.🚩 useEffect - 특정 값을 Observing 하는 함수 Component에서 특정 상태가 바뀔 때마다 원하는 코드를 실행할 수 있는 함수 Component가 마운트(가장 처음 화면에 나타남)되거나 언마운트(화면에서 컴포넌트가 사라짐)될 때 원하는 코드를 실행할 수도 있습니다. 첫 번째 인자 : 주시하고 싶은 값이 바뀌었을 때 호출하고 싶은 함수를 넣습니다. 두 번째 인자 : 주시하고 싶은 값을 배열 안에 넣습니다. 예시 todos를 옵저빙하다가 todos가 바뀌면 log를 찍는 코드👇import React, {useState, useEffect} from 'react';function App() { const today = new Date(); const [todos, setTodos] = useState([ {id: 1, text: 'Hello', done: true}, {id: 2, text: 'Hello 2', done: false}, {id: 3, text: 'hello 3', done: false}, ]); useEffect(() =&gt; { console.log(todos); }, [todos]);} useEffect에 등록한 함수는 두 번째 인자의 배열 안에 넣은 값이 바뀔 때도 호출되지만, Component가 가장 처음 렌더링됐을 때도 호출됩니다.🚩 useNavigation - 내비게이션 Hooks Screen 으로 사용되고 있지 않은 컴포넌트에서도 navigation객체를 사용할 수 있습니다.import {useNavigation} from '@react-navigation/native';function Test() { const navigation = useNavigation(); retrun ( &lt;Button title= \"Detail 열기\" onPress={() =&gt; navigation.navigate('Detail', {id: 1})} /&gt; );};🚩 useRoute - 내비게이션 Hooks useNavigation과 비슷하게, Screen이 아닌 Component에서 route객체를 사용할 수 있게 됩니다. Android 에서 Fragment/Activity 간 데이터를 주고 받는다 생각하면 됩니다. import {useRoute} from '@react-navigation/native';function Test() { const route = useRoute(); return &lt;Text&gt;id: {rounte.params.id}&lt;/Text&gt;;}🚩 useFocusEffect - 내비게이션 Hooks 화면에 포커스가 잡혔을 때 특정 작업을 할 수 있게 하는 Hook입니다. 다른 화면을 열었다가 돌아왔을 때 특정 작업을 하고 싶다면 useFocusEffect Hook을 사용해야 합니다. 현재 화면에서 다른 화면으로 넘어갈 때 특정 작업을 하고 싶다면 useFocusEffect에서 함수를 만들어 반환하면 됩니다. 주의❗️ useFocusEffect는 꼭 useCallback과 같이 사용해야 합니다. 만약 useCallback을 사용하지 않으면 Component가 리렌더링될 때마다 useFocusEffect에 등록한 함수가 호출됩니다.useCallback : Component 내부에서 함수를 만들 때, 새로 만든 함수를 사용하지 않고 이전에 만든 함수를 다시 사용하도록 만들어줍니다.그리고 그 함수 내부의 로직에서 의존하는 값이 있다면 의존하는 값이 바뀌었을 때 함수를 교체할 수 있도록 해줍니다. import React, {useEffect, useCallback} from 'react';import {createMaterialBottomTabNavigator} from '@react-navigation/material-bottom-tabs';import {Text, Button, View} from 'react-native';import Icon from 'react-native-vector-icons/MaterialIcons';import {useNavigation, useFocusEffect} from '@react-navigation/native';const Tab = createMaterialBottomTabNavigator();function OpenDetailButton() { const navigation = useNavigation(); return ( &lt;Button title=\"Detail 1 열기\" onPress={() =&gt; navigation.push('Deatil', {id: 1})} /&gt; );};function HomeScreen() { useFocusEffect( useCallback(() =&gt; { console.log('이 화면을 보고 있어요.'); return () =&gt; { console.log('다른 화면으로 넘어갔어요.'); } }, []), ); retrun ( &lt;View&gt; &lt;Text&gt;Home&lt;/Text&gt; &lt;OpenDetailButton /&gt; &lt;/View&gt; )};🚩 useMemo - 메모리 최적화 메모이제이션해 최적화할 수 있습니다. 메모이제이션 : 동일한 계산을 반복해야 할 때 불필요한 연산을 제거하기 위해 이전에 계산한 값을 재사용해 처리를 최적화하는 것을 의미합니다. 예제 👇const value = useMemo(() =&gt; compute(a, b), [a, b]); 설명 👉 a, b의 값이 변경될 때만 값이 연산됩니다. 전체 예제 👇import {fromat} from 'date-fns';import React, {useContext, useMemo, useState} from 'react';import CalendarView from '../components/CalendarView';import FeedList from '../components/FeedList';import LogContext from '../contexts/LogContext';function CalendarScreen() { const {logs} = useContext(LogContext); const [selectedDate, setSelectedDate] = useState(format(new Date(), 'yyyy-MM-dd'),); const markedDates = useMemo( () =&gt; logs.reduce((acc, current) =&gt; { const formattedDate = format(new Date(current.date), 'yyyy-MM-dd'); acc[formattedDate] = {marked: true}; return acc; }, {}), [logs], );} 설명 👉 logs 배열이 바뀔 때만 logs.reduce 함수가 수행됩니다.🚩 useReducer - 여러가지 상태를 관리 상태를 관리할 때 사용할 수 있는 또 다른 Hook 함수 입니다. state: 상태 action: 변화를 정의하는 객체 reducer: state와 action을 파라미터로 받아와 그다음 상태를 반환하는 함수입니다. dispatch: action을 발생시키는 함수 useState를 여러번 사용하는 상황에서 사용하면 유용할 수 있습니다. (무조건 이 Hook을 사용할 필요는 없음) 각기 다른 상태를 동시에 업데이트하는 상황에서 useReducer를 고민해보면 좋습니다. 👇const onPressDate = () =&gt; { // 버튼 클릭 시 useState 함수를 2개 사용 setMode('date'); setVisible(true);}; 카운터를 useReducer로 구현하는 예제 👇const initialState = {value: 1};// state: 현재 상태, action: dispatch 함수의 인자로 넣은 액션 객체를 가리킵니다.function reducer(state, action) { swich (action.type) { case 'increase': return {value: state.value + 1}; case 'decrease': return {value: state.value - 1}; default: throw new Error('Unhandled action type'); }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); const onIncrase = () =&gt; dispatch({type: 'increase'}); const onDecrease = () =&gt; dispatch({type: 'decrease'}); return (...)} 상태를 업데이트하는 로직을 Component 바깥에 구현할 수 있다는 장점이 있습니다. dispatch라는 함수 하나로 다양하게 업데이트할 수 있기 때문에 Context와 함께 사용하면 유용합니다. useReducer의 첫 번째 인자 : reducer 함수를 넣습니다. useReducer의 두 번째 인자 : 상태의 초기값 입니다. 함수의 결과 물의 첫 번째 원소 : 현재 상태 함수의 결과 물의 두 번째 원소 : dispatch 함수 reducer에서 반환하는 값 : 그다음 업데이트할 값으로 사용 🚩 useRef - 컴포넌트 레퍼런스 선택 함수 Componet에서 Component의 레퍼런스를 선택할 수 있게 하는 Hook입니다. ✋ 제목을 입력하고 Enter를 누르면 하단 내용으로 포커스를 이동시키고 싶다면 TextInput의 레퍼런스를 선택하여 포커스를 해줘야 합니다. ref를 생성하여 TextInput의 파라미터로 지정해주면 원하는 Component의 레퍼런스를 선택할 수 있습니다. 참고🔍 TextInput의 레퍼런스 focus() : TextInput에 포커스를 잡아줍니다. blur() : TextInput에 포커스를 해제합니다. clear() : TextInput의 내용을 모두 비웁니다. current : useRef로 선택한 레퍼런스는 .current 값을 조회하여 확인할 수 있습니다. onSubmitEditing 속성을 통해 Enter 를 눌렀을 때 내용 TextInput으로 포커스하는 예제 👇import React, {useRef} from 'react';import {View, StyleSheet, TextInput} from 'react-native';function WriteEditor({title, body, onChnageTitle, onChangeBody}) { const bodyRef = useRef() return ( &lt;View&gt; &lt;TextInput placeholder=\"제목을 입력하세요.\" style={styles.titleInput} returnKeyType=\"next\" onChangeText={onChnageTitle} value={title} onSubmitEditing={() =&gt; { bodyRef.current.focus() }} /&gt; &lt;TextInput plcaeholder=\"당신의 오늘을 기록해보세요.\" style={styles.bodyInput} multiline textAlignVertical=\"top\" onChangeText={onChangeBody} value={body} ref={bodyRef} /&gt; &lt;/View&gt; );}마치며이번시간에는 React-Native Hook에 관하여 알아보았습니다.해당 포스팅은 React-Navive에 대하여 처음 공부하면서 작성한 글입니다.추후 계속 업데이트될 예정입니다." }, { "title": "React-Native Context API", "url": "/posts/React-Native-Context-API/", "categories": "React-Native, Context", "tags": "react-native, context-api", "date": "2022-08-22 16:03:00 +0900", "snippet": "안녕하세요. Narvis2입니다.이번 시간에는 React-Native Context API 에 관하여 알아볼까 합니다.Context API는 react에 내장된 기능으로 Props를 사용하지 않아도 특정 값이 필요한 Component끼리 쉽게 값을 공유할 수 있게 해줍니다.주로 프로젝트에서 전역 상태를 관리할 때 많이 사용합니다.🚩 Context API Component의 상태를 공유할 때 주로 사용합니다. (서로 다른 화면에서 상태를 공유) Android로 치면 activityViewModels()를 생각하시면 됩니다. 주로 프로젝트 전역 상태를 관리할 때 많이 사용합니다. 새로운 Context를 만들 때는 createContext함수를 사용합니다. 👇import {createContext} from 'react';const LogContext = createContext('안녕하세요');export default LogContext; Context를 만들면 LogContext.Provider라는 Component와 LogContext.Consumer라는 Component가 만들어 집니다. Provider는 Context안에 있는 값을 사용할 Component들을 감싸주는 용도로 사용합니다. Provider의 value라는 Props 를 통해 여러 Component에서 공유할 수 있는 값을 지정합니다. Provider Component를 사용하면 이 Component 내부에 선언된 모든 Component에서 Context안의 값을 사용할 수 있습니다. import React from 'react';import {NavigationContainer} from '@react-navigation/native';import RootStack from './sreens/RootStack';import LogContext from './contexts/LogContext';function App() { // 이렇게하면 RootStack에 있는 모든 Component에서 해당 Context를 통해 value값을 사용할 수 있습니다. return ( &lt;NavigationContainer&gt; &lt;LogContext.Provider value=\"안녕하세요\"&gt; &lt;RootStack /&gt; &lt;/LogContext.Provider&gt; &lt;/NavigationContainer&gt; );}export default App; 해당 Context 값 사용 👇import React from 'react';import {View, Text} from 'react-native';import LogContext from '../contexts/LogContext';function FeedsScreen() { return ( &lt;View&gt; &lt;LogContext.Consumer&gt; {(value) =&gt; &lt;Text&gt;{value}&lt;/Text&gt;} &lt;/LogContext.Consumer&gt; &lt;/View&gt; );}export default FeedsScreen;🚩 useContext - Hook 함수 Render Props 와 LogContext.Consumer 대체 Context의 값을 훨씬 간결하게 사용 가능합니다. 👇import React, {useContext} from 'react';import {View, Text} from 'react-native';import LogContext from '../contexts/LogContext';function FeedsScreen() { const value = useContext(LogContext); return ( &lt;View&gt; &lt;Text&gt;{value}&lt;/Text&gt; &lt;/View&gt; );}export default FeedsScreen; Component에서 JSX를 반환하기 전에 값을 조회할 수 있기 때문에 Component 로직 작성이 더욱 간편합니다.🚩 Context에서 유동적인 값 다루기 Provider를 사용하는 Component에서 Context의 상태를 관리하는 것보다는 Provider 전용 Component를 따로 만드는 것이 유지보수성이 더 높습니다. 특히 Context에서 다루는 로직이 복잡할 때는 전용 Component를 만드는 것이 좋습니다. 별도의 Context Provider Component 만들기 예제 코드 👇import React from 'react';import {createContext, useState} from 'react';const LogContext = createContext();export function LogContextProvider({children}) { const [text, setText] = useState(''); return ( &lt;LogContext.Provider value=&gt; {children} &lt;/LogContext.Provider&gt; );}export default LogContext; Context Provider Component 사용 👇import React from 'react';import {NavigationContainer} from '@react-navigation/native';import RootStack from './screens/RootStack';import {LogContextProvider} from './contexts/LogContext';function App() { return ( &lt;NavigationContainer&gt; &lt;LogContextProvider&gt; &lt;RootStack /&gt; &lt;/LogContextProvider&gt; &lt;/NavigationContainer&gt; );}export default App; useContext를 사용하여 Context Provider로 제공된 Data 사용 👇import React, {useContext} from 'react';import {View, TextInput} from 'react-native';import LogContext from '../contexts/LogContext';function FeedsScreen() { const {text, setText} = useContext(LogContext); return ( &lt;View&gt; &lt;TextInput&gt; value={text} onChangeText={setText} placeHolder=\"텍스트를 입력하세요.\" &lt;/TextInput&gt; &lt;/View&gt; );}export default FeedsScreen;🚩 마치며이번 포스팅에서는 Context API에 대하여 알아보았습니다.Context API는 서로 다른 화면간에 데이터를 공유하기 위해 사용하며 Android 의 Fragment간 데이터 공유에 사용하는 activityViewModels()를 생각하면 쉽습니다." }, { "title": "TypeScript", "url": "/posts/TypeScript/", "categories": "React-Native, TypeScript", "tags": "typescript", "date": "2022-08-22 13:37:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 TypeScript에 대하여 알아보도록 하겠습니다.JavaScript는 동적 타입 언어 입니다. 즉, 특정 변수를 선언했을 때 다른 타입으로 대입할 수 있습니다.JavaScript의 변수의 타입은 Runtime에서 결정됩니다. 따라서 프로젝트의 규모가 커질수록 실수할 가능성도 높아지고 타입 추론이 일부만 되기 때문에 개발이 불편할 수 있습니다. 또한 오류 발생이 Runtime에서 발생하므로 오류를 핸들링하기가 불편합니다.이런 문제를 해결하기 위해 TypeScript를 사용하여 JavaScript에 정적 타입 시스템을 적용합니다.🚩 TypeScript MicroSoft에서 만든 오픈 소스 프로그래밍 언어입니다. JavaScript에 정적 타입을 사용할 수 있습니다. TypeScript로 작성된 코드는 tsc(TypeScript Compiler)를 통해 JavaScript코드로 변환됩니다. TypeScript의 확장자는 ts 또는 tsx 입니다. 주의❗️ React Component를 작성한다면 확장자를 tsx로 해야 JSX가 지원됩니다. JSX를 사용하지 않는다면 확장자를 ts로 저장하면 됩니다. TypeScript가 적용된 프로젝트에서는 선언된 변수를 사용하는 곳이 없으면 Error를 발생시키는 규칙이 있습니다. 주의❗️ .eslintrc.js 파일을 열어서 밑의 코드를 입력합니다. module.exports = { root: true, extends: '@react-native-community', rules: { '@typescript-eslint/no-unused-vars': 0, }} 🚩 TypeScript React Native 에서 사용$ npx react-native init 프로젝트이름 --template react-native-template-typescript🚩 TypeScript 기초 문법1. 기본 타입 기본 타입들은 타입을 명시해주지 않아도 자동으로 타입추론됩니다. 변수가 하나의 타입만 지니고 있다면 타입 선언을 생략해도 됩니다. string : 문자열 number : 숫자 boolean : true / false any : 모든 타입 undefined : 변수는 존재하나, 어떠한 값으로도 할당되지 않아 자료형이 정해지지(undefined) 않은 상태 | : or 예제 코드 👇 let message: string = 'Hello World';let value: number = 1;// 문자열 or Null 타입let nullableString: string | null = null;nullableString = 'Hi';// undefined or 숫자 타입 let undefinedDrNumber: undefined | number;undefinedDrNumber = 'Hi';// 숫자 or 문자열 or Null 타입let numberOrStringOrNull: number | string | null = null;numberOrStringOrNull = 1;numberOrStringOrNull = 'Bye';numberOrStringOrNull = null;let isCompleted: boolean = true;isCompleted = false;// 모든 타입의 값을 대입할 수 있음let anyValue: any = null;anyValue = undefined;anyValue = 1;anyValue = 'hello world';2. 함수 타입 여러 반환값 타입을 지닌 함수 👇 ✅참고 : 함수에서 무엇을 반환하느냐에 따라 반환값의 타입이 결정되도록 함수 반환값을 따로 설정안함 function sum(a: number, b: number) { return a + b;} 명시적으로 함수 반환값 선언 👇 ✅참고 : 함수의 반환값이 지정한 타입과 다른 값을 반환한다면 오류가 발생합니다. function sum(a: number, b: number): number { retrun a + b;} 3. 옵서녈 파라미터 생락해도 되는 파라미터를 의미합니다. 👇 ✅참고 : 밑의 코드에서 isDouble 은 boolean | undefined 로 설정됩니다. function process(a: number, b: number, isDouble?: boolean) { const sum = a + b; return isDouble ? sum * 2 : sum;} 4. interface TypeScript에서 객체나 클래스를 위한 Type을 정할 때 사용합니다. 선언된 객체 타입은 변수의 타입이나 파라미터의 타입으로 사용할 수 있습니다. 예제👇 interface Profile { id: number; username: string; displayName: string;}function printUsername(profile: Profile) { console.log(profile.username);}const profile: Profile = { id: 1, username: 'narvis2', displayName: 'Youngjun Choi',};printUsername(profile) 다른 interface에서 참조 예제👇 interface Profile { id: number; username: string; displayName: string;}interface RelationShip { from: Profile; to: Profile;}const relationship: RelationShip = { from: { id: 1, username: 'narvis2', displayName: 'Youngjun Choi', }, to: { id: 2, username: 'astatrte', displayname: 'Jun' },}; 5. interface 상속하기 기존 interface 타입에 필드를 더 추가할 때 는 상속을 통해 처리할 수 있습니다. 👇 예제👇 interface Profile { id: number; username: string; displayName: string;}interface Account extends Profile { email: string; password: string;}const account: Account = { id: 1, username: 'narvis2', displayName: 'Youngjun Choi', email: 'narvis2@naver.com', password: '123123',}; 6. 옵셔널 속성 interface에서 옵셔널 속성을 다룰 때는 함수의 옵셔널 파라미터와 비슷하게 ?를 사용합니다. 예제👇 interface Profile { id: number; username: string; displayname: string; photoURL?: string;}const profile: Profile = { id: 1, usename: 'narvis2', displayName: 'Youngjun Choi',}const profileWithPhoto: Profile = { id: 1, usename: 'narvis2', displayName: 'Youngjun Choi', photoURL: 'photo.png',} 7. 클래스에서 interface를 implement 하기 interface에서 구현해야 하는 메서드들의 타입을 미리 선언하고, 이에 맞춰 클래스에서 구현하는 예제 👇 interface Shape { getArea(): number; getPerimeter(): number;}class Circle implements Shape { // Class의 기본 생성자 constructor(private radius: number) {} getArea() { return Math.PI * Match.pow(this.radius, 2); } getPerimeter() { return 2 * Math.PI * this.radius; }}class Rectangle implements Shape { constructor(private width: number, private height: number) {} getArea() { return this.width + this.height; } getPerimeter() { return 2 * (this.width + this.height); }} ✅참고 : constructor 부분에 private radius: number 는 다음 형식과 같음 👇 class Circle implements Shape { radius: number; constructor(radius: number) { this.radius = radius; }} 8. 배열 타입 TypeScript에서 배열 타입 을 다룰 때는 타입 뒤에 []를 붙여줍니다. 예제👇 const numbers: number[] = [1, 2, 3, 4, 5];const texts: string[] = ['hello', 'world'];// 객체를 배열로interface Person { name: string;}const people: Person[] = [{name: 'narvis2'}, {name: 'Choi Young Jun'}]; 9. Type Alias 타입에 별칭을 붙여주는 기능 예제👇 type Persion = { name: String;};const person: Person = { name: 'Choi Young Jun',};// 객체 배열 타입type People = Person[];const people: People = [{name: 'Choi Young Jun'}];// Android 로 치면 Enum Classtype Color = 'red' | 'orange' | 'yellow';const color: Color = 'red'; type을 사용하여 만든 객체 타입에도 필드를 추가할 수 있습니다. &amp; 문자를 사용 예제👇 type Persion = { name: string;};// Persion 객체에 job 이라는 필드 추가type Employee = Persion &amp; { job: string;};// Employee 객체를 인스턴스화 하여 필드에 값 추가const empolyee: Emplyee = { name: 'narvis2', job: 'Programmer',}; 10. Generic(제네릭) 함수, 객체, 클래스 타입에서 사전에 정하지 않은 다양한 타입을 다룰 때 사용 함수(function)에서 Generic 사용 Generic을 사용하지 않는 경우 any 타입 사용 주의❗️ 해당 형식을 사용할 경우 result 에서 즉 함수 호출하는 쪽에서 type 추론이 되지 않습니다.예제👇 function wrap(value: any) { return {value};}const result = wrap('Hello World'); Generic을 사용하여 type 추론이 가능하게 설정 예제👇 function wrap&lt;T&gt;(value: T) { return {value};}const result = wrap('Hello World'); 객체(interface)에서 Generic 사용 객체 타입의 특정한 필드에 다양한 값이 올 수 있다고 가정 예제👇 interface Item&lt;T&gt; { id: number; data: T;}interface Persion { name: string;}interface Place { location: string;}const personItem: Item&lt;Person&gt; = { id: 1, data: { name: \"narvis2\", },};const placeItem: Item&lt;Place&gt; = { id: 2, data: { location: \"Korea\", },}; Type Alias에서 Generic사용 type Item&lt;T&gt; = {id: number; data: T} 클래스(Class)에서 Generic사용 Queue 클래스를 예제로 사용해 보겠습니다. (선입 선출) ✅참고 : Queue에 대하여 잘 모르신다면 자료 구조 Queue, Stack 정리 포스팅을 참고해 주세요.예제👇 class Queue&lt;T&gt; { list: T[] = []; get length() { return this.list.length; } enqueue(item: T) { this.list.push(item); } dequeue() { return this.list.shift(); }}const queue = new Queue&lt;number&gt;();queue.enqueue(0);queue.enqueue(1);const first = queue.dequeue(); // 0const second = queue.dequeue(); // 1 마치며이번 포스팅에서는 TypeScript에 대하여 알아보았습니다.JavaScript는 동적 타입이기 때문에 오류 발생이 Runtime에 발생하여 TypeScript를 사용하여 정적 타입으로 바꿔 오류 발생을 Compile 시점으로 바꿔 오류 핸들링에 더욱 이점을 보고자 TypeScript를 사용합니다." }, { "title": "자료구조 Hash, HashMap, LinkedHashMap", "url": "/posts/Data-Structure-Hash/", "categories": "DataStructure", "tags": "hash, hashCode, hashTable, hashMap, linkedHashMap", "date": "2022-07-25 13:37:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 시간에는 Hash에 대하여 알아보고 더불어 HashMap, LinkedHashMap에 대하여 간략히 알아보고자 합니다.Hash 단방향 암호화 기법으로 산술 연산을 통하여 “입력된 값을 출력 데이터가 있는 곳을 알 수 있는 값으로 바꾸는 것”을 의미합니다. 데이터가 저장된 객체들과 일일이 동등성을 비교하지 않고, 산술 연산으로 데이터에 접근할 수 있기 때문에 속도가 빠릅니다. Hash Fuction을 통해 입력 값이 데이터가 있는 곳을 알 수 있는 출력 값으로 연결될 수 있으므로 Hash Fuction은 입력값을 출력값으로 Mapping 해주는 함수입니다.HashCode 객체를 식별하는 하나의 정수 값입니다. Object의 hashCode() 메서드는 객체의 메모리 번지를 이용해서 HashCode를 만들어 Return하기 때문에 객체마다 다른 값을 가지고 있습니다. 객체의 값을 동승성 비교 시 hashCode()를 Overriding 할 필요성이 있는데 hashCode()를 Overrding 할 때는 equals()도 반드시 Overring 해야합니다. 실행 중에 객체의 유일한 integer 값을 반환합니다. 참고❗️ equals 와 hashCode의 관계 Java 프로그램을 실행하는 동안 equals에 사용된 정보가 수정되지 않았다면 hashCode는 항상 동일한 정수값을 반환해야 합니다.(Java의 프로그램을 실행할때 마다 달라지는 것은 상관이 없습니다.) 두 객체가 equals 에 의해 동일하다면, 두 객체의 hashCode() 값 또한 일치해야 합니다. 두 객체가 equals 에 의해 동일하지 않다면, 두 객체의 hashCode() 값은 일치하지 않아도 됩니다. HashTable, HashSet, HashMap 과 같은 자료 구조는 “자료를 저장하기 위한 위치를 선택하기 위해 HashCode를 이용”합니다. 참고❗️ HashTable, HashSet, HashMap 의 객체 동등성 비교 방식 hashCode() 메서드를 실행하여 Return 된 HashCode 값이 같은 지를 비교합니다. HashCode 값이 다르면 다른 객체로 판단하고, HashCode 값이 같으면 equals() 메소드로 다시 비교합니다. 위의 2개가 모두 맞아야 동등 객체로 판단합니다. 즉, HashCode 값이 다른 Entries 끼리는 동치성 비교를 시도 조차 하지않습니다. HashTable 작동 원리 HashMap, HashSet 과 동작원리는 같습니다. HashTable 은 &lt;Key, Value&gt; 형태로 데이터를 저장합니다. 이 때 Hash Fuction 을 이용하여 Key 값을 기준으로 고유한 식별값인 Hash 값을 만들고(HashCode가 해시 값을 만드는 역할을 합니다.) 이 해시 값을 버킷(Bucket)에 저장합니다. 하지만 HashTable 크기는 한정적이기 때문에 같은 서로 다른 객체라 하여도 같은 Hash값을 갖게될 수 있습니다.(이것을 Hash Collisions 즉, 해쉬 충돌 이라고 합니다.) 이런 경우 해당 버킷(Bucket)에 LinkedList 형태로 객체를 추가합니다. 참고❗️ LinkedList 는 아이템의 갯수가 8개 이상으로 넘어가면 TreeMap 자료 구조로 저장됩니다. 이 처럼 같은 Hash 값을 버킷(Bucket)안에 다른 객체가 있는 경우 equals가 사용됩니다. 1️⃣ HashTable 에 put 메서드로 객체를 추가하는 경우 값이 같은 객체가 이미 존재한다면(equals()가 true) 기존 객체를 덮어씁니다. 값이 같은 객체가 없다면(equals()가 false) 해당 entry를 LinkedList에 추가합니다. 2️⃣ HashTable 에 get 메서드로 객체를 조회하는 경우 값이 같은 객체가 있다면(equals()가 true) 그 객체를 return 합니다. 값이 같은 객체가 없다면(equals()가 false) null을 return 합니다. HashMap Hash 기법을 사용하여 구현된 Map 입니다. 즉, Hash 기법을 사용하여 데이터를 보관하는 자료 구조입니다. 자료를 저장하기 위한 위치를 선택하기 위해 HashCode를 이용합니다. 데이터가 추가되는 순서를 유지하지 않으나 Hashing 기법의 특징인 빠른 접근 속도가 장점입니다. 데이터에 접근하거나 감색할 때 데이터를 순회(반복)하면서 일일이 빌교하는 일반적인 자료 구조와 다르게 key 값을 통해 한 번의 산술연산으로 데이터에 접근할 수 있기 때문에 아주 빠른 접근 속도와 검색 속도가 특징입니다. 데이터를 입력 순서대로 저장하거나 정렬하여 저장하지 않습니다. 참고❗️ 데이터를 순서대로 저장하고 싶으면 LinkedHashMap을 사용합니다. 배열을 기반으로 데이터를 관리하기 때문에 데이터의 총 개수를 미리 얼추 알고있다면 초기 용량을 정해주는 것이 좋습니다.LinkedHashMap Hash 기법을 사용하여 데이터를 보관하는 자료 구조입니다. 데이터를 추가한 순서대로 보관합니다.(데이터를 순서대로 저장) 따라서 LinkedHashMap 을 반복문 돌려서 순회하면 순서대로 접근이 가능합니다. 데이터의 총 개수를 미리 알고 있다면 초기 용량을 정해주는 것이 좋습니다." }, { "title": "Android Context", "url": "/posts/Android-Context/", "categories": "Android, Context", "tags": "android, context, applicationContext, activityContext", "date": "2022-07-22 13:29:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.오늘은 Android의 Context에 대하여 알아보고자 합니다.Context는 Application 환경에 대한 글로벌 정보를 갖는 인터페이스 입니다.Android에서는 대표적으로 Application의 Context와, Activity의 Context가 존재합니다.밑에서 자세히 알아보도록 하겠습니다.Context Application 환경에 대한 글로벌 정보를 갖는 인터페이스입니다. Android System에서 구현체를 제공하는 추상 클래스입니다. Application 별 Resource 및 클래스 접근에 사용되며, Activity 실행, BroadcastReceiver, Intent 수신과 같은 Application 수준 작업에 사용됩니다. Application의 현재 상태를 나타냅니다. 참고 👇 Context는 Application의 현재 상태의 맥락(Context)를 의미합니다. Context는 새로 생긴 객체가 지금 어떤일이 일어나고 있는지 알 수 있도록 합니다. 따라서 Activity와 Application에 대한 정보를 얻기 위해서는 Context를 사용하면 됩니다. Activity Application의 정보를 얻기 위해 사용할 수 있습니다. Activity 와 Application은 Context 클래스를 확장한 클래스입니다. 참고 👉 Context를 사용하는 경우Resource, Database, SharedPreference 등에 접근하기 위해 사용합니다. Application Context Singleton 인스턴스입니다. Activity에서 getApplicationContext()를 통해 접근할 수 있습니다. Application의 Lifecycle에 묶여 있습니다. 참고 👉 현재 Context가 종료된 이후에도 Context가 필요한 작업이나 Activity Scope를 벗어난 Context가 필요한 작업에 적합합니다. Singleton Object를 생성하고 해당 Object가 Context가 필요하면 ApplicationContext를 사용합니다. 주의❗️ Singleton에 Activity의 Context를 전달할 경우, 해당 Object가 Activity를 항상 참조하므로 Activity가 화면에 표시되지 않는 순간에도 Garbage Collection(가비지 컬렉션)이 진행되지 않아 메모리 누수가 발생할 수 있습니다. Application 전체에서 사용할 라이브러리를 특정 Activity에 초기화 한다면 ApplicationContext를 사용합니다. 참고 👇 Room, SharedPreference, Sinlgeton을 사용할 때는 ApplicationContext를 사용합니다. ContentProvide 의 getContext() 는 Application Context입니다. Activity Context Activity 내에서 유요한 Context입니다. Activity의 Lifecycle과 연결되어 있습니다. Activity와 함께 소멸해야하는 경우에 사용합니다. 즉, Activity와 Lifecycle이 같은 Object를 생성할 때 사용합니다. 참고 👇 Toast, Dialog 등의 UI Option에서 Context가 필요한 경우 Activity의 Context를 사용합니다. resources 를 사용하는 경우 Activity의 Context를 사용합니다. " }, { "title": "Android Glide를 이용한 Image Load", "url": "/posts/Android-Glide/", "categories": "Android, Glide", "tags": "android, glide", "date": "2022-07-22 10:19:00 +0900", "snippet": "안녕하세요. Narvis2입니다.이번 포스팅에서는 Glide에 대하여 알아보도록 하겠습니다.Glide는 Android에서 이미지를 빠르고 효율적으로 불러올 수 있게 도와주는 라이브러리입니다.이미지, Gif, 비디오 스틸의 로딩과 디코딩, 캐싱 등의 다양한 API를 사용할 수 있습니다.Glide는 어떠한 종류의 이미지이더라도 빠르고 부드럽게 스크롤 하는 것을 목적으로 합니다.Glide GithubGlide Cache Glide는 기존적으로 메모리 &amp; 디스크에 이미지를 Caching 하여 다음번에 호출하였을 때 빠른 Image Loading을 지원합니다. 메모리 캐시 Glide는 기본적으로 메모리 캐싱을 하기 때문에 메모리 캐싱을 위해 추가적으로 할 일은 없습니다. 주의❗️ 단, Url 이미지 로딩 시 한번 Load한 이미지는 Cache에 저장되어 서버에서 해당 이미지를 변경해도 App의 이미지는 갱생되지 않습니다. 이런 경우 .skipMemoryCache(true) 로 메모리 캐시를 사용하지 않을 수 있습니다. 디스크 캐시 Glide는 기본적으로 디스크 캐싱을 수행합니다. 기본적인 개념은 메모리 캐시와 같습니다. .diskCacheStrategy()를 사용하여 캐싱에 관한 설정이 가능합니다. DiskCacheStrategy.ALL : 모든 이미지를 캐싱합니다. DiskCacheStrategy.AUTOMATIC : default 값이며, RESOURCE 를 기반으로 전략적인 캐싱을 수행합니다. DiskCacheStrategy.DATA : 원본 이미지를 캐싱합니다. DiskCacheStrategy.RESOURCE : 해상도를 줄인 이미지만 캐싱합니다. DiskCacheStrategy.NONE : 디스크 캐싱을 수행하지 않습니다. Glide 이미지 불러오기 절차 (여러 캐시를 확인) Active Resources : 현재 이 이미지가 다른 View에 나타나는가? 를 확인합니다. Memory Cache : 이 이미지가 최근에 메모리에 load 되었거나 여전히 메모리에 남아있는가? 를 확인합니다. Resource : 이 이미지가 예전에 decode 되었거나, 변형 되었거나, 디스크 캐시에 기록되어 있는가? 를 확인합니다. Data : 이 이미지가 이전에 디스크 캐시에 기록 되었던 데이터 였는가? 를 확인합니다.Glide Image Loading Glide는 빌더 패턴으로 구성되어 있고, 3개의 필수 파타미러를 요구합니다. Glide는 기본적으로 비동기로 이미지를 load 합니다. 참고 : 필수 파라미터 with() : context를 넣어줍니다. load() : 대상 이미지를 넣어줍니다.(URL, Resource Id, File Url …) into() : 이미지를 보여줄 ImageView를 넣어줍니다. ✔️ 이미지 변형 참고 : 이미지 변형 함수 centerCrop() : 이미지가 ImaveView보다 클 때, ImageView의 크기에 맞춰 이미지 크기를 조정 후 자릅니다. ImageView가 완전히 채워지지만, 전체 이미지가 표시되지 않을 수 있습니다. fitCenter() : 이미지가 ImageView의 사이즈와 다를 때, ImageView 크기와 같거나 작도록 이미지의 크기를 조정합니다. 이미지가 완전히 표시되지만, 전체 ImageView 크기를 채우지 않을 수 있습니다. circleCrop() : 이미지가 원으로 변경됩니다.(CenterCrop()과 동일한 방식입니다.) ✔️ Option : 사용자 정의할 수 있는 유형 독립적 옵션을 제공합니다. 🚩 RequestOption() 인스턴스를 생성하고 apply()를 활용하여 원하는 Option을 넣습니다. placeHolder(@DrawableRes int resourceId) : 요청받은 이미지가 나타나기 전까지 지정한 이미지를 보여줍니다. 네트워크로 이미지를 요청하거나 큰 이미지를 요청하여 시간이 오래 걸릴 때 PlaceHolder 로 지정한 이미지를 보여줍니다. error(@DrawableRes int resourceId) : 이미지 로드에 실패한 경우 Error 에 지정된 이미지를 보여줍니다. fallback(@Nullable Drawable drawable) : 요청된 URL or 모델이 null 인 경우 fallback으로 지정한 이미지를 보여줍니다. Glide.into(context).load(\"Image Url 넣기\").apply( RequestOption().placeHoler(이미지 로딩 중 표시될 이미지 넣기).error(이미지 로드 실패 시 표시될 이미지 넣기)).into(imageView) ✔️ Target Glide에서 Target 을 사용하면 bitmap, drawable, placeHolder 를 받아 처리할 수 있습니다. 다음은 예제 코드 입니다. 해당 예제 코드는 암시적 인텐트 사용하여 핸드폰의 갤러리에 접근해 받아온 Uri을 비트맵으로 바꾸는 로직입니다. 👇 private val startIntentGallery: ActivityResultLauncher&lt;Intent&gt; = registerForActivityResult( ActivityResultContracts.StartActivityForResult()) { result: ActivityResult -&gt; result.data?.extras?.clear() if (result.data?.data != null &amp;&amp; result.resultCode == AppCompatActivity.RESULT_OK) { val context = binding.imageView.context // ContentProvider를 통해 Image Uri를 bitmap으로 변경합니다. val bitmap = MediaStore.Images.Media.getBitmap( context.contentResolver, result.data?.data!! ) Glide.with(context) .asBitmap() .load(bitmap) override(1024, 1024) .into(object : CustomTarget&lt;Bitmap&gt;() { override fun onResourceReady( resource: Bitmap, transition: Transition&lt;in Bitmap&gt;? ) { // TODO : ImageView에 이미지 넣기 } override fun onLoadCleared(placeholder: Drawable?) {} }) }} Glide Blur 처리 Blur를 통해 이미지를 흐리게 만듭니다. gradle 파일에 다음 dependency 를 추가합니다.👇 implementation \"jp.wasabeef:glide-transformations::4.3.0\" 참고 : 다음은 Glide Blur 처리 예제 코드입니다. 👇BlurTransformation 의 첫 번째 인자는 radius 입니다. 해당 radius 값에 따라 흐림의 정도가 설정됩니다.주의❗️ : BlurTransformation을 사용할때 centerCrop()을 먼저 사용하고 BlurTransformation을 사용해야합니다. 그렇지 않으면 오류가 발생합니다. fun blurImageLoader( context: Context, imageView: ImageView, url: String) { Glide.with(context) .setDefaultRequestOptions( RequestOptions() .diskCacheStrategy(DiskCacheStrategy.RESOURCE) // 해상도를 줄인 이미지만 캐싱 .centerCrop() .transform(BlurTransformation(10, 3)) // Blur 적용 ) .load(url) .into(imageView)} Glide error, placeHolder 처리 예제 다음은 Glide를 이용하여 Image를 Load할때 error, placeHolder를 처리하는 예제입니다. 👇 fun loadImage( view: ImageView, imageUrl: String, @DrawableRes placeholder: Int = 0, @DrawableRes error: Int = 0,) { // imageUrl 이 비어있을 때 로직 추가 if (imageUrl.isEmpty()) { if (placeholder != 0) { view.setImageResource(placeholder) } return } val options = RequestOptions() @SuppressLint(\"CheckResult\") if (error != 0) { // 로드가 실패할 경우 표시할 리소스를 설정합니다. options.error(error) } Glide.with(view.context) .setDefaultRequestOptions(options) .load(imageUrl).apply { @SuppressLint(\"CheckResult\") if (placeholder != 0) { // 리소스가 로드되는 동안 표시할 드로어블 리소스의 Android 리소스 ID를 설정합니다. apply(options.placeholder(placeholder)) } } .into(object : CustomTarget&lt;Drawable&gt;() { override fun onResourceReady(resource: Drawable, transition: Transition&lt;in Drawable&gt;?) { view.setImageDrawable(resource) } override fun onLoadCleared(placeholder: Drawable?) { view.setImageDrawable(placeholder) } })} 마치며이번 포스팅에서는 Glide의 기본 개념에 대하여 알아보았습니다.Glide는 기본적으로 이미지를 비동기로 load하며, 기본적으로 캐싱을 지원하여 보다 빠르게 이미지를 불러올 수 있다는 점을 기억해주시면 되겠습니다." }, { "title": "Android Paging3 에 대하여", "url": "/posts/Android-Paging3/", "categories": "Android, Paging3", "tags": "android, paging3", "date": "2022-07-21 17:06:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 Paging3 에 대하여 알아보도록 하겠습니다.페이징이란 대량의 데이터를 한 번에 불러오는 것이 아니라 필요한 만큼 ““일부분을 나눠서 가져오는 것\"”을 말합니다.API에 따라 limit(한 번에 보여줄 데이터의 개수 제한), offset(데이터의 인덱스)등으로 페이징이 처리 되어 있습니다.해당 포스팅에서는 Naver Open API 를 기준으로 설명 드리겠습니다.해당 프로젝트의 전체 코드입니다. 👉🏿 영화검색앱Paging 3 사용 이유 페이징 된 데이터의 메모리 캐싱으로 시스템 리소스를 효율적으로 사용할 수 있습니다. 요청 중복 제거 기능을 지원합니다. RecyclerView 를 스크롤 할 때 밑으로 스크롤 시 nextKey에 따라 자동으로 data를 load 합니다. Refresh(새로고침), Retry(재시도), 오류 처리를 지원합니다.Paging3 의 구조 페이징 라이브러리는 안드로이드 권장 아키텍쳐에 맞게 설계 되어있으며, 총 3개의 Layer로 구성 됩니다. 위의 그림을 참고하여 설명하겠습니다. 1. Repository Layer PagingSource : 각 페이지에서 데이터를 얻는 방법을 정의합니다. (Local DB에서 데이터를 저장하거나 서버에서 받아오도록 설정이 가능합니다.) 즉, 데이터를 가져오는 방법을 정의합니다. RemoteMediaor : 로컬 데이터베이스를 이용해 네트워크 데이터를 캐싱하기 위해 사용됩니다.2. ViewModel Layer PagingConfig를 바탕으로 PagingSource에서 데이터를 얻어 PagingData를 만들고 Flow형으로 UI에 넘겨줍니다. Pager : PagingSource를 리턴타입으로 하는 람다와 PagingConfig를 생성자로 받으며 PagingData 를 반응형 스트림으로 생성할 수 있습니다. 참고 PagingConfig 페이징 구성 클래스로 PagingSource를 구성하는 방법을 정의합니다. pageSize 파라미터로 각 페이지에 얼마나 많은 데이터가 있어야 하는지 정의합니다. 즉 각 페이지에 보여줄 데이터의 갯수를 정의합니다. PagingData : 페이징된 데이터를 담아두는 컨테이너 입니다. Paging Source에서 load한 결과를 저장하며 UI Layer의 PagingDataAdapter로 넘겨 줍니다. (ViewModel Layer를 UI Layer에 연결하는 구성요소 입니다.)페이지로 나눈 데이터의 SnapShot을 보유하는 컨테이너 입니다.3. UI Layer PagingDataAdapter PagingData 를 입력 유형으로 사용하고 내부 로드 이벤트를 수신합니다. RecyclerViwe 의 Adapter 와 연결하여 사용합니다. BackGround Thread에서 DiffUtil 을 사용하여 미세 조정한 후 데이터를 load 하므로 UI Thread에 새 항목을 추가하는 동안 문제가 발생하지 않습니다. 코드를 통해 알아보기 깃허브 해당 프로젝트는 Naver Open API 를 이용하였으며 Clean Archtecture MVVM 구조 입니다. 1. PagingSource 정의 suspend fun load(params: LoadParams) : 각 페이지에서 데이터를 load 하는 방법을 정의합니다. nextKey : 스크롤을 밑으로 내렸을 때 더 많은 데이터를 로드할 수 있는 경우 다음 페이지에 대한 Key 입니다. 이 key를 기점으로 다음 Page의 데이터를 Load합니다. 다음 Page가 없을 경우 Null 입니다. prevKey : 스크롤을 위로 올렸을 때 더 많은 데이터를 로드할 수 있는 경우 이전 페이지에 대한 Key입니다. 이 key를 기점으로 이전 Page의 데이터를 Load 합니다. 이전 Page에 load할 데이터가 없을 경우 Null 입니다. params.key 는 현재 페이지의 Key로 Naver API 의 경우 처음 Index 가 1이기 때문에 null 일 경우 1을 반환합니다.(params.key는 처음 load할 경우 null입니다.) getRefreshKey(state: PagingState&lt;Int, MovieInfoModel&gt;) 함수는 Adapter Refresh를 할 경우 해당 메서드가 호춛되는데 여기서는 Refresh 할 경우 처음 부터 전부 데이터를 가져오기 위해 Null을 반환합니다. class MovieInfoListPagingDataSource @Inject constructor( private val remoteDataSource: RemoteDataSource, private val searchQuery: StateFlow&lt;String&gt;, private val limit: Int) : PagingSource&lt;Int, MovieInfoModel&gt;() { override suspend fun load(params: LoadParams&lt;Int&gt;): LoadResult&lt;Int, MovieInfoModel&gt; { val pageNumber = params.key ?: 1 try { val response = withContext(Dispatchers.IO) { remoteDataSource.requestSearchMovie( query = searchQuery.value, start = pageNumber, display = limit ) } if (response.isSuccessful) { response.body()?.let { val movieList = it.items.toMovieInfoListModel() /** * nextKey -&gt; naver Api의 start 는 index 이고, 현재 display(limit) 가 10 이므로 * 10 이후에 start 값은 11 이 되어야함 * 스크롤되어 페이지가 추가될때 마다 10개씩 가져온다. */ return LoadResult.Page( data = movieList, prevKey = null, nextKey = if (it.items.size &gt;= limit) { pageNumber + limit } else { null } ) } } return LoadResult.Error( LoadException(\"영화 정보를 가져오는데 실패하였습니다.\") ) } catch (e: Exception) { Timber.e(\"paging catch Error -&gt; ${e.message}\") return LoadResult.Error(e) } } override fun getRefreshKey(state: PagingState&lt;Int, MovieInfoModel&gt;): Int? { // 새로고침 될때 항상 전부 새로고침 되도록 null 을 return return null }} 2. RepositoryImpl (레파지토리 구현) Flow&lt;PagingData&gt; 객체를 Return 합니다. pageSize 는 한 페이지당 몇 개의 Data를 보여줄지 설정합니다. class NaverRepositoryImpl @Inject constructor( private val remoteDataSource: RemoteDataSource) : NaverRepository { override fun getMovieList(query: StateFlow&lt;String&gt;): Flow&lt;PagingData&lt;MovieInfoModel&gt;&gt; { return Pager( config = PagingConfig(pageSize = 10), pagingSourceFactory = { MovieInfoListPagingDataSource( remoteDataSource = remoteDataSource, searchQuery = query, limit = 10 ) } ).flow.distinctUntilChanged().flowOn(Dispatchers.IO) }} 3. UseCase에서 받기 해당 UseCase에서 NaverRepository를 받아 처리합니다. 이렇게 처리된 UseCase는 ViewModel 에서 Hilt를 통해 생성자에 주입받아 사용합니다. class GetMovieListPagingDataUseCase @Inject constructor( private val naverRepository: NaverRepository) { operator fun invoke( query: StateFlow&lt;String&gt; ): Flow&lt;PagingData&lt;MovieInfoModel&gt;&gt; { return naverRepository.getMovieList(query) }} 4. ViewModel 에서 사용 ViewModel 에서 GetMovieListPagingDataUseCase를 Hilt를 통해 생성자에서 받아 처리합니다. 해당 LoadingType 은 PagingData 의 loadState에 따라 DataBinding을 통해 UI를 업데이트 해주기 위해 사용합니다. cachedIn(viewModelScope)를 사용하여 캐싱에 사용될 Coroutine Scope를 지정합니다. @HiltViewModelclass HomeViewModel @Inject constructor( private val getMovieListPagingDataUseCase: GetMovieListPagingDataUseCase) : BaseViewModel() { val loadingType = MutableStateFlow(MovieLoadingType.LOADING) val getMovieList: Flow&lt;PagingData&lt;MovieInfoModel&gt;&gt; = getMovieListPagingDataUseCase(searchQuery).cachedIn(viewModelScope) enum class MovieLoadingType { LOADING, EMPTY, ERROR, VIEW }} PagingAdapter 구현 RecyclerView 의 Adapter 에 사용될 PagingAdapter를 구현합니다. DiffUtil을 사용하고 있으며, 클릭 리스너를 가지고 있습니다. 또한 DataBinding으로 처리합니다. DiffUtil 은 areItemsTheSame()이 ture를 반환하면, areContentsTheSame()를 호출하고 areContentsTheSame()또한 true를 반환하면 같은 객체라고 판단합니다. class MovieInfoAdapter : PagingDataAdapter&lt;MovieInfoModel, MovieInfoAdapter.MovieInfoViewHolder&gt;( diffUtil) { interface OnItemClickListener { fun onClick(item: MovieInfoModel, position: Int) } interface MovieRankingPresenter { fun onRootClick(view: View?) } private var listener: OnItemClickListener? = null fun setOnItemClickListener(listener: OnItemClickListener) { this.listener = listener } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MovieInfoViewHolder { val binding: MovieInfoItemBinding = DataBindingUtil.inflate( LayoutInflater.from(parent.context), R.layout.movie_info_item, parent, false ) return MovieInfoViewHolder(binding) } override fun onBindViewHolder(holder: MovieInfoViewHolder, position: Int) { getItem(position)?.let { holder.bind(it, listener) } } inner class MovieInfoViewHolder( private val binding: MovieInfoItemBinding ) : RecyclerView.ViewHolder(binding.root), MovieRankingPresenter { private var listener: OnItemClickListener? = null fun bind(info: MovieInfoModel, listener: OnItemClickListener?) { binding.info = info binding.presenter = this this.listener = listener binding.executePendingBindings() } override fun onRootClick(view: View?) { binding.info?.let { listener?.onClick(it, bindingAdapterPosition) } } } companion object { private val diffUtil = object : DiffUtil.ItemCallback&lt;MovieInfoModel&gt;() { override fun areItemsTheSame( oldItem: MovieInfoModel, newItem: MovieInfoModel ): Boolean { return oldItem.title == newItem.title } override fun areContentsTheSame( oldItem: MovieInfoModel, newItem: MovieInfoModel ): Boolean { return oldItem == newItem } } }} Fragment 구현 ViewModel로 부터 Flow&lt;PagingData&gt;를 받아 PagingDataAdapter에 넘겨줍니다. PagingAdapter의 loadState를 받아와 상황별로 UI를 컨트롤 합니다. 참고 🚩 loadState 상태 설명 LoadState.NotLoading : 로딩이 끝나고 Error 없이 데이터를 보여주는 상태입니다. LoadState.Loading : 데이터가 load 되고 있으며, 사용자에게 진행 상황을 보여줄 수 있습니다. LoadState.Error : 데이터 load 중 error 발생한 상태입니다. CombinedLoadStates.refresh : PagingData 의 Load 가 끝난 상태입니다. CombinedLoadStates.append : PagingData 의 Load 가 끝난 상태입니다. endOfPaginationReached : Load 가능 여부, true 면 더 이상 Load 를 하지 못합니다. @AndroidEntryPointclass HomeFragment : BaseFragment&lt;FragmentHomeBinding, HomeViewModel&gt;( R.layout.fragment_home), View.OnFocusChangeListener, TextWatcher { override val viewModel: HomeViewModel by viewModels() private val movieInfoAdapter by lazy { MovieInfoAdapter() } private lateinit var scrollLayoutManager: LinearLayoutManager private var scrollReset = false private val scrollListener = object : RecyclerView.OnScrollListener() { override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) { super.onScrolled(recyclerView, dx, dy) val lastVisibleItemPosition = scrollLayoutManager.findFirstVisibleItemPosition() // 스크롤 시 Scroll Top Button 을 보여줍니다. if (lastVisibleItemPosition &gt;= 1) { binding.topButton.show() } else { binding.topButton.hide() } } } private val keyboardObserver = object : KeyboardUtils.SoftKeyboardToggleListener { override fun onToggleSoftKeyboard(isVisible: Boolean, height: Int) { // keyboard 가 보이지 않을 때 searchEt 포커스를 해제합니다. if (!isVisible) { binding.searchEt.let { if (it.isFocusable) { it.clearFocus() } } } } } override fun onAttach(context: Context) { super.onAttach(context) KeyboardUtils.addKeyboardToggleListener(requireActivity(), keyboardObserver) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.viewModel = this.viewModel binding.focusListener = this binding.textListener = this binding.noResultLayout.noResultText = resources.getString(R.string.str_no_search) binding.listView.apply { scrollLayoutManager = layoutManager as LinearLayoutManager adapter = movieInfoAdapter.withLoadStateHeaderAndFooter( header = MyLoadStateAdapter { movieInfoAdapter.retry() }, footer = MyLoadStateAdapter { movieInfoAdapter.retry() } ) addOnScrollListener(scrollListener) } // ViewModel로 부터 받아온 PagingData 를 PagingDataAdapter 에 넣어줍니다. viewModel.getMovieList.observeOnLifecycleStop(viewLifecycleOwner) { movieInfoAdapter.submitData(it) } // PagingDataAdapter 의 loadState 에 따라 UI를 컨트롤 합니다. movieInfoAdapter.loadStateFlow.observeOnLifecycleStop(viewLifecycleOwner) { viewModel.loadingType.value = when { // 초기 load 또는 새로고침이 실패하면 -&gt; ERROR it.source.refresh is LoadState.Error &amp;&amp; movieInfoAdapter.itemCount == 0 -&gt; { if (binding.refreshView.isRefreshing) { binding.refreshView.isRefreshing = false } MovieLoadingType.ERROR } // List 가 비어있는 경우 -&gt; EMPTY it.source.refresh is LoadState.NotLoading &amp;&amp; movieInfoAdapter.itemCount == 0 -&gt; { if (binding.refreshView.isRefreshing) { binding.refreshView.isRefreshing = false } MovieLoadingType.EMPTY } // Local Db 또는 Remote 에서 새로 고침이 성공한 경우 -&gt; VIEW it.source.refresh is LoadState.NotLoading -&gt; { if (binding.listRefreshView.isRefreshing) { binding.listRefreshView.isRefreshing = false } if (scrollReset) { scrollReset = false binding.listView.stopScroll() scrollLayoutManager.scrollToPositionWithOffset(0, 0) } MovieLoadingType.VIEW } else -&gt; MovieLoadingType.LOADING } } // PagingDataAdapter 의 Click Listener 입니다. movieInfoAdapter.setOnItemClickListener(object : MovieInfoAdapter.OnItemClickListener { override fun onClick(item: MovieInfoModel, position: Int) { startActivity( WebViewActivity.getInAppBrowserIntent( activity = requireActivity(), url = item.link, pageTitle = \"영화 상세 정보\", showTitle = true ) ) } }) // IME_ACTION_SEARCH : 키보드 search 모양 클릭 시 Listener 등록 binding.searchEt.setOnEditorActionListener { _, actionId, _ -&gt; if (actionId == EditorInfo.IME_ACTION_SEARCH) { viewModel.onSearchClick() true } else { false } } initViewModelCallback() } private fun initViewModelCallback() = with (viewModel) { // 스크롤 Top 버튼 클릭 시 해당 Callback이 실행됩니다. scrollTop.onEach { binding.listView.stopScroll() scrollLayoutManager.scrollToPositionWithOffset(0, 0) }.observeInLifecycleStop(viewLifecycleOwner) // Refresh Layout 으로 Refresh 할 경우 해당 Callback이 실행됩니다. refresh.onEach { if (binding.refreshView.isRefreshing) { binding.refreshView.isRefreshing = false } scrollReset = true movieInfoAdapter.refresh() onScrollTop() }.observeInLifecycleStop(viewLifecycleOwner) // 검색 버튼 클릭 시 해당 Callback이 실행됩니다. search.onEach { onRefreshList() }.observeInLifecycleStop(viewLifecycleOwner) } // Edit Text의 OnFocusChangeListener를 정의합니다. override fun onFocusChange(view: View?, hasFocus: Boolean) { if (view != null) { when (view.id) { R.id.searchEt -&gt; { viewModel.searchFocusView.value = hasFocus } } } } // Edit Text의 TextWatcher를 정의합니다. override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {} override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {} override fun afterTextChanged(s: Editable?) { viewModel.notBlankContents.value = if (!s.isNullOrEmpty()) { viewModel.searchFocusView.value = true true } else { false } } override fun onDetach() { KeyboardUtils.removeKeyboardToggleListener(keyboardObserver) super.onDetach() }}마치며이번 포스팅에서는 Paging3를 사용하는 이유와 Clean Architecture에서 Paging3를 사용하는 방법에 대하여 알아보았습니다.페이징이란 대량의 데이터를 한 번에 불러오는 것이 아니라 필요한 만큼 ““일부분을 나눠서 가져오는 것”” 이라는 점을 기억하시면 되겠습니다.해당 프로젝트의 전체 코드는 Naver Open API 영화 검색에서 확인하실수 있습니다." }, { "title": "Android StateFlow, SharedFlow, Coroutine Channel 에 대하여", "url": "/posts/Android-StateFlow/", "categories": "Android, Coroutine", "tags": "android, stateFlow, sharedFlow, channel, coroutine", "date": "2022-07-21 11:11:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 StateFlow, SharedFlow, Coroutine Channel 에 대하여 알아보고자 합니다.아직 Flow에 대하여 잘 모르시면 Flow 포스팅을 참고하시길 바랍니다. 👉 Flow에 관하여Flow는 Cold Stream입니다. 즉, collector 를 공유할 수 없어 collect를 할때마다 각기 다른 데이터가 수집됩니다.StateFlow, SharedFlow는 Flow의 단점을 극복하기 위해 나왔습니다.StateFlow, SharedFlow는 Hot Stream으로 collector를 공유 합니다. 자세한건 밑에서 알아보도록 하겠습니다.🍀 Flow의 단점 Flow는 스스로 Android의 Lifecycle에 대해 알지 못합니다. ✅ 즉, Lifecycle에 따른 중지나 재개가 어렵습니다. Flow는 상태가 없어 값이 할당된 것인지, 현재 값은 무엇인지 알기 어렵습니다. Flow는 Cold Stream 방식으로, 연속해서 계속 들어오는 데이터를 처리할 수 없으며, Collect 되었을 때만 생성되고 값을 반환 합니다. 참고 👉 만약, 하나의 flow builder 에 대해 다수의 Collector 가 있다면 Collector 하나마다 하나씩 데이터를 호출 하기 때문에 UpSteam이 비싼 비용을 요구하는 DB 접근이나 서버 통신 등이라면 여러 번 리소스 요청 을 하게 될 수 있습니다. 🍀 StateFlow Hot Stream 방식입니다. 즉, collect가 공유 되어 오직 하나의 Flow만을 실행 하게 합니다. ✅ 참고 👉 Flow와 다르게 하나의 StateFlow를 통해 DB에 접근할 때 여러개의 Collect를 쓰더라도 DB에는 한번만 접근 합니다. 초기 데이터(기본 값)이 항상 존재 해야 합니다. 마지막 값의 개념이 있으며 생성하자 마자 활성화 됩니다. 값이 업데이트 된 경우에만 반환하고 동일한 값을 반환하지 않습니다. Flow 의 distinctUtilChanged()가 항상 포함되어 있다고 생각하시면 됩니다. .value를 사용하여 현재 값에 접근 할 수 있습니다. SharedFlow 의 replay 값이 1로 고정된 경우와 같습니다. 참고 👉 새로운 subscriber가 등록될 때 바로 최신의 값을 가져 옵니다. 1️⃣ 예제 ) StateFlow 생성 👇🏾 @HiltViewModelclass MainViewModel @Inject constructor() : ViewModel() { // StateFlow 생성 private val _isAdult = MutableStateFlow(false) val isAdult: StateFlow&lt;Boolean&gt; = _isAudult.asStateFlow() // StateFlow에 값 넣기 fun onIsAdultClick() { _isAdult.value = !isAdult.value }} 2️⃣ 예제 ) StateFlow Collect 👇🏾 @AndroidEntryPointclass MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val mainViewModel: MainViewModel by viewModels() override fun onCreate(saveInstanceState: Bundle?) { binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this lifecycleScope.launchWhenStarted { mainViewModel.isAdult.collect { it: Boolean // TODO : true, false 동작 넣기 } } }} 🍀 SharedFlow Hot Stream 방식으로 여러개의 Collector를 공유하여 오직 하나의 Flow만을 실행하게 합니다.( 아무리 많은 Collector가 존재해도 오직 하나의 Flow만 실행 ) firstOrNull을 통해 현재 값에 접근 가능 합니다. 초기 값이 필요없으며, 중복된 값이 필요한 경우 사용 ✅ 참고 👉 중복 값이 필요한 경우란 Event를 말하는데 예를들어 API를 호출하였을 때 실패의 경우 연속 적으로 실패할 수 있으므로 이럴때는 SharedFlow를 사용합니다. 만약, SharedFlow 한 개를 정의하고 Database 결과값을 공유하게 한 뒤, 여러 개의 Collector를 달아 준다면 Database 접근은 오직 한 번만 일어납니다. SharedFlow 파라미터 👇 replay : Collect 시 전달받을 이전 데이터의 개수 지정, replay가 0이면 Collect 시점에 담겨있던 데이터부터 전달 받습니다. replay가 1이면 collect 시점 직전의 데이터부터 전달 받으며 시작(최신 데이터)합니다. 0 : collect 이후의 데이터를 전달 받습니다. (새로운 구독자에게 이전 이벤트를 전달하지 않습니다.) 1 : collect 시점 직전의 데이터부터 전달받으며 시작합니다.( 최신 데이터 ) 2 : 현재 데이터 이전 두개의 데이터 부터 전달받으면서 시작합니다. extraBufferCapacity : buffer의 개수를 설정합니다. flow의 emit이 빠르고 collect가 느릴 때 지정된 개수만큼 buffer에 저장되고, 저장된 개수가 넘어가면 'onBufferOverFlow'에 설정된 정책에 따라 동작 합니다. onBufferOverFlow : Buffer 가 꽉 찼을 때 동작을 정의합니다. SUSPEND : buffer가 꽉 찼을 때 emit을 수행하면 emit 코드가 blocking 됩니다. 즉, buffer의 빈자리가 생겨야 emit코드 이후의 코드가 수행 될 수 있습니다. DROP_OLDSET : buffer가 꽉 찼을 때 emit을 수행하면 오래된 데이터부터 삭제하면서 새로운 데이터를 넣습니다. DROP_LATEST : buffer 가 꽉 찼을 때 emit을 수행하면 최근 데이터를 삭제하고 새로운 데이터를 넣습니다. 🍀 StateIn / SharedIn Flow Builder 로 만든 Clod Flow를 Hot Flow로 변경 할 수 있는 확장함수 입니다. 하나의 Flow 에서 방출된 값을 여러개의 Collector 에서 받아야할 경우 에 유용하게 사용됩니다. stateIn() / sharedIn() 파라미터 scope 👉 공유가 시작되는 Coroutine Scope를 설정합니다. started 👉 공유가 시작 및 중지되는 시기를 제어 하는 전략을 설정합니다. Eagerly 👇 Collector 가 존재하지 않더라도 바로 Sharing이 시작되며, 중간에 중지되지 않습니다. 값이 replay 크기 보다 많이 들어오면 바로 삭제됩니다. 즉, 즉시 시작되며 Scope가 취소되면 중지됩니다. Lazily 👇 Collector 가 등록된 이후부터 Sharing이 시작되며 중간에 중지되지 않습니다. 첫 번째 Collector는 그 동안 emit된 모든 값들을 얻으며, 이후에 Collector는 replay 개수 만큼 값을 얻어갑니다. ✅ 즉, Collector가 모두 없어지더라도 Sharing 동작을 유지되며 replay 개수만큼 Cache하고 Sopce가 취소되면 중지됩니다. WhileSubscribed 👇 Collector 가 등록되면 바로 Sharing을 시작하며, Collector 가 전부 없어지면 바로 Sharing을 중지 합니다. 이때 replay 개수만큼 Cache 처리 됩니다. stopTimeOutMillis 👇 collector가 모두 사라진 이후에 정지할 delay를 넣습니다. 즉, Collect가 사라지고 몇 초 후에 Sharing을 중지할지 설정 합니다. 0이면 Collector가 모두 사라지는 순간에 바로 정지합니다. 5,000을 사용하면 Configuration(구성요소) 변경과 같은 특정 상황에서 이득을 볼 수 있습니다. replayExpirationMillis 👇 cache 한 값을 유지할 시간을 정합니다. 시간이 지나면 stateIn의 초기 값으로 복원 됩니다. 기본 값 👉 replay cache를 영구적으로 유지하며 buffer를 재 생성하지 않습니다. 0을 사용 👉 cache를 즉각적으로 만료 시킬 수 있습니다. initialValue 👉 stataIn 사용 시 초기 값을 설정 합니다. replay 👇 sharedIn 사용 시 사용되며( StateFlow는 replace 값이 1로 고정되어 있습니다. ), Collect 시 전달받을 이전 데이터의 개수 지정 지정 replay가 0 👉 Collect 시점에 담겨있던 데이터부터 전달 받습니다. replay가 1 👉 collect 시점 직전의 데이터부터 전달 받으며 시작합니다.( 최신 데이터 ) ❗️주의❗️ 👉 stateIn, sharedIn을 함수로 만들면 매번 재 사용되지 않는 새로운 instance를 만들게 됩니다. 아래는 해당 코드의 샘플 예제 입니다. 👇🏾 @HiltViewModelclass MainViewModel @Inject constructor( private val getCastInfoUseCase: GetCastInfoUseCase) : ViewModel() { // 해당 Result Sealed Class 는 보다 이해를 돕기위해 ViewModel에서 생성하였습니다. sealed class Result&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Loading&lt;T&gt;: Result&lt;T&gt;() class Success&lt;T&gt;(data: T) : Result&lt;T&gt;(data) class NetworkError&lt;T&gt;(message: String?, data: T? = null) : Result&lt;T&gt;(data, message) class Error&lt;T&gt;(message: String?, data: T? = null) : Result&lt;T&gt;(data, message) } private val getCastInfo: StateFlow&lt;Result&lt;CastInfoResponseModel&gt;&gt; = getCastInfoUseCase() .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5000), initialValue = Result.Loading() ) fun requestCastInfo() = viewModelScope.launch { getCastInfo().collect { result -&gt; when (result) { is Result.Loading -&gt; { showLoadingDialog() } is Result.Success -&gt; { hideLoadingDialog() // TODO : API 요청 성공일 때 동작 넣기 } is Result.NetworkError -&gt; { hideLoadingDialog() // TODO : Network 오류 발생 때 동작 넣기 } is Result.Error -&gt; { hideLoadingDialog() // TODO : API ERROR 발생 때 동작 넣기 } } } }} 🍀 Coroutine Channel Channel은 단방향 Observing 이라고 생각하시면 쉽습니다. ✅ 참고 LiveData에서는 단방향 옵저빙을 위해 SingleLiveEvent 혹은 Event Wrapper 를 사용합니다. Coroutine Channel 은 Flow의 단방향 옵저빙 이라고 생각하시면 됩니다. Channel은 정확히 한 번만 처리해야하는 이벤트 를 처리하는 데 사용됩니다. 이는 일반적으로 단일 구독자 가있는 이벤트 유형의 설계에서 사용됩니다. ✅ 참고 예를 들면 Click Event Listener 가 이에 해당합니다. Click Event Listener는 항상 Observing 할 필요없이 눌렀을 때만 Observing 하면 되므로 이럴 때 Channel 을 사용합니다. send 값이 오지않으면 Observing을 하지않고, send 값이 들어오면 Observing 시작합니다. Channel의 Buffer Type Rendezvous (Unbuffered) : 기본 타입으로 버퍼가 없습니다. Conflated : 크기가 1인 고정 버퍼가 있는 채널이 생성 됩니다. 만약에 수신하는 Coroutine이 송신하는 Coroutine을 따라잡지 못했다면, 송신하는 쪽은 새로운 값을 Buffer의 마지막 아이템에 덮어씌웁니다. 즉, 최신 값을 받습니다. Buffered : 이 모드는 고정된 크기의 버퍼를 생성 (Buffer는 Array 형식)합니다. 송신 Coroutine은 Buffer가 꽉 차있으면 새로운 값을 보내는 걸 중단 합니다. 수신 Coroutine 은 Buffer가 빌때까지 계속해서 꺼내서 수행합니다. Unlimited : 제한 없는 크기의 버퍼를 생성 (Buffer는 LinkedList 형식)합니다. 만약에 Buffer가 소비되지 않았다면 메모리가 힘들어할때까지 계속해서 아이템을 착착 채우고 결국엔 OutOfMemeoryException을 일으키게 됩니다. 1️⃣ 다음은 Coroutine Channel 예제 입니다. 👇🏾 @HiltViewModelclass MainViewModel @Inject constructor() : ViewModel() { private val _actionLogin = Channel&lt;Unit&gt;(Channel.CONFLATED) val actionLogin = _actionLogin.receiveAsFlow() fun onLoginClick() = viewModelScope.launch { _actionLogin.send(Unit) }} 2️⃣ 다음은 수신을 받아서 사용하는 쪽 예제 입니다. @AndroidEntryPointclass MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val mainViewModel: MainViewModel by viewModels() override fun onCreate(saveInstanceState: Bundle?) { binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this lifecycleScope.launchWhenStarted { mainViewModel.actionLogin.collect { // TODO: 로그인 버튼 클릭 시 동작할 코드 넣기 } } }} 🍀 Flow Observer Flow는 스스로 Android의 Lifecycle에 대해 알지 못합니다. ( Lifecycle에 따른 중지나 재개가 어렵습니다. ) 따라서 해당 문제를 해결하기 위해 Custom Class를 만듭니다. 해당 코드는 lifecycle 이 onStart가 되면 구독을 시작하고, onStop이 되면 구독 취소 합니다. 1️⃣ 다음은 FlowObserver 예제 코드 입니다. 👇 class FlowObserverInStop&lt;T&gt;( lifecycleOwner: LifecycleOwner, private val flow: Flow&lt;T&gt;, private val collector: suspend (T) -&gt; Unit) { private var job: Job? = null init { lifecycleOwner.lifecycle.addObserver(LifecycleEventObserver { source, event -&gt; when (event) { Lifecycle.Event.ON_START -&gt; { job = source.lifecycleScope.launch { flow.collect { collector(it) } } } Lifecycle.Event.ON_STOP -&gt; { job?.cancel() job = null } else -&gt; {} } }) }}inline fun &lt;reified T&gt; Flow&lt;T&gt;.observeOnLifecycleStop( lifecycleOwner: LifecycleOwner, noinline collector: suspend (T) -&gt; Unit) = FlowObserverInStop(lifecycleOwner, this, collector)// .onEach{ } 사용할때 사용inline fun &lt;reified T&gt; Flow&lt;T&gt;.observeInLifecycleStop( lifecycleOwner: LifecycleOwner) = FlowObserverInStop(lifecycleOwner, this) {} ✅ 설명 👇 observeOnLifecycleStop() 의 매개변수에는 lifecycle 을 넣습니다. Activity의 경우 this 이고, Fragment인 경우 viewLifecycleOwner를 넣어주시면 됩니다. 2️⃣ FlowObserver 사용 예제 입니다. 👇🏾 @AndroidEntryPointclass MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val mainViewModel: MainViewModel by viewModels() override fun onCreate(saveInstanceState: Bundle?) { binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this // StateFlow Observing mainViewModel.actionLogin.observeOnLifecycleStop(this) { // TODO : true, false 동작 넣기 } // Coroutine Channel Observing mainViewModel.actionLogin.onEach { // TODO: 로그인 버튼 클릭 시 동작할 코드 넣기 }.observeInLifecycleStop(this) }} 🍀 마치며이번 포스팅에서는 StateFlow, SharedFlow, Coroutine Channel 에 대하여 알아보았습니다.LiveData를 사용하고 Event Wrapper를 통해 단방향 Observing을 처리해도 되지만 문제는 Clean Architecture에 있습니다.LiveData는 UI에 밀접하게 연관되어 있기 때문에 Clean Architecture로 Project를 구성하면 Domain, Data layer에서 비동기 방식으로 데이터를 처리하기에 자연스러운 방법이 없습니다.또한 LiveData 는 안드로이드 플랫폼에 속해 있기 때문에 순수 Java / Kotlin 을 사용해야 하는 Domain Layer 에서 사용하기에 적합하지 않습니다.이럴 경우 LiveData를 대체하여 StateFlow 나 SharedFlow 또는 Coroutine Channel을 사용 할 수 있습니다." }, { "title": "Android Naver Open API 영화 검색 어플", "url": "/posts/Android-Clean-Architecture/", "categories": "Android, Naver Open API", "tags": "android, cleanArchitecture, MVVM", "date": "2022-07-21 11:11:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅에서는 “Naver Open API를 이용한 영화 검색” 어플에 사용된 기술과 프로젝트에 대하여 알아보겠습니다.재직중인 회사에서 사용하는 기술을 과제의 주제에 벗어나지 않는 선에서 모두 보여드리고 노력하였습니다.해당 프로젝트 전체 코드 👉🏿 Naver Open API를 이용한 영화 검색 어플앱 기능 Naver Open API를 사용하여 원하는 영화를 검색합니다. 검색한 내용을 RecyclerView를 통해 보여주며 Paging3를 사용하여 Page에 따라 list를 추가로 불러와 보여줍니다. 참고 : 해당 포스팅에 Paging3에 관하여 자세히 정리 했습니다. 👉🏿 Paging3에 대하여 RecyclerView에 썸네일 이미지, 제목, 평점, 연도, 감독, 출연 배우를 표기하고 Item Click 시 해당 API Response에 있는 link를 바탕으로 WebView를 띄워줍니다. 참고 : 해당 프로젝트에서는 Image Load를 위해 Glide를 사용합니다. 다음은 Glide 관련 포스팅입니다. 👉🏿 Glide Image 처리 해당 어플은 Network가 끊겼을 때 할 수 있는 동작이 없기 때문에 ConnectivityManager를 통해 Network Callback을 받아 네트워크가 끊겼을 때 네트워크가 끊겼다는 화면을 보여줍니다. 네트워크가 연결되면 자동으로 해당 화면이 사라지고 어플을 계속 컨트롤 할 수 있습니다. 참고 : 해당 포스팅에 ConnectivityManager를 통한 Netwrok 관리에 관하여 자세히 정리 했습니다.👉🏿 Netwrok 관리 프로젝트의 패턴은 Claen Architecture MVVM 을 채택하였습니다. AAC ViewModel 을 사용하여 앱 구성요소 변경에도 앱의 데이터와 내용이 사라지지 않게 설계하였습니다. Single Activity를 적용하였습니다. Jetpack Navigation을 통해 Single Activity를 적용하였으며, 이렇게한 이유 역시 재직중인 회사에서 사용하는 기술을 과제의 주제에 벗어나지 않는 선에서 모두 보여드리고자 선택하였습니다.🚩참고🚩 Single Activity의 장단점 1️⃣ 장점 : Activity Stack에 Activity를 쌓아두기 보다. Fragment BackStack에서 Fragment를 관리하는 것이 메모리 관리에서의 효율도 챙기고 화면 전환시 Activity 보다 순조롭습니다. 2️⃣ 장점 : 데이터 공유에 있어 이점이 있습니다. Activity간 Data를 전달하려면 Intent를 통해 직렬화/역직렬화를 과정을 거쳐야 하며, 이는 메모리 공유에 비해 결코 가벼운 작업이 아닙니다. 3️⃣ 장점 : 재사용성이 증가합니다. View 나 Business Logic을 Fragment 단위로 분리 가능합니다. 이는 아키텍쳐 원칙에서 가장 중요한 원칙인 관심사 분리를 통해 의존성을 분리하고 독립성을 가지게 합니다. 4️⃣ 장점 : 유연한 UI 구현이 가능합니다. (Navigation Component, BottomSheetDialog 등..) 1️⃣ 단점 : 비동기로 인해 예기치 않은 동작이 발생할 수 있습니다. 2️⃣ 단점 : Transaction 내에서 문제가 발생한다면 디버그가 매우 어려운 IllegalStateException을 발생시킵니다. StateFlow, Coroutine Channel을 사용하였습니다. Clean Architecture에서 LiveData 사용시 View의 의존성이 없는 Domain, Data Layer에서는 비동기 방식으로 데이터를 처리하기에 자연스러운 방법이 없기에 StateFlow, Coroutine Channel 을 사용하였습니다.참고 : 해당 포스팅에 StateFlow, Channel 에 관하여 자세히 정리 했습니다. 👉🏿 StateFlow, Channel Dagger-Hilt 를 통한 DI(Dependency Injection) 관리를 적용하였습니다. Domain Layer, Data Layer 와 최종적으로 Presentation Layer의 의존성 관리를 위해 Hilt 를 사용하였습니다. Clean Architecture 란 Clean Code 로 소프트웨어 공학의 대가 “로버트 C.마틴”이 제시한 소프트웨어 디자인 철학입니다. 소프트웨어의 관심사를 계층별로(domain, data, presentation)로 분리하여 코드 종속성이 외부로부터 내부로 의존하도록 하는 것이 주요 원칙입니다.Clean Architecture 장점 코드의 재사용성이 용이해집니다. 참고 : 멀티 모듈로 분리하여 작성시 API는 같고(회원가입, 로그인) 앱의 구성만 다른 경우 Domain Layer, Data Layer는 그대로 복사해서 가져와 사용할 수 있음 Unit Test에 있어 용이해집니다. 참고 : 비즈니스 규칙은 UI, DB, 백엔드 서버등 외부와 무관하게 테스팅이 가능합니다. UI 독립성 참고 : UI 변경이 시스템의 나머지 부분에 영향을 미치지 않습니다. 유지보수 용이 참고 : 각 모듈의 의존성을 분리하므로 만약 코드 한 곳을 바꾼다고 하여도 나머지 부분을 변경할 필요가 없습니다. Android Clean Architecture 구조 위의 사진을 참고하시면 이해가 쉽습니다. 위의 사진의 Entity는 Android에서는 Model로 정의합니다. 참고 : Domain Layer의 Model은 사용자에게 직접 보여줄 Model 로 API에서 내려오는 Response에 직접 접근하지 않고 DTO를 통해 접근한다고 생각하시면 됩니다. 아래에서 자세히 알아보겠습니다. 1. Domain Layer 어떤 모듈에도 의존적이지 않는 독립적인 Module 입니다.(최상위 모듈) 비즈니스 로직을 처리하는 곳 입니다. Data Layer에 접근하기 위한 interface를 갖고 있습니다. (Repository interface정의) 안드로이드에 의존성을 가지지 않은 순수 Java 및 Kotlin 코드로만 구성됩니다. 참고 : Paging3를 사용 시 Android 의존성을 가지고있지 않을 방법이 없어 위의 그림에서는 어쩔 수 없이 android 의존성을 가졌습니다. UseCase 행동들의 최소 단위, 즉 비즈니스 로직을 구현합니다. 참고 : 사용자를 가져오는 UseCase, Login을 하는 UseCase, Token을 가져오는 UseCase 등이 포함 됩니다. 보통 UseCase 하나당 하나의 기능을 담당합니다. 참고 : UseCase 이름만 보고 이것이 무슨 기능을 하는지 짐작하고 구분할 수 있어야 합니다. Pesentation Layer 에서 어떠한 이벤트나 동작에 의하여 호출되는 방향으로 설계합니다. 참고 : 보통 ViewModel 의 생성자에 DI(Dependency Inject)을 통해 주입받아 사용합니다. UseCase 생성시 어떤 DataBase or Remote(API)를 사용했는지에 대한 고민을 하지 않고 Domain Layer에서 정의한 Repository 함수를 호출하는 방식으로 정의합니다. Data Layer 에서 실제로 어떻게 데이터를 가져올지에 대한 정의는 하지 않고 해당 Repository의 메서드를 호출하는 방식으로 구현합니다. 참고 : 다음은 Naver 검색 API 를 통해 검색 결과를 PagingSource로 가져오는 UseCase 예제입니다. 👇 class GetMovieListPagingDataUseCase @Inject constructor( private val naverRepository: NaverRepository) { operator fun invoke( query: StateFlow&lt;String&gt; ): Flow&lt;PagingData&lt;MovieInfoModel&gt;&gt; { return naverRepository.getMovieList(query) }} Repository 데이터의 출처(Local DB 인지 API 응답인지 등..)와 관계없이 동일 Interface로 데이터에 접속할 수 있도록 만듭니다. UseCase가 필요로 하는 데이터 저장/수정 등의 기능을 제공하는 Interface입니다. Interface에 함수만 정의하고 구현은 Data Layer에서 합니다. 참고 : 다음은 Naver 검색 API 를 통해 검색 결과를 PagingSource로 가져오는 Repository 예제입니다. 👇 interface NaverRepository { fun getMovieList(query: StateFlow&lt;String&gt;): Flow&lt;PagingData&lt;MovieInfoModel&gt;&gt;} Model 앱의 실질적인 데이터가 여기에 구현됩니다. 즉, UI에 보여질 실제 데이터입니다. 참고 : 만약 API 호출을 통해 Response를 받아 왔다면 해당 Response에 직접 접근하지 않고 Domain Layer의 Model을 통해 접근한다고 생각하시면 됩니다. DTO(Data Transfer Object)와 유사하다고 보시면 됩니다. 참고 : 다음은 Naver 검색 API 를 통해 검색 결과의 사용자에게 직접 보여줄 Model 예제입니다. 👇 data class MovieInfoModel( val title: String, val link: String, val image: String, val subtitle: String, val pubDate: String, val director: String, val actor: String, val userRating: Float) { val rating = userRating / 2} 2. Data Layer Domain Layer에서 정의한 Repository 구현제, dataSource, Retrofit API 정의, Room DB 정의, Mapper, API Response Model 등으로 구성됩니다. Domain Layer에 대한 의존성을 가지고 있습니다. 데이터 베이스(Local DB)와 서버(Remote)의 통신을 담당합니다. ✔️ Data Model : API 통신을 통해서 받게되는 Response 나 Local DB를 통해 얻게되는 Entity를 정의합니다. 참고 : 다음은 Naver 검색 API 를 통해 검색 결과 Response 입니다. 👇 data class MovieResponse( @SerializedName(\"lastBuildDate\") val lastBuildDate: String, @SerializedName(\"total\") val total: Int, @SerializedName(\"start\") val start: Int, @SerializedName(\"display\") val display: Int, @SerializedName(\"items\") val items: List&lt;MovieInfo&gt;)data class MovieInfo( @SerializedName(\"title\") val title: String, @SerializedName(\"link\") val link: String, @SerializedName(\"image\") val image: String, @SerializedName(\"subtitle\") val subtitle: String, @SerializedName(\"pubDate\") val pubDate: String, @SerializedName(\"director\") val director: String, @SerializedName(\"actor\") val actor: String, @SerializedName(\"userRating\") val userRating: String) ✔️ DataSource 🚩 RemoteDataSource : 네트워크 통신을 담당하는 interface 입니다. 🚩 LocalDataSource : Local Database와의 통신을 담당하는 interface 입니다. 참고 : 다음은 Naver 검색 API 에 접근하는 RemoteDataSource 입니다. 👇 interface RemoteDataSource { suspend fun requestSearchMovie( query: String, start: Int, display: Int ): Response&lt;MovieResponse&gt;} 참고 : 다음은 Naver 검색 API 에 접근하는 RemoteDataSource의 구현체입니다. Hilt로 부터 생성자에 NaverApiService를 주입받아 사용합니다. 👇 class RemoteDataSourceImpl @Inject constructor( private val naverApiService: NaverApiService) : RemoteDataSource { override suspend fun requestSearchMovie( query: String, start: Int, display: Int ): Response&lt;MovieResponse&gt; { return naverApiService.searchMovie(query, start, display) }} ✔️ Api 🚩 Retrofit 을 이용한 Netwrok 통신을 하기 위한 interface 입니다. 🚩 Url에 접근하는 함수만 만들어 놓고, Retrofit의 인스턴스 생성 및 세팅은 Hilt를 통해합니다. 참고 : GET 방식을 사용하며 Query로 query, start, display를 넣어주고 있습니다. 여기서 start는 아이템 시작 index이며, display는 limit 입니다.다음은 Naver 검색 API URL에 접근하는 코드입니다. 👇 interface NaverApiService { @GET(\"/v1/search/movie\") suspend fun searchMovie( @Query(\"query\") query: String, @Query(\"start\") start: Int, @Query(\"display\") display: Int ): Response&lt;MovieResponse&gt;} ✔️ Repository (Domain Layer의 Repository 구현체) 🚩 DataSource 를 interface 형태로 참조하여 Domain Layer의 Repository를 구현합니다. 참고 : DI(Dependency Inject)을 사용하여 생성자에 DataSource를 주입받습니다. 🚩 실제로 어떻게 데이터를 가져올지에 대한 정의를 하여 UseCase에서 해당 Repository 구현체의 함수를 사용합니다. 참고 : 해당 코드에서는 Paging3를 사용하여 Naver API Response 결과를 Flow&lt;PagingSource&gt; 의 형태로 가져옵니다. 👇 class NaverRepositoryImpl @Inject constructor( private val remoteDataSource: RemoteDataSource) : NaverRepository { override fun getMovieList(query: StateFlow&lt;String&gt;): Flow&lt;PagingData&lt;MovieInfoModel&gt;&gt; { return Pager( config = PagingConfig(pageSize = 10), pagingSourceFactory = { MovieInfoListPagingDataSource( remoteDataSource = remoteDataSource, searchQuery = query, limit = 10 ) } ).flow.distinctUntilChanged().flowOn(Dispatchers.IO) }} ✔️ Mapper 🚩 Data Model 에 의해 가져온 Data를 Domain Model 로 맞게 바꿔주는 매핑 작업을 하여 UseCase 에서 Domain Model 을 반환합니다. 참고 : API 를 통해 받아온 Response를 UI에 맞는 Domain Model로 맵핑 👇 (Kotlin 확장 함수 기능을 사용하여 처리합니다.) object ObjectMapper { // List&lt;MovieInfo&gt; -&gt; List&lt;MovieInfoModel&gt; 로 변환 fun List&lt;MovieInfo&gt;.toMovieInfoListModel(): List&lt;MovieInfoModel&gt; = map { MovieInfoModel( title = it.title, link= it.link, image= it.image, subtitle= it.subtitle, pubDate= it.pubDate, director= it.director, actor= it.actor, userRating= it.userRating.toFloat() ) } // MovieInfo -&gt; MovieInfoModel 로 변환 fun MovieInfo.toMovieInfoModel(): MovieInfoModel = MovieInfoModel( title = this.title, link= this.link, image= this.image, subtitle= this.subtitle, pubDate= this.pubDate, director= this.director, actor= this.actor, userRating= this.userRating.toFloat() )} ✔️ MovieInfoListPagingDataSource 🚩 Naver로 부터 받아오는 Response 의 값을 PagingSource에 담아 반환합니다. 참고 해당 프로젝트는 Paging3를 사용하고 있습니다. Hilt를 사용하여 remoteDataSource 를 생성자에 주입받고 있습니다. 참고 : 해당 포스팅에 Paging3에 관하여 자세히 정리 했습니다. 👉🏿 Paging3에 대하여 class MovieInfoListPagingDataSource @Inject constructor( private val remoteDataSource: RemoteDataSource, private val searchQuery: StateFlow&lt;String&gt;, private val limit: Int) : PagingSource&lt;Int, MovieInfoModel&gt;() { override suspend fun load(params: LoadParams&lt;Int&gt;): LoadResult&lt;Int, MovieInfoModel&gt; { val pageNumber = params.key ?: 1 try { val response = withContext(Dispatchers.IO) { remoteDataSource.requestSearchMovie( query = searchQuery.value, start = pageNumber, display = limit ) } if (response.isSuccessful) { response.body()?.let { val movieList = it.items.toMovieInfoListModel() /** * nextKey -&gt; naver Api의 start 는 index 이고, 현재 display(limit) 가 10 이므로 * 10 이후에 start 값은 11 이 되어야함 * 스크롤되어 페이지가 추가될때 마다 10개씩 가져온다. */ return LoadResult.Page( data = movieList, prevKey = null, nextKey = if (it.items.size &gt;= limit) { pageNumber + limit } else { null } ) } } return LoadResult.Error( LoadException(\"영화 정보를 가져오는데 실패하였습니다.\") ) } catch (e: Exception) { Timber.e(\"paging catch Error -&gt; ${e.message}\") return LoadResult.Error(e) } } override fun getRefreshKey(state: PagingState&lt;Int, MovieInfoModel&gt;): Int? { // 새로고침 될때 항상 전부 새로고침 되도록 null 을 return return null }}3. Presentation Layer (App Module) 화면의 입력에 대한 처리 등 UI와 관련된 부분을 담당합니다. 참고 : Activity, Fragment, View, ViewModel, Di 등을 포함합니다. Android에 높은 의존성을 가지고 있습니다. Domain Layer, Data Layer 에 대한 의존성을 가지고 있습니다. ViewModel에서 domain layer의 UseCase를 주입 받아 사용하여 각 ViewModel당 기능 이 무엇인지 쉽게 알 수 있습니다. MVVM 패턴을 사용하여 ViewModel에서 데이터를 받아 View(Activity/Fragment)에 넘겨주는 방식으로 구현되어 있습니다. 해당 프로젝트는 Single Activity를 적용했습니다. 참고 Single Activity의 장단점 1️⃣ 장점 : Activity Stack에 Activity를 쌓아두기 보다. Fragment BackStack에서 Fragment를 관리하는 것이 메모리 관리에서의 효율도 챙기고 화면 전환시 Activity 보다 순조롭습니다. 2️⃣ 장점 : 데이터 공유에 있어 이점이 있습니다. Activity간 Data를 전달하려면 Intent를 통해 직렬화/역직렬화를 과정을 거쳐야 하며, 이는 메모리 공유에 비해 결코 가벼운 작업이 아닙니다. 3️⃣ 장점 : 재사용성이 증가합니다. View 나 Business Logic을 Fragment 단위로 분리 가능합니다. 이는 아키텍쳐 원칙에서 가장 중요한 원칙인 관심사 분리를 통해 의존성을 분리하고 독립성을 가지게 합니다. 4️⃣ 장점 : 유연한 UI 구현이 가능합니다. (Navigation Component, BottomSheetDialog 등..) 1️⃣ 단점 : 비동기로 인해 예기치 않은 동작이 발생할 수 있습니다. 2️⃣ 단점 : Transaction 내에서 문제가 발생한다면 디버그가 매우 어려운 IllegalStateException을 발생시킵니다. ✔️ Base 🚩 Presentaion Layer의 Base에 사용될 Class 모음입니다. 해당 프로젝트에는 BaseActivity, BaseFragment, BaseViewModel, BaseDialogFragment, MyLoadStateAdapter 가 정의되어 있습니다. 참고 -&gt; 깃허브 ✔️ Di 🚩 DI(Dependency Injection) 즉 의존성을 관리하는 페지키 입니다. 1️⃣ ApiModule : Hilt Module로 관리하며 @InstallIn에 SingletonComponent를 넣어 관리되고 있습니다. SingletonComponent는 @Singleton 어노테이션과 같이 사용되며, Application이 onCreate()가 되면 생성되고, Application이 onDestory()가 되면 자동으로 파괴됩니다. ApiModule 에서는 Retrofit 인스턴스를 만들어 Hilt 를 통해 Provide합니다. 해당 부분에서 OkHttp3 Interceptor 를 사용하여 Header 부분에 X-Naver-Client-Id 와 X-Naver-Client-Secret를 넣어줍니다. Hilt 를 통해 NaverApiService를 제공하고 있으며, 해당 NaverApiService는 RemoteDataSource의 생성자에 주입됩니다. 또한 RemoteDataSource 역시 Hilt를 통해 제공되고 있습니다. (이렇게 제공된 RemoteDataSource는 Hilt를 통해 RepositoryModule의 생성자에서 주입 받습니다.) 다음은 ApiModule 코드 입니다. 👇 깃허브 @Module@InstallIn(SingletonComponent::class)object ApiModule { @Singleton @Provides fun provideRemoteDataSource( naverApiService: NaverApiService ): RemoteDataSource { return RemoteDataSourceImpl( naverApiService ) } @Singleton @Provides fun provideNaverApiService( retrofit: Retrofit ): NaverApiService { return retrofit.create(NaverApiService::class.java) } @Singleton @Provides fun provideRetrofit( client: OkHttpClient, converter: GsonConverterFactory ): Retrofit { return Retrofit.Builder() .baseUrl(BuildConfig.API_HOST) .client(client) .addConverterFactory(converter) .build() } @Singleton @Provides fun provideGsonConverterFactory(): GsonConverterFactory { return GsonConverterFactory.create() } @Singleton @Provides fun provideOkHttpClient( logging: HttpLoggingInterceptor, interceptor: Interceptor, ): OkHttpClient = OkHttpClient.Builder().apply { if (BuildConfig.DEBUG) { addInterceptor(logging) } addInterceptor(interceptor) }.build() @Singleton @Provides fun provideLoggingInterceptor(): HttpLoggingInterceptor = HttpLoggingInterceptor().apply { level = if (BuildConfig.DEBUG) { HttpLoggingInterceptor.Level.BODY } else { HttpLoggingInterceptor.Level.NONE } } @Singleton @Provides fun provideInterceptor(): Interceptor = Interceptor { chain -&gt; val response = chain.proceed( chain.request().newBuilder().apply { addHeader(\"X-Naver-Client-Id\", BuildConfig.NAVE_CLIENT_ID) addHeader(\"X-Naver-Client-Secret\", BuildConfig.NAVE_CLIENT_SECRET) }.build() ) response }} 2️⃣ RepositoryModule : Hilt Module로 관리하며 @InstallIn에 SingletonComponent를 넣어 관리되고 있습니다. SingletonComponent는 @Singleton 어노테이션과 같이 사용되며, Application이 onCreate()가 되면 생성되고, Application이 onDestory()가 되면 자동으로 파괴됩니다. Hilt를 통해 생성자로 부터 RemoteDataSource를 주입받아 사용하고 있으며 NaverRepository를 Hilt를 통해 제공합니다. 다음은 Repository Module Code 입니다. 👇 깃허브 @Module@InstallIn(SingletonComponent::class)object RepositoryModule { @Provides @Singleton fun provideNaverRepository( remoteDataSource: RemoteDataSource ): NaverRepository { return NaverRepositoryImpl(remoteDataSource) }} 3️⃣ UseCaseModule : Hilt Module로 관리하여 @InstallIn 에 ViewModelComponent 를 넣어 관리되고 있습니다. 해당 UseCase는 ViewModel 의 생성자에 주입받아 사용됩니다. 따라서 @InstallIn 에 ViewModelComponent를 사용합니다. ViewModelComponent 는 @ViewModelScope 와 같이 사용되며, AAC ViewModel의 생명주기에 따라 관리됩니다. 즉, ViewModel 이 생성되면 생성되고, ViewModel의 onCleared()가 호출되면 자동으로 파괴됩니다. 다음은 UseCase Module Code 입니다. 👇 깃허브 @Module@InstallIn(ViewModelComponent::class)object UseCaseModule { @Provides @ViewModelScoped fun provideGetMovieListPagingDataUseCase( naverRepository: NaverRepository ): GetMovieListPagingDataUseCase { return GetMovieListPagingDataUseCase(naverRepository) }} ✔️ MovieApplication 🚩 Hilt를 사용하도록 설정하고 Debug에 필요한 Timber를 등록합니다. 참고 : @HiltAndroidApp -&gt; 컴파일 타임 시 표준 컴포넌트 빌딩에 필요한 클래스들을 초기화 해줍니다. Hilt를 사용하는 모든 앱은 @HiltAndroidApp 이 달린 Application 클래스를 반드시 포함해야 합니다. @HiltAndroidAppclass MovieApplication : Application() { override fun onCreate() { super.onCreate() if (BuildConfig.DEBUG) { Timber.plant(TimberDebugTree()) } }} ✔️ Activity 🚩 해당 프로젝트에서는 MainActivity 와 WebViewActivity로 구분됩니다. 1️⃣ MainActivity : 해당 프로젝트는 SingleActivity를 채택하고 있어 MainActivity 에서는 Navigation의 NavHostFragment를 연결해주고 있으며, Network 관리를 통해 Network Callback을 등록하고 Network 상태 값을 Observing 하는 코드가 포함되어 있습니다. 또한 뒤로 가기 클릭 시 한번 눌렀을 경우 “한번 더 누르면 종료됩니다.” 라는 SnackBar를 띄워주기 위해 BackStack을 관리하는 코드가 포함되어 있습니다. 깃허브 2️⃣ WebViewActivity : 영화 상세 정보를 WebView로 띄워주기 위해 생성했습니다. onPause()와 onResume(), onDestory()에 따라 WebView를 관리해주고 있으며, Intent를 통해 Main -&gt; WebView 로 이동 시 내부/외부 WebView를 띄워줄 수 있는 코드가 포함되어 있습니다. 해당 WebViewActivity는 내부 웹뷰 일 경우 동작합니다. 깃허브 ✔️ Fragment 🚩 해당 프로젝트에서는 HomeFragment 와 NetworkFragment로 구분됩니다. 1️⃣ HomeFragment : 네이버 Open API 를 활용하여 영화 정보를 받아와 사용자에게 보여주는 역할을 합니다. 또한 NavHostFragment로 모든 Navgigation의 시작점이 됩니다. 네이버 Open API 를 활용하여 영화 정보를 받아와 사용자에게 보여 주기 위해 RecyclerView 를 포함하고 있으며, 또한 PagingData의 Load 상태에 따라 DataBinding으로 View를 Controll 하고 있습니다. 깃허브 2️⃣ HomeViewModel : 앞서 Domain Layer의 UseCase를 Hilt를 통해 생성자에 주입받아 네이버 Open API 데이터를 가져오는 역할을 합니다. 이렇게 가져온 데이터는 HomeFragment 에서 Observing 하여 RecyclerView 에 넣어줍니다. 또한 MutableStateFlow를 사용하여 Data Binding을 통해 HomeFragment 의 View를 Controll 해주고 있으며, Coroutine Channel 을 통해 해당 Click Event의 Listener를 관리하고 있습니다. 깃허브 3️⃣ NetworkFragment : 네트워크가 끊겼을 때 보여주는 DialogFragment 입니다. 네트워크가 연결되면 자동으로 dialog를 dissmiss 해주는 코드를 포함하고 해당 다이얼로그가 보여질 때 다른 View에서는 해당 다이얼로그를 Cancel 하지 못하게하는 코드가 포함되어 있습니다. 4️⃣ NetworkViewModel : ConnectivityManager를 통해 Network Callback을 받아 Network를 관리하는 코드가 포함되어 있습니다. 해당 ViewModel은 MainActivity에서 생성되며, NetworkFragment 에서는 FragmentX를 사용하여 activityViewModels() 코드로 Fragment 상태를 공유합니다. Network 관리에 대해서는 옆의 포스팅을 참고하시길 바랍니다. 👉 Android ConnectivityManager를 통한 Network 관리 ✔️MovieInfoAdapter(PagingAdapter) RecyclerView 에 데이터를 표시하는 기본 UI 구성요소 입니다. PagingData를 입력 유형으로 사용하고 내부 load 이벤트를 수신합니다. BackGround Thread 에서 DiffUtil 을 사용하여 미세 조정한 후 데이터를 load하므로 UI Thread에 새 항복을 추가하는 동안 문제가 발생하지 않습니다. Root Click Listener를 포함하고 있고 Domain Layer에 정의한 MovieInfoModel을 데이터로 사용합니다. 해당 Adapter 또한 Data Binding을 통해 View에 데이터를 연결해주고 있습니다. 참고 : 깃허브 참고 : 해당 포스팅에 Paging3에 관하여 자세히 정리 했습니다. 👉🏿 Paging3에 대하여 ✔️Utils 🚩 해당 프로젝트에서는 데이터 바인딩을 위한 BindingAdapters, Flow를 Lifecycler에 맞게 Observing하기 위해 만들어진 FlowObserver, keyBoardUtils, Listener, TimberDebugTree 등이 포함되어 있습니다. 1️⃣ BindingAdpaters 깃허브 서버에서 받아오는 image Url을 ImageView에 넣어주기 위해 Glide를 사용하는 함수, Html 을 String으로 바꿔주는 함수, 중복 클릭 방지 함수 등이 포함되어 있습니다. 참고 : 다음은 Glide에 대해 자세한 내용을 기록한 포스팅입니다. 👉🏿 Glide Image 처리 image Load 함수 👇 @BindingAdapter(value = [\"loadImage\", \"placeHolder\", \"error\"], requireAll = false)fun ImageView.loadImage( imageUrl: String, @DrawableRes placeholder: Int = 0, @DrawableRes error: Int = 0,) { // imageUrl 이 비어있을 때 로직 추가 if (imageUrl.isEmpty()) { if (placeholder != 0) { this.setImageResource(placeholder) } return } val options = RequestOptions() @SuppressLint(\"CheckResult\") if (error != 0) { // 로드가 실패할 경우 표시할 리소스를 설정합니다. options.error(error) } Glide.with(this.context) .setDefaultRequestOptions(options) .load(imageUrl).apply { @SuppressLint(\"CheckResult\") if (placeholder != 0) { // 리소스가 로드되는 동안 표시할 드로어블 리소스의 Android 리소스 ID를 설정합니다. apply(options.placeholder(placeholder)) } } .into(object : CustomTarget&lt;Drawable&gt;() { override fun onResourceReady(resource: Drawable, transition: Transition&lt;in Drawable&gt;?) { setImageDrawable(resource) } override fun onLoadCleared(placeholder: Drawable?) { setImageDrawable(placeholder) } })} 중복 클릭 방지 함수 @BindingAdapter(value = [\"onSingleClick\", \"interval\"], requireAll = false)fun View.onSingleClick(listener: View.OnClickListener? = null, interval: Long? = null) { if (listener != null) { setOnClickListener(object : Listener.OnSingleClickListener(interval ?: 1000L) { override fun onSingleClick(v: View?) { listener.onClick(v) } }) } else { setOnClickListener(null) }} Html을 String으로 바꿔주는 함수 @BindingAdapter(\"htmlToString\")fun TextView.htmlToString(text: String) { this.text = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY).toString() } else { @Suppress(\"DEPRECATION\") Html.fromHtml(text).toString() }} 2️⃣ FlowObserver : Flow를 Activity/Fragment 의 Lifecycler에 맞게 Observing 하기위해 만든 클래스 입니다. 깃허브 해당 포스팅에 FlowObserver에 관하여 자세히 설명했습니다. 👉🏿 StateFlow, Channel// FlowObserver -&gt; lifecycle 이 onStart가 되면 구독 시작, onStop이 되면 구독 취소class FlowObserverInStop&lt;T&gt;( lifecycleOwner: LifecycleOwner, private val flow: Flow&lt;T&gt;, private val collector: suspend (T) -&gt; Unit) { private var job: Job? = null init { lifecycleOwner.lifecycle.addObserver(LifecycleEventObserver { source, event -&gt; when (event) { Lifecycle.Event.ON_START -&gt; { job = source.lifecycleScope.launch { flow.collect { collector(it) } } } Lifecycle.Event.ON_STOP -&gt; { job?.cancel() job = null } else -&gt; {} } }) }}inline fun &lt;reified T&gt; Flow&lt;T&gt;.observeOnLifecycleStop( lifecycleOwner: LifecycleOwner, noinline collector: suspend (T) -&gt; Unit) = FlowObserverInStop(lifecycleOwner, this, collector)// .onEach{ } 사용할때 사용inline fun &lt;reified T&gt; Flow&lt;T&gt;.observeInLifecycleStop( lifecycleOwner: LifecycleOwner) = FlowObserverInStop(lifecycleOwner, this) {} 3️⃣ Listener : 중복 클릭 방지를 위해 사용됩니다. 깃허브 class Listener { abstract class OnSingleClickListener(private val minIntervalMS: Long = 1000L) : View.OnClickListener { // 마지막으로 클릭한 시간 private var mLastClickTime: Long = 0 abstract fun onSingleClick(v: View?) override fun onClick(v: View?) { //현재 클릭한 시간 val currentClickTime = SystemClock.uptimeMillis() // 이전에 클릭한 시간과 현재시간의 차이 val elapsedTime = currentClickTime - mLastClickTime // 마지막클릭시간 업데이트 mLastClickTime = currentClickTime // 내가 정한 중복클릭시간 차이를 안넘었으면 클릭이벤트 발생못하게 return if (elapsedTime &lt;= minIntervalMS) return // 중복클릭시간 아니면 이벤트 발생 onSingleClick(v) } }} 4️⃣ KeyboardUtils : 해당 프로젝트에서는 Keyboard가 보이지 않을때 Focus를 해제하기 위해 사용됩니다. 깃허브 OnGlobalLayoutListener 을 사용하여 View 의 전체 영역이 바뀔때 Event를 받아 사용합니다. 주의 : windowSoftInputMode 에 adjustNothing 을 사용하면 View 의 변경을 알 수 없어 Listener 가 동작하지 않습니다. 마치며해당 포스팅는 Naver Open API를 사용하여 영화를 검색하고 검색한 영화를 사용자에게 보여주는 앱에 대하여 사용 기술에 대한 설명에 초점에 두고 작성하였습니다.최대한 주어진 주제에 벗어나지 않는 선에서 제가 사용할 수 있는 기술을들 적용해 보았습니다.긴 글 읽어주셔서 감사합니다.프로젝트 전체 코드" }, { "title": "Android Coroutine Flow", "url": "/posts/Android-Coroutine-Flow/", "categories": "Android, Coroutine", "tags": "android, coroutine, flow", "date": "2022-07-18 15:28:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.오늘은 Kotlin Coroutines Flow에 대하여 알아보도록 하겠습니다.suspend 함수는 비동기로 단일 값을 리턴합니다 .Flow는 비동기로 계산된 여러값을 리턴 합니다. 연속적으로 값을 가져와야하는 상황(시시각각 변화하는 온도를 가져올 때)에서 주로 사용합니다. 즉, 비동기로 계산된 값을 실시간으로 나타낼 수 있습니다.🍀 Flow Coroutine의 Flow는 Data Stream이며, Coroutine 상에서 Reactive Programming을 지원하기 위한 구성요소입니다. 참고 👇 Reactive Programming(반응형 프로그래밍) : Data가 변경 될 때 이벤트를 발생시켜 데이터를 계속해서 전달하도록 하는 프로그래밍 방식 입니다. Clod Stream 형식으로, 외부에서 설정하는 데이터가 아닌 생성 시 해당 데이터를 정의해야 합니다. 또한 단 한명의 구독자가 존재 하며, 데이터 발생 시점의 주체가 구독자 입니다. flow {} 를 통해 빌드합니다. 코드 내부가 일시 중단 될 수 있으며, collect{}가 호출될 때까지 코드가 실행되지 않습니다. suspend 수정자를 붙히지 않아도 됩니다. flow는 자체적으로 취소할 수 없습니다. emit()을 통해 값을 내보내고, Coroutine Builder 내에서 collect {} 를 통하여 값을 받습니다. flow {} 빌더의 코드는 Context Preservation(컨텍스트 보존) 특성을 준수해야 하며, 다른 Context에서 emit 할 수 없습니다. 즉 withContext를 사용하지 못합니다. flowOf() : 고정 값을 외부로 보내는 flow 입니다. 예제 👇 fun main() = runBlocking { sendNumbers().collect { Timber.e(\"Received $it\") }}// Flow 생성fun sendNumbers() = flowOf(\"ONE\", \"TWO\", \"THREE\") asFlow() 변수의 Collection, 시퀸스를 변경할 수 있습니다. Collection을 flow로 직접 변환하며 emit()을 할 필요가 없습니다. suspend 함수나 Coroutine Builder 안에서 사용합니다. 예제 👇 fun main() = runBlocking&lt;Unit&gt; { (1..3).asFlow().collect { response: Int -&gt; Timber.e(\"response -&gt; $response\") }} ❗️단점 Flow는 스스로 Android의 Lifecycle에 대하여 알지 못해 Lifecyle에 따른 중지나 재개가 어려움 Flow는 상태가 없어 값이 할당된 것인지, 현재 값은 무엇인지 알기 어려움 Flow는 Cold Stream 방식으로, 연속해서 계속 들어오는 데이터를 처리할 수 없으며, Collect 되었을 때만 생성되고 값을 반환함 ✅ 즉, 하나의 flow builder에 대하여 다수의 collector가 있으면 collector하나마다 하나씩 데이터를 호출 하기 때문에 UpStream이 비싼 비용을 요구하는 DB접근이나 서버통신 등이라면 여러번 리소스 요청을 하게 될 수 있음 🍀 Flow Operator 입력 Flow를 가져와서 변환 하고 출력 Flow를 반환 하는 동기 Flow입니다. Collect {} 함수를 호출하지 않으면 실행되지 않습니다.☘️ 1. transform transform{} 을 통해 여러개의 값을 매핑 (하나의 값을 다른 값으로 대응 시키는 것)시켜 전달할 수 있습니다. take() : 리스트의 갯수를 제한 합니다. 첫 번째부터 지정된 Count의 수 만큼의 요소를 포함하는 Flow를 반환합니다. 다음은 예제 코드 입니다. 👇 fun main() = runBlocking&lt;Unit&gt; { (1..3).asFlow() .take(2) .transform { request: Int -&gt; emit(\"Making request -&gt; $request\") emit(performRequest(request)) } .collect { response: String -&gt; Timber.e(\"Response -&gt; $response\") }}suspend fun performRequest(request: Int): String { delay(1000) return \"response -&gt; $request\"} 결과 -&gt; Making request 1, response 1, Making request 2, response 2 ☘️ 2. flowOn flow{} 빌더의 코드는 다른 Context에서 emit() 사용은 불가합니다. 즉, flow{} 안에서 withContext 를 사용하여 다른 Thread로 바꿀 수 없습니다.이럴 때 사용하는 것이 flowOn 입니다. flow {} 빌더 코드를 다른 Thread에서 emit() 시키고 싶을 때 즉, Flow가 방출되는 Context를 전환할 때 flowOn() 함수를 사용합니다. 다음은 예제 코드 입니다. 👇 fun main() = runBlocking&lt;Unit&gt; { foo().collect { value: Int -&gt; // 기본 Thread 즉 MainThread에서 실행됩니다. Timber.e(\"[${Thread.currentThread().name} Collected : $value]\") }}private fun foo(): Flow&lt;Int&gt; = flow { for (i in 1..3) { delay(1000) Timber.e(\"[${Thread.currentThread().name} Emitting : $i]\") emit(i) }}.flowOn(Dispatchers.Default) 결과 [DefaultDispatcher-worker-1 Emitting : 1] [main Collected : 1] [DefaultDispatcher-worker-1 Emitting : 2] [main Collected : 2] [DefaultDispatcher-worker-1 Emitting : 3] [main Collected : 3] Main Thread에서 Collect 되는 동안 foo() 함수에서는 다른 Thread에서 진행됩니다. ☘️ 3. buffer flow {} 가 구현된 함수를 호출할 때 속도를 빠르게 할 수 있습니다. Flow 처리에 오랜 시간이 걸리는 경우 buffer()는 나중에 처리할 수 있는 Flow값을 축적 하는데 유용합니다. 다음은 예제 코드 입니다. 👇 fun main() = runBlocking { val time = measureTimeMillis { generate().buffer().collect { it: Int delay(300L) Timber.e(\"collect -&gt; $it\") } } Timber.e(\"Collect in $time ms\")}fun generate() = flow { for (i in 1..3) { delay(100L) emit(i) }} 결과 : buffer 사용 = 약 1,000 ms, buffer 사용 x = 약 1,250 ms ☘️ 4. map map 을 이용한 Mapping 예제입니다. 문자열에 매핑 합니다.fun main() { runBlocking{ mapOperator() } }suspend fun mapOperator() { (1..10).asFlow().map { it: Int delay(500L) \"mapping $it\" }.collect { it: String Timber.e(\"mapped values -&gt; $it\") }}☘️ 5. Filter filter 를 이용한 예제 입니다. 2의 배수만 출력 하겠습니다.(짝수 만 출력)fun main() { runBlocking{ filterOpertaor() } }suspend fun filterOperator() { (1..10).asFlow().filter { it: Int it%2 == 0 }.collect { it: Int Timber.e(\"filtered value -&gt; $it\") }}☘️ 6. zip 2개의 Flow를 결합하여 하나의 Flow로 만듭니다. 2개의 Flow를 결합시켜 각 값을 다른 flow의 해당 값과 일치시킵니다. 예제 👇 fun main() { runBlocking&lt;Unit&gt; { val nums: Flow&lt;Int&gt; = (1..3).asFlow() val strs: Flow&lt;String&gt; flowOf(\"one\",\"two\") nums.zip(strs) { t1: Int, t2: String -&gt; \"$t1 -&gt; $t2\" }.collect { it: String Timber.e(\"response -&gt; $it\") } }} 결과 1 -&gt; one, 2 -&gt; two nums 와 strs 의 사이즈가 다르기 때문에 사이즈가 작은 strs 를 기준으로 출력됩니다. 즉, nums 의 3은 삭제됩니다. ☘️ 7. flatternConcat, flatMapConcat, flatMapMerge return 타입이 Flow&lt;Flow&lt;T&gt;&gt; 일때 이 타입을 Flow&lt;T&gt; 로 만들 수 있는 flattern(평탄화) 작업이 필요합니다. 이때 사용하는 것이 flatternConcat, flatMapConcat, flatMapMerge 입니다. 예제 👇 fun requestFlow(i: Int): Flow&lt;String&gt; = flow { emit(\"$i : first\") delay(500) emit(\"$i : second\")} 다음은 flattenConcat() 사용 예제 입니다. 👇 fun main() = runBlocking&lt;Unit&gt; { val beforeFlattening: Flow&lt;Flow&lt;String&gt;&gt; = (1..3).asFlow().onEach { delay(1000) }.map { requestFlow(it) } val flatten: Flow&lt;String&gt; = beforeFlattening.flattenConcat() flatten.collect { Timber.e(\"flatten response -&gt; $it\") }} 결과 👇 1 : first 1 : second 2 : first 2 : second 3 : first 3 : second 다음은 flatMapConcat 사용 예제 입니다. 👇 fun main() = runBlocking&lt;Unit&gt; { (1..3).asFlow().onEach { elay(1000) }.flatMapConcat { requestFlow(it) }.collect { Timber.e(\"flatten response : $it\") }} 결과 👇 1 : first 1 : second 2 : first 2 : second 3 : first 3 : second 다음은 flatMapMerge 를 사용한 예제 입니다.(flatMapMerge는 들어오는 Flow를 동시에 실행시켜 단일 Flow로 가능한 빨리 값을 전달 합니다.) 👇 fun main() = runBlocking&lt;Unit&gt; { (1..3).asFlow().onEach { elay(1000) }.flatMapMerge { requestFlow(it) }.collect { Timber.e(\"flatten response : $it\") }} 결과 👇 1 : first 2 : first 3 : first 1 : second 2 : second 3 : second ☘️ 8. Combine 한 Flow의 최신 값을 다른 Flow의 최신 값과 결합 합니다. Combine() 연산자의 출력은 기본적으로 모든 단일 Flow의 최신값 입니다. 에제 👇 fun main() = runBlocking&lt;Unit&gt; { combine()}private suspend fun combine() { val numbers = (1..5).asFlow().onEach { delay(300L) } val values = flowOf(\"One\", \"Two\", \"Three\", \"Four\", \"Five\").onEach { delay(400L) } numbers.combine(values) { a: Int, b: String -&gt; \"$a -&gt; $b\" }.collect { it: String Timber.e(\"combine response -&gt; $it\") }} 결과 👇 1 -&gt; One 2 -&gt; One 2 -&gt; Two 3 -&gt; Two 4 -&gt; Two 4 -&gt; Three 5 -&gt; Three 5 -&gt; Four 5 -&gt; Five combine() 대신 zip()을 사용했을 경우 👇 1 -&gt; One 2 -&gt; Two 3 -&gt; Three 4 -&gt; Four 5 -&gt; Five ☘️ 9. Exception handler Flow try / catch로 둘러 싸기, emit() 과 collect{}를 모두 try/catch 문으로 둘러싸서 지금 발생하는 모든 Exception을 표착합니다. catch {} : 예외 Operator, collect{}를 하기전에 사용 하며, catch {} 이후에 다른 Exception이 발생하면 예외 처리가 불가합니다. onCompletion {} : catch{} 연산자와 같이 사용 합니다. Flow의 성공 실패 여부 를 담당하며 finally {} 구문과 비슷합니다. 1️⃣ 다음은 try / catch 문을 사용한 예제입니다. 👇 fun main() { runBlocking { tryCatch() }}private suspend fun tryCatch() { try { (1..3).asFlow().onEach { check(it != 2) // 값이 false이면 IllegalStateException을 던집니다. check는 onEach에서 사용하셔야 합니다. }.collect { it: Int Timber.e(\"response -&gt; $it\") } } catch (e: Exception) { Timber.e(\"caught exception -&gt; $e\") }} 2️⃣ 다음은 catch {} 을 사용한 예제입니다. 👇 fun main() { runBlocking { catched() }}private suspend fun catched() { (1..3).asFlow().onEach { check(it != 2) // 값이 false이면 IllegalStateException을 던집니다. check는 onEach에서 사용하셔야 합니다. }.catch { e: Throwable -&gt; Timber.e(\"Caught exception -&gt; $e\") }.collect { it: Int Timber.e(\"response -&gt; $it\") }} 3️⃣ 다음은 onCompletion {} + catch {} 를 사용한 예제입니다. 👇 fun main() { runBlocking { onCompletion() }}private suspend fun onCompletion() { (1..3).asFlow().onEach { check(it != 2) // 값이 false이면 IllegalStateException을 던집니다. check는 onEach에서 사용하셔야 합니다. }.onCompletion { cause: Throwable? -&gt; if (cause != null) { // TODO: 실패 처리 Timber.e(\"실패\") } else { // TODO: 성공 처리 Timber.e(\"성공\") } }.catch { e: Throwable -&gt; Timber.e(\"Caught exception -&gt; $e\") }.collect { it: Int Timber.e(\"response -&gt; $it\") }} 결과 👇 response -&gt; 1 실패 Caught exception -&gt; java.lang.IllegalStateException: Check failed. 처음 1은 2와 다름 따라서 IllegalStateException 발생 이후의 값은 실행되지 않음 🍀 마치며이번 포스팅에서는 Coroutine Flow 와 Flow Operator 에 대하여 알아보았습니다.저는 실무에서 map 은 자주 사용중이나 나머지 부분은 잘 사용하지 않습니다.Coroutin Flow는 emit 을 통해 값을 보내며 collect를 통해 값을 전달받고 또한 Coroutine Flow는 Cold Stream이기에 값을 공유할 수 없다. 정도만 기억해주시면 되겠습니다.Cold Stream 이기에 값을 공유할 수 없다는 말의 의미는 예를 들어 하나의 flow를 2개의 activity나 fragment에서 각각 collect 할때 flow 의 값이 서로 다를 수 있다는 이야기 입니다.다음 포스팅에서는 이런 문제를 해결하기 위해 나온 Hot Stream 인 SharedFlow, StateFlow, 또한 나아가 Coroutine Channel 에 대하여 알아보겠습니다.StateFlow, SharedFlow, Coroutine Cannel에 대하여" }, { "title": "Android Coroutine", "url": "/posts/Android-Coroutine/", "categories": "Android, Coroutine", "tags": "android, coroutine", "date": "2022-07-18 15:12:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번시간에는 Kotlin Coroutines Flow에 대하여 알아보기 전 Coroutine에 대하여 알아보고자 합니다.우선 Coroutine에 대하여 알기전에 동기, 비동기에 대하여 아셔야합니다.간단하게 설명 드리면동기 👉 순차적으로 작업을 처리하는 모델( 어떤 작업이 처리 중이면 다음 작업은 대기 )을 의미합니다.비동기 👉 병렬적으로 작업을 처리하며, 어떤 작업을 처리중 이더라도 처리 될때까지 기다리지 않고 즉시 다음 작업을 처리 합니다.(작업이 종료되는 시점에 처리 결과를 받습니다.)이제 Coroutine에 대하여 알아보도록 하겠습니다.🍀 Coroutine 비동기 라이브러리 입니다. 경량 Thread : Thread간 Context 전환 비용이 발생하지 않으며, 개발자가 직접 중지 시점을 선택 가능하고 Thread를 재사용 가능합니다. ✅ 참고 suspend 함수를 호출하는 시점에 현재 실행중인 Coroutine 은 잠시 중단되며, 그 때 남게되는 Thread는 다른 Coroutine에 할당될 수 있으며 suspend 함수의 로직이 끝났을 때에 중단되었던 Coroutine은 다시 실행됩니다. ✅ 즉, 비동기 작업을 수행하면서 중지 상태일 때 Thread를 블로킹하지 않고 그 Thread를 재사용 특징 : CoroutinScope Context의 launch 빌더를 통하여 실행될 수 있으며, 이 빌더 블록안의 코드는 Thread처럼 비동기로 실행 됩니다. Coroutine은 비동기 작업을 수행하면서 중지 상태일 때 Thread를 블로킹하지 않고 그 Thread를 재사용 할 수 있기 때문에 더욱 효율적이고 빠르게 동작할 수 있습니다.🍀 suspend point Coroutine 을 사용하시려면 suspend 함수에 대하여 알아야 합니다. 현재 실행중인 작업을 중지하고 다른 작업을 수행시키는 함수 입니다. Coroutine이 사용중인 Thread를 블로킹하지 않으면서 실행중인 Coroutine을 잠시 중단 시킬 수 있는 중단 지점 함수 입니다. suspend 함수를 호출하는 시점에 현재 실행중인 Coroutine 은 잠시 중단되며, 그 때 남게되는 Thread는 다른 Coroutine에 할당될 수 있으며 suspend 함수의 로직이 끝났을 때에 중단되었던 Coroutine은 다시 실행됩니다. suspend 함수는 Coroutine 내부에서 실행되거나 suspend 함수 내부에서 실행되어야 합니다. suspend 함수 호출 또한 다른 Coroutine에서 일어나거나 suspend함수 내부에서 호출되어야 합니다. ✅ 즉, suspend 함수를 호출하기 위해서는 최소 하나의 Coroutine Builder 블록이 필요하게 됩니다. 예제 ) 간단한 코드를 통해 알아보기 👇 runBlocking { launch { uniFuction() } } suspend fun somNetworkCall(): String { delay(1000) return \"data from network\" } suspend fun uniFuction() { val data = somNetworkCall() println(data) println(\"uniFuction is done\") } 결과 👇 “data from network” “uniFuction is done” 👍 해설 : uniFuction() 함수를 Coroutine으로 호출하게 되면 내부적으로 somNetworkCall() 호출이 일어나게 되고, 이 지점에서 실행되고 있던 unifuction() 함수는 someNetworkCall() 함수의 호출이 끝날 때 까지 대기하다가 somNetwork() 함수 호출이 끝나면 다시 실행 됩니다. ✅ 즉, uiFuction()을 실행하고 있는 Thread는 대기하는 것이 아니라 다른 Coroutine에 할당될 수 있는 상태 가 된다. 🍀 Coroutine Scope☘️ 1. GlobalScope 앱의 시작부터 종료까지 장시간 실행되어야 할 필요가 있을 경우 사용합니다. Application의 Lifecycle과 함께 동작 합니다.(앱이 실행되는 동안에는 별도의 생명주기가 필요없습니다.) 즉, 앱 Process의 Lifecycle을 따라갑니다.☘️ 2. CoroutineScope 작업 필요할 때만 실행하고 완료되면 종료 됩니다. Coroutine의 기본 Scope로 다른 Scope는 Coroutine Scope를 상속 받아 처리하고 있습니다. ✅ 참고 : 주로 버튼을 클릭해서 서버의 정보를 가져오거나 파일을 열때 사용 합니다. ☘️ 3. MainScope UI 관련 작업 을 처리하는 용도로 사용합니다. 이 Scope 안에서 만들어진 모든 Coroutine 을 Main Thread에서 실행 합니다.☘️ 4. coroutineScope (소문자) 반환전에 제공되는 자식 범위 내의 모든 작업의 완료를 보장합니다. 구조화된 동기성, suspend 함수가 반환되기 전에 자식 범위 내에서 Coroutine에 의해 시작된 모든 작업을 완료하도록 보장 합니다. 즉, coroutineScope 블록안의 suspend 함수가 완료 되면 반환합니다.☘️ 5. viewModelScope ViewModel 에 연결된 Coroutine Scope 입니다. ViewModel이 활성화된 상태인 경우에만 실행해야 할 작업이 있을 경우 사용합니다. 이 범위에서 시작되는 모든 Coroutine은 ViewModel 이 삭제되면 자동으로 취소 됩니다.(onCleared()가 호출되면 자동으로 취소됨) 즉, 수동으로 onCleared()에서 Job Cancel을 할 필요가 없습니다.☘️ 6. lifecycleScope Activity/Fragment 의 lifecycle 에 연결된 Coroutine Scope 입니다. 이 범위에서 시작된 모든 Coroutine 은 Lifecycle이 파괴되면 자동으로 취소 됩니다. Activity/Fragment 와 같은 수명주기가 있는 객체에 Coroutine을 만들 때 사용합니다.☘️ 7. LiveData + Coroutine (LiveData Builder) LiveData를 사용할 때 값을 비동기적으로 계산해야 할 때 사용 합니다. 사용자의 환경 설정을 검색하여 UI에 제공할 때 이런 경우 liveData { } 를 사용해 suspend 함수를 호출하여 결과를 LiveData 객체로 제공(emit) 합니다. emit() 을 통해 결과를 내보냅니다. LiveData가 활성화되면 실행을 시작하고 LiveData가 비활성화가 되면 구성 가능한 제한 시간 후 자동으로 취소 됩니다. 간단한 코드를 통해 알아보기 👇 val isMobileDataOk: LiveData&lt;Boolean&gt; = liveData { // LiveData Builder 입니다. dataStore.getUserMobileData.collect { // DataStore에 저장된 값 가져오기 emit(it) // 결과를 LiveData에 보내기 }} 🍀 Coroutine Builder☘️ 1. runBlocking 현재 Thread를 블록킹하는 Coroutine Builder 입니다. ✅ 참고 블록킹 👉 주어진 블록이 완료될때 까지 현재 Thread를 멈춤 일반 함수 내에서 suspend 함수를 호출하기 위해 사용할 수 있는 가장 단순한 형태의 Coroutine Builder 입니다. 내부 suspend 함수들도 모두 현재 Thread를 블로킹 하게 됩니다. 주로 Test시 Top Level 함수로 사용 되며, 주어진 블록이 완료될때 까지 현재 Thread를 멈추는 새로운 Coroutine을 생성하여 실행 하는 Coroutine Builder 입니다. 잘 사용하지 않으나 Test 코드를 짤때 주로 사용합니다. ❗️주의❗️ 실무에서는 잘 사용하지 않습니다. 그 이유는 Context가 Main Thread일 때 runBlocking 을 넣으면 오류를 유발할 수 있습니다. 여기서 오류란 Main Thread를 장기간 블럭킹 하여 ANR 을 유발할 수 있습니다. 따라서 runBlocking 은 Unit Test에서 주로 사용 합니다. ☘️ 2. launch 가장 많이 사용하는 Coroutine Builder 입니다. 현재 Thread를 블록킹 하지 않고 새로운 비동기 작업을 시작 합니다. Coroutine이 시작되었다는 의미의 Job 객체를 반환 합니다. Job 객체는 Coroutine의 종료를 기다리거나 취소를 기다리기 위해서 사용 됩니다. Job 의 isCancelled 프로퍼티를 이용하여 작업이 성공인지, 실패인지 확인할 수 있습니다. 결과 값을 반환받을 수 없기 때문에 파이어 앤드 포켓 방식의 UseCase에서 많이 사용합니다. ⚠️주의⚠️ 예외가 전파되지 않기 때문에 블록 내부에서 CoroutineExceptionHandler 와 함께 try-catch 가 필요할 수 있습니다. CoroutineExceptionHandler 를 사용한 Sample Code 입니다. 👇 fun main() = runBlocking { val handler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; println(\"Caught:${coroutineContext[CoroutineName]}, ${throwable.message?.substring(0..28)}\") } try { val airportCodes = listOf(\"LAX\", \"SF-\", \"PD-\", \"SEA\") val jobs: List&lt;Job&gt; = airportCodes.map { onAirportCode -&gt; // SupervisorJob -&gt; 단 방향 취소가 가능하게 만들어줍니다. (부모에서 자식으로만 단방향으로 취소가 가능하게 만들어줍니다.) launch(Dispatchers.IO + CoroutineName(onAirportCode) + handler + SupervisorJob()) { val airport = Airport.getAirportData(onAirportCode) // Network 요청 println(\"${airport.code}\") } } jobs.forEach { it.join() } jobs.forEach { println(\"cancelled : ${it.isCancelled}\") } } catch (e:Exception) { println(\"ERROR: ${e.message}\") }} ☘️ 3. async 현재 Thread를 블록킹하지 않고 새로운 비동기 작업을 시작 합니다. Deferred&lt;T&gt; 타입의 객체를 반환 하며 await()를 호출하여 결과 값을 반환 받을 수 있습니다. await()는 susepnd 함수 이기에 Coroutine 내부나 또 다른 susepnd 함수 내부에서 호출되어야 합니다. 참고 👉 예외가 전파되기 때문에 블록 외부에서 try-catch 가 가능합니다. ☘️ 4. withContext 현재 Thread를 블록킹하지 않고 새로운 Coroutine을 실행 할 수 있습니다. async 처럼 결과값을 반환하는 빌더 입니다. async는 반환하는 Deferred&lt;T&gt; 객체로 결과값을 원하는 시점에 await()함수를 통해 결과값을 얻지만, withContext()는 Deferred&lt;T&gt;객체로 반환하지 않고, 결과(T)를 그 자리에서 반납 합니다. 코드의 한 부분을 Coroutine의 다른 코드들과 완전히 다른 Context에서 실행할 수 있습니다.(Coroutine을 한 Context에서 실행하다가 중간에 Context를 바꾸고 싶을 때 사용 합니다.)🍀 Coroutine Context☘️ 1. Dispatchers.Default Coroutine에게 DefaultDispatchers 풀(pool)의 Thread 안에서 실행을 시작하라고 지시합니다. 풀(Pool) 안의 Thread 숫자는 2개 이거나 시스템의 코어 숫자 중 높은 것 을 사용합니다. 계산한 일이 많은 작업을 위한 풀(Pool) 입니다. (cpu 에서 처리하는 대부분의 작업들에 사용합니다.) 참고 👉 데이터 처리, 이미지 처리 등에 사용합니다. ☘️ 2. Dispatchers.IO IO 작업 실행을 위한 풀(Pool)안에 Coroutine을 실행시키는 데 사용됩니다. Local, Network 에서 데이터를 읽을 때 사용 합니다. 참고 👉 네트워크 작업, 이미지 다운로드, 파일 입출력 등의 입출력에 최적화 되어 있습니다. ❗️주의❗️ 👉 IO에서 UI 변경 시 IOException 이 발생 하므로 UI 변경은 Main Thread에서만 하셔야 합니다. ☘️ 3. Dispatchers.Main Main Thread 에서만 사용되는 UI 업데이트 기능이 필요할 때 사용 합니다. Android Main Thread UI 작업에 주로 사용됩니다. 참고 👉 항상 Main Thread로 Coroutine을 시작한 다음 Background Thread로 전환하는 것 이 좋습니다. ☘️ 4. Custom Pool 에서 실행 시키기 풀(Pool)안에 Thread가 있기 때문에 이 Context를 사용하는 Coroutine은 병렬 진행이 아닌 동시 진행으로 진행됩니다. 작업을 Coroutine으로 진행시킬 때 작업들 간에 자원 경쟁에 대해서 고려할 때 사용 합니다. 예제 ) Single Thread 생성자 만들기 👇 Executors.newSingleThreadExecutor() 실행자로 부터 CoroutineContext 가져오기 👇 (.asCoroutineDispatcher() 확장함수 사용) Executors.newSingleThreadExecutor().asCoroutineDispatcher().use { context -&gt; runBlocking { // launch 에 context를 전달하면 해당 블럭에서 실행되는 Coroutine은 Single Thread Pool에서 동작합니다. launch(context) { // TODO: Coroutine 에서 실행할 함수 및 동작 } }} ❗️주의❗️ 실행자를 닫지 않으면 프로그램이 영원히 멈추지 않습니다. 그 이유는 실행자의 풀(Pool)에는 Main Thread 외에도 Active Thraed가 있고, Active Thread가 JVM 을 계속 살려두게 되기 때문입니다. ✅ 해결 위의 상황을 해결하기 위해 .use{context -&gt; }를 사용합니다. 예제 👇 다음은 Multi Thread 를 가지는 풀(Pool) 사용 코드 입니다. 즉 시스템 코어의 숫자 만큼 Thread를 이용하고 싶을 때 사용합니다. Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()) .asCoroutineDispatcher().use { context -&gt; runBlocking { launch(context) { // TODO: Coroutine 에서 실행할 함수 및 동작 } } } ✅ 참고 👉 이 context를 사용하는 Coroutine은 코드가 동작하는 시스템의 코어 숫자와 동일한 Thread 숫자를 가지는 커스텀 Pool에서 실행 됩니다. 🍀 Mutex (상호배제) 상호 배제 👉 한번에 하나 의 Coroutine만 코드 블럭을 실행할 수 있도록 하는 동기화 메커니즘 입니다. ✅ 즉, 모든 공유되는 상태의 변경들이 절대 동시 실행되지 않도록 합니다. 동시에 실행되면 안되는 부분 을 lock()/unlock() 으로 보호합니다. (List의 값을 변경하는 부분에 사용될 수 있습니다.) 해당 Thread는 Block의 작업이 다 처리될 때 까지 다른 작업을 수행할 수 없습니다. (차단 역할) 예제 👇 private val mutex = Mutex()private suspend fun test() { mutex.withLock { // TODO: something.. }} 🍀 마무리이번 포스팅에서는 Coroutine의 기본 개념에 대하여 알아보았습니다. Coroutine을 사용하면 매우 간결하게 비동기 처리 가 됩니다.Coroutine 은 경량 Thread로 비동기 작업을 수행하면서 중지 상태일 때 Thread를 블로킹하지 않고 그 Thread를 재사용 할 수 있기 때문에 더욱 효율적이고 빠르게 동작할 수 있습니다.다음 포스팅에서는 Coroutine Flow에 대하여 알아보도록 하겠습니다." }, { "title": "Android ConnectivityManager를 통한 Network 관리", "url": "/posts/Android-Network/", "categories": "Android, Network", "tags": "android, network, connectivity manager", "date": "2022-07-18 09:08:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.오늘은 Android Network 관리에 대하여 알아보도록 하겠습니다.실전 코드를 통하여 알아볼 것 이고 AndroidViewModel 를 사용하며 activityX 의 viewModels와 fragmentX activityViewModels를 통하여 Fragment의 상태를 공유하여 처리하는 코드입니다.Android에서는 ConnectivityManager를 통하여 연결 상태를 확인할 수 있습니다.Android에서는 셀룰러, 와이파이, 일반 네트워크(Default Network)가 존재하는데 기본으로 사용할 네트워크는 시스템에서 결정합니다.아래에서 코드를 통해 알아보겠습니다.1. AndroidViewModel 을 사용한 Network 관리Hilt + DataStore 를 기본으로 사용하겠습니다.DataStore은 셀룰러 on/off 유무를 저장하기 위해 사용하였으며, Hilt는 DataStore를 ViewModel의 생성자에 주입받기 위해 사용합니다.DataStore에 대하여 잘 모르시면 해당 링크를 참고하시길 권장 드립니다. -&gt; DataStore 정리@HiltViewModel // Hilt를 ViewModel에서 사용할 때는 해당 어노테이션을 달아주셔야 합니다.class NetworkViewModel @Inject constructor( application: Application, private val dataStore: DataStoreModule) : AndroidViewModel(application) { // 해당 Enum Class를 바탕으로 DataBinding을 통해 UI 를 Controll 합니다. enum class NetworkStatus : EnumClassProguard { CONNECT_ERROR, CONNECT_NETWORK, DISCONNECT_NETWORK, CONNECT_NETWORK_BUT_NOT_USE_MOBILE_DATA } private var manager: ConnectivityManager? = null // Network가 연결 되었는지 유무 private var isNetworkConn = false // Wifi 연결 유무 private var isWifiConn = false // Cellular 연결 유무 private var isCellularConn = false // 현재 네트워크 상태를 담고있는 LiveData, 해당 LiveData를 Activity/Fragment에서 Observing하여 Network 별 UI를 Controll 합니다. private val _currentNetworkStatus = MutableLiveData&lt;NetworkStatus&gt;() val currentNetworkStatus: LiveData&lt;NetworkStatus&gt; get() = _currentNetworkStatus // DataBinding에서 사용될 StateFlow 입니다. // StateFlow는 초기값이 항상 필요하며, StateFlow는 중복값을 무시하고 .value를 통해 현재 값을 가져올 수 있습니다.(양방향 Observing) val networkStatus = MutableStateFlow(NetworkStatus.CONNECT_ERROR) // Mobile Data 즉 Cellular 연결을 체크할지 유무입니다. private var checkMobileData = false // Network 가 연결되었을 경우, 연결되어있지 않을 경우를 Boolean으로 구분하여 처리합니다. // Coroutine Channel 은 정확히 한 번만 처리해야하는 Event를 처리하는데 사용됩니다. (단방향 Observing) private val _networkAction = Channel&lt;Boolean&gt;(Channel.CONFLATED) val networkAction = _networkAction.receiveAsFlow() // Wifi를 담당하는 NetworkCallback 입니다. private val wifiNetworkCallback = object : ConnectivityManager.NetworkCallback() { // 연결된 경우 override fun onAvailable(network: Network) { super.onAvailable(network) isWifiConn = true changeNetworkStatus() } // 연결 끊긴 경우 override fun onLost(network: Network) { super.onLost(network) isWifiConn = false changeNetworkStatus() } } // Cellular를 담당하는 NetworkCallback 입니다. private val cellularNetworkCallback = object : ConnectivityManager.NetworkCallback() { override fun onAvailable(network: Network) { super.onAvailable(network) isCellularConn = true changeNetworkStatus() } override fun onLost(network: Network) { super.onLost(network) isCellularConn = false changeNetworkStatus() } } // Default Network를 담당하는 NetworkCallback 입니다. private val defaultNetworkCallback = object : ConnectivityManager.NetworkCallback() { override fun onAvailable(network: Network) { super.onAvailable(network) isNetworkConn = true changeNetworkStatus() } override fun onLost(network: Network) { super.onLost(network) isNetworkConn = false changeNetworkStatus() } } // 네트워크 상태를 바꿔주는 함수 입니다. fun changeNetworkStatus() = viewModelScope.launch { // 모바일 데이터 사용 유무를 DataStore에서 가져옵니다. val isDataConn = dataStore.getUserMobileData.first() networkStatus.value = when { // 네트워크가 연결된 경우 isNetworkConn &amp;&amp; (isWifiConn || !checkMobileData || (isDataConn &amp;&amp; isCellularConn)) -&gt; { NetworkStatus.CONNECT_NETWORK } // 네트워크가 연결되어있지만 셀룰러를 사용하지 않는 경우 isNetworkConn &amp;&amp; !isDataConn &amp;&amp; isCellularConn -&gt; { NetworkStatus.CONNECT_NETWORK_BUT_NOT_USE_MOBILE_DATA } // 나머지의 경우 else -&gt; { NetworkStatus.DISCONNECT_NETWORK } } if (networkStatus.value != currentNetworkStatus.value) { _currentNetworkStatus.value = networkStatus.value } } // 네트워크 Callback을 등록할 때 사용하는 함수 입니다. fun register(checkMobileData: Boolean = true, checkNetworkStatus: Boolean = false) { this.checkMobileData = checkMobileData manager = application.applicationContext.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager // Android Version이 24보다 클 경우 DefaultNetwork 사용 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { registerDefaultNetwork() } else { isNetworkConn = true } // Wifi Network Callback 등록 registerWifi() // Cellular Network Callback 등록 registerCellular() if (checkNetworkStatus) { // 버전 관리 SDK_INT 23 이상부터는 activeNetworkInfo 는 Deprecated 됨 if (Build.VERSION.SDK_INT &gt;= 23) { checkActiveNetwork() } else { checkActiveNetworkInfo() } changeNetworkStatus() } } // 네트워크 Callback을 해제할 때 사용하는 함수 입니다. fun unRegister() { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { unRegisterDefaultNetwork() } unRegisterWifi() unRegisterCellular() manager = null } // 활성화된 Network 정보를 가져오는 함수 입니다. SDK_INT 23 이상부터는 activeNetwork 를 통하여 가져옵니다. private fun checkActiveNetwork() { manager?.activeNetwork?.let { isNetworkConn = true isWifiConn = hasTransport(it, NetworkCapabilities.TRANSPORT_WIFI) isCellularConn = hasTransport(it, NetworkCapabilities.TRANSPORT_CELLULAR) } } private fun hasTransport(network: Network, transport: Int): Boolean = manager?.getNetworkCapabilities(network)?.hasTransport(transport) ?: false // 활성화된 Network 정보를 가져오는 함수 입니다. SDK_INT 23 이하에서는 activeNetworkInfo 를 통하여 가져옵니다. @Suppress(\"DEPRECATION\") private fun checkActiveNetworkInfo() { manager?.activeNetworkInfo?.let { if (it.isConnectedOrConnecting) { isNetworkConn = true isWifiConn = it.type == ConnectivityManager.TYPE_WIFI isCellularConn = it.type == ConnectivityManager.TYPE_MOBILE } } } // WIFI Callback을 등록하는 함수 입니다. private fun registerWifi() { manager?.registerNetworkCallback( createNetworkRequest(NetworkCapabilities.TRANSPORT_WIFI), wifiNetworkCallback ) } // WIFI Callback을 해제하는 함수 입니다. private fun unRegisterWifi() { manager?.unregisterNetworkCallback(wifiNetworkCallback) } // Cellular Callback을 등록하는 함수 입니다. private fun registerCellular() { manager?.registerNetworkCallback( createNetworkRequest(NetworkCapabilities.TRANSPORT_CELLULAR), cellularNetworkCallback ) } // Cellular Callback을 해제하는 함수 입니다. private fun unRegisterCellular() { manager?.unregisterNetworkCallback(cellularNetworkCallback) } // Default Network Callback을 등록하는 함수 입니다. private fun registerDefaultNetwork() { manager?.registerDefaultNetworkCallback(defaultNetworkCallback) } // Default Network Callback을 해제하는 함수 입니다. private fun unRegisterDefaultNetwork() { manager?.unregisterNetworkCallback(defaultNetworkCallback) } // Default Network를 제외한 사용 가능한 다른 Network를 등록하는 함수 (여기서는 WIFI, CELLULAR) private fun createNetworkRequest(capability: Int): NetworkRequest { return NetworkRequest.Builder() .addTransportType(capability) .build() } // 모바일 데이터 차단 시 차단 해제로 바꿔주는 함수 입니다. private fun changeUseMobileDataState() = viewModelScope.launch { val useMobileData = dataStore.getUserMobileData.first() dataStore.putUseMobileData(!useMobileData) changeNetworkStatus() } // 새로고침 버튼 클릭 함수 입니다. fun onReTryClick() = viewModelScope.launch { when (networkStatus.value) { // 네트워크가 끊겼거나 Error인 경우 NetworkStatus.DISCONNECT_NETWORK, NetworkStatus.CONNECT_ERROR -&gt; { _networkAction.send(false) } // 모바일 데이터에 연결은 되었으나 모바일 데이터를 차단한 경우 NetworkStatus.CONNECT_NETWORK_BUT_NOT_USE_MOBILE_DATA -&gt; { changeUseMobileDataState() } // 네트워크가 연결되었을 경우 NetworkStatus.CONNECT_NETWORK -&gt; { _networkAction.send(true) } } }}2. NetworkFragment저는 네트워크 연결이 끊겼으면 NetworkFragment를 띄워주는 식으로 하였습니다.@AndroidEntryPointclass NetworkFragment : DialogFragment() { private lateinit var binding: FragmentNetworkBinding // navigation safe args 사용 private val args: NetworkFragmentArgs by navArgs() private val viewModel: NetworkViewModel by activityViewModels() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = DataBindingUtil.inflate(inflater, layoutResId, container, false) binding.lifecycleOwner = viewLifecycleOwner return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.viewModel = viewModel viewModel.networkStatus.value = args.networkState networkViewModelCallback() } private fun networkViewModelCallback() = with(viewModel) { currentNetworkStatus.observe(viewLifecycleOwner) { when(it) { // 네트워크가 연결되면 NetworFragment 지워줌 NetworkViewModel.NetworkStatus.CONNECT_NETWORK -&gt; { findNavController().popBackStack() } else -&gt; {} } } // \"새로고침\" 눌렀을 경우 viewLifecycleOwner.lifecycleScope.launchWhenStarted { networkAction.collect { if (it) { // 네트워크가 연결되었을 경우 findNavController().popBackStack() } else { // 네트워크가 연결되지 않았을 경우 showSnackBar(binding.root, getString(R.string.disabled_network)) } } } } override fun onStart() { super.onStart() val d = dialog when (activity) { is IntroActivity -&gt; { if (d != null) { // intro 화면에서 Dialog 를 Cancel 했을 경우 d.setOnCancelListener { requireActivity().finish() } } else { isCancelable = false } } is MainActivity -&gt; { if (d != null) { } else { isCancelable = false } } } } override fun onResume() { super.onResume() dialog?.window?.let { window -&gt; window.setBackgroundDrawableResource(android.R.color.transparent) window.clearFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND) // 기본 배경 제거 val params = window.attributes params.width = WindowManager.LayoutParams.MATCH_PARENT params.height = WindowManager.LayoutParams.MATCH_PARENT window.attributes = params setTransparentStatusBar(window) } }}3. NetworfFragment Navigation Graph&lt;dialog android:id=\"@+id/networkFragment\" android:name=\"com.example.networtest.view.fragment.network.NetworkFragment\" android:label=\"NetworkFragment\" tools:layout=\"@layout/fragment_network\"&gt; &lt;!-- Safe Args 사용 --&gt; &lt;argument android:name=\"networkState\" android:defaultValue=\"CONNECT_ERROR\" app:argType=\"com.example.networtest.view.fragment.network.NetworkViewModel$NetworkStatus\" /&gt; &lt;/dialog&gt;&lt;!-- 네트워크는 언제 어디서든 끊길 수 있기 때문에 전역에서 사용 --&gt;&lt;action android:id=\"@+id/action_global_networkFragment\" app:destination=\"@id/networkFragment\" /&gt;4. NetworkFragment xml 정의 (R.layout.fragment_network)&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;import type=\"com.example.networtest.view.fragment.network.NetworkViewModel.NetworkStatus\"/&gt; &lt;variable name=\"viewModel\" type=\"com.example.networtest.view.fragment.network.NetworkViewModel\" /&gt; &lt;/data&gt; &lt;FrameLayout android:id=\"@+id/network_fl\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#55000000\"&gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/colorTranslucentDim\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:layout_marginTop=\"200dp\" android:orientation=\"vertical\" android:paddingStart=\"20dp\" android:paddingEnd=\"20dp\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:src=\"@drawable/search_none_w\" /&gt; &lt;!-- 네트워크가 끊겼을 경우 \"연결이 원활하지 않습니다.\\n네트워크 연결 상태를 확인하거나\\n다시 시도해 주세요.\" 를 보여줌 --&gt; &lt;!-- 나머지 경우 즉, Cellular 차단의 경우 \"모바일데이터 차단 상태입니다.\\n차단을 해제하거나\\nWi-Fi를 설정해 주세요.\" 를 보여줌 --&gt; &lt;TextView android:id=\"@+id/network_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"15.8dp\" android:layout_marginBottom=\"17.2dp\" android:gravity=\"center\" android:letterSpacing=\"-0.02\" android:lineHeight=\"20sp\" android:lineSpacingExtra=\"6sp\" android:lineSpacingMultiplier=\"1.2\" android:text=\"@{viewModel.networkStatus == NetworkStatus.DISCONNECT_NETWORK ? @string/retry_disabled_network : @string/use_mobile_data}\" android:textAlignment=\"center\" android:textColor=\"@android:color/white\" android:textSize=\"14sp\" /&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:orientation=\"horizontal\"&gt; &lt;!-- 네트워크가 끊겼을 경우 \"새로고침\" 보여줌 --&gt; &lt;!-- 모바일 데이터가 차단되었을 경우 \"차단해제\" 보여줌 --&gt; &lt;Button android:id=\"@+id/retry_btn\" style=\"?android:attr/borderlessButtonStyle\" android:layout_width=\"89dp\" android:layout_height=\"40dp\" android:layout_marginStart=\"4dp\" android:layout_marginEnd=\"4dp\" android:background=\"@drawable/positive_bg3\" android:letterSpacing=\"-0.02\" android:lineSpacingExtra=\"-4sp\" android:textColor=\"#ffffff\" android:textSize=\"14sp\" android:text=\"@{viewModel.networkStatus == NetworkStatus.DISCONNECT_NETWORK ? @string/retry : @string/block_off }\" android:onClick=\"@{() -&gt; viewModel.onReTryClick()}\" tools:text=\"@string/retry\"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; &lt;/FrameLayout&gt;&lt;/layout&gt;5. NetworkViewModel 연결@AndroidEntryPointclass MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val mainViewModel: MainViewModel by viewModels() private val networkViewModel: NetworkViewModel by viewModels() private lateinit var navController: NavController val navHostFragment by lazy { supportFragmentManager.findFragmentById(R.id.navHostFragmentContainer) as NavHostFragment } override fun onCreate(saveInstanceState: Bundle?) { binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this binding.viewModel = mainViewModel navController = navHostFragment.navController // Network Callback 등록 networkViewModel.register(checkNetworkStatus = true) initMainViewModelCallback() initNetworkViewModelCallback() } private fun initMainViewModelCallback() = with(mainViewModel) { isMobileDataOk.observe(viewLifecycleOwner) { // isModileDataOk 의 값이 변결될 때 마다 networkViewModel 의 changeNetworkStatus() 함수 호출 networkViewModel.changeNetworkStatus() } } private fun initNetworkViewModelCallback() = with(networkViewModel) { currentNetworkStatus.observe(this@MainActivity) { it: NetworkViewModel.NetworkState! when (it) { NetworkViewModel.NetworkStatus.CONNECT_NETWORK -&gt; { // TODO: 네트워크가 연결되었을 때 동작 넣기 } // 네트워크 차단 및 Error, Disconnect 의 경우 NetworkFragment 보여줌(현재 Network상태를 NetworFragment 에 넣어줍니다.) else -&gt; { navController.navigate( NavigationDirections.actionGlobalNetworkFragment(it) ) } } } } // Activity가 onDestory() 될 때 Network Callback 해제 override fun onDestroy() { networkViewModel.unRegister() super.onDestroy() }}5. MainViewModel 정의 (모바일데이터 차단/해제 기능)@HiltViewModelclass MainViewModel @Inject constructor( private val dataStore: DataStoreModule) : ViewModel() { // DataStore 의 flow 값을 LiveData로 변경 val isMobileDataOk: LiveData&lt;Boolean&gt; = liveData { dataStore.getUserMobileData.collect { emit(it) } } // 모바일 데이터 차단/해제 클릭 Listener fun onMobileClick() = viewModelScope.launch { // 누를때마다 isMobileDataOk 의 반대값을 넣어줌 dataStore.putUseMobileData(!isMobileDataOk.value!!) }}6. MainActivity xml 정의 (R.layout.activity_main)&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" tools:context=\".activity.main.MainActivity\"&gt; &lt;data&gt; &lt;variable name=\"viewModel\" type=\"com.example.networtest.view.activity.main.MainViewModel\" /&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;androidx.fragment.app.FragmentContainerView android:id=\"@+id/navHostFragmentContainer\" android:name=\"androidx.navigation.fragment.NavHostFragment\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:defaultNavHost=\"true\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:navGraph=\"@navigation/navigation\" /&gt; &lt;!-- isMobileDataOk 가 true 이면 \"차단\", false 이면 \"차단해제\" 보여줌 --&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:text=\"@{viewModel.isMobileDataOk ? @string/block : @string/block_off}\" android:onClick=\"@{() -&gt; viewModel.onMobileClick()}\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt;7. 모바일 데이터 차단 유무를 저장을 위한 DataStore 정의DataStore에 대하여 자세히 알고싶으시면 해당 링크를 참고하세요. -&gt; DataStore 정리class DataStoreModule( private val context: Context) { // DataStore 인스턴스 생성 private val Context.dataStore by preferencesDataStore(name = \"test.db\") private val mobileDataKey = booleanPreferencesKey(\"use_mobile_data\") val getUserMobileData: Flow&lt;Boolean&gt; = context.dataStore.data .catch { exception -&gt; if (exception is IOException) { emit(emptyPreferences()) } else { throw exception } } .map { preferences -&gt; preferences[mobileDataKey] ?: false } suspend fun putUseMobileData(use: Boolean) { val getData = getUserMobileData.first() if (getData != use) { context.dataStore.edit { preferences -&gt; preferences[mobileDataKey] = use } } }}8. DataStore Hilt Module 정의@Module@InstallIn(SingletonComponent::class)object LocalDataModule { @Singleton @Provides fun provideDataStoreModule(@ApplicationContext context: Context): DataStoreModule { return DataStoreModule(context) }}마무리이번 포스팅에서는 Android ConnectivityManager 를 통한 Network 관리에 대하여 코드를 위주로 알아보았습니다.해당 코드에서는 Default Network, Wifi, Cellular 상태를 관리하며, Cellular 차단 기능 또한 들어있습니다.Network 의 연결이 끊겼을 시 NetworkFragment를 띄워주며 네트워크 끊김, Cellular는 연결되어 있지만 Cellular를 차단한 경우에 따라 UI를 분리하고 있습니다.또한 버튼을 클릭 시 모바일 데이터를 차단/해제 하는 코드 또한 존재합니다.다음 시간에는 위에서 사용중인 Flow 및 StateFlow, Coroutine Channel 에 대하여 자세히 알아보도록 하겠습니다." }, { "title": "Android DataStore(SharedPreference 대체)", "url": "/posts/Android-DataStore/", "categories": "Android, DataStore", "tags": "android, datastore", "date": "2022-07-18 09:08:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.오늘은 Android DataStore 에 대하여 알아보고자 합니다.DataStore 이전에는 가벼운 데이터를 저장하기 위해 SharedPreferences를 사용하였는데 SharedPreferences 에는 다양한 한계점이 있었습니다.첫째로 비동기 작업을 제대로 해주지 않으면 ANR 즉, Application Not Responding(애플리케이션 응답 없음)이 발생할 수 있습니다.두번째는 오류가 발생하면 확인이 불가능고, Runtime에 Exception이 발생(RuntimeException)하어 앱이 강제 종료될 수 있었습니다.또한 type safety 가 보장되지 않아 어떤 데이터가 저장되고 추출되는지 일일히 type converting 즉, 형 변환을 해주어야 했습니다.밑에서 자세히 알아보도록 하겠습니다.SharedPreference의 한계점우선 SharedPreference 의 단점에 대하여 알아보겠습니다. SharedPrefereence 는 동기 API를 제공하는 것과 MainThread로 부터 안전하지 않습니다. 즉, UI Thread를 Blocking 하여 ANR을 발생시킬 수 있습니다. Strong Consistency가 보장되지 않아 Multiple Thread 환경에서 안전하지 않습니다. type safety가 보장되지 않습니다.이러한 문제점을 개선하기 위해 DataStore가 등장하였습니다.DataStore 프로토콜 버퍼를 사용하여 key-value 쌍 또는 유형이 저장된 객체를 저장할 수 있는 데이터 저장소 솔루션입니다. Coroutine 및 Flow 를 사용하여 비동기적이고 일관된 Transaction 방식으로 데이터를 저장하는 것이 특징입니다. DataStore 는 내부적으로 Dispatchers.IO 를 사용하기 때문에 UI Thread에서 사용하여도 ANR이 발생하지 않습니다. Runtime Error로 부터 안전합니다. Protocol Buffer를 사용하여 Type Safety한 코드를 작성할 수 있습니다. DataStore 2가지 Preferences DataStore : key 와 value로 구성되며 Type Safety 하지 못합니다. Proto DataStore : 사용자가 정의한 데이터를 저장하며 Protocol Buffer를 이용하여 Schema를 정의해야 합니다. 데이터의 타입을 보장해 줍니다.(Type Safety) 참고 -&gt; 복잡한 대규모 데이터 저장, 부분 업데이트, 참조 무결성을 지원해야 할 경우에는 DataStore 대신 Room을 사용하는 것이 좋습니다. DataStore는 소규모 단순 데이터 저장에 적합하며 부분 업데이트나 참조 무결성은 지원하지 않습니다.Preferences DataStore ExamplePreferences DataStore 에 대하여 코드를 통해 알아보겠습니다.해당 코드에서는 Android Dagger-Hilt를 사용하여 의존성 관리 하였으며, 간단한 String값 저장 및 Boolean값을 저장하는 코드입니다. DataStore 의존성 관련은 구글 공식 홈페이지를 참고하여 주세요. DataStore 정의 class DataStoreModule( private val context: Context) { // DataStore 인스턴스 생성 private val Context.dataStore by preferencesDataStore(name = \"test.db\") // String 저장 Key 값 private val stringKey = stringPreferencesKey(\"string_key_name\") // DataStore로 부터 값 가져오기 val getText = context.datastore.data .catch { exception -&gt; if (exception is IOException) { emit(emptyPreferences()) } else { throw exception } } .map { preferences -&gt; preferences[stringKey] ?: \"\" } // DataStore에 값 저장 suspend fun setText(text: String) { // DataStore에 저장된 String 값과 매개변수로 넘어오는 String값이 다를 경우만 저장(중복값 저장 안함) val getData = getText.first() if (getData != text) { context.dataStore.edit { preferences -&gt; preferences[stringKey] = userId } } } // Boolean 저장 Key 값 private val booleanKey = booleanPreferencesKey(\"boolean_key_name\") // DataStore로 부터 값 가져오기 val getIsAutoLogin = context.datastore.data .catch { exception -&gt; if (exception is IOException) { emit(emptyPreferences()) } else { throw exception } } .map { preferences -&gt; preferences[booleanKey] ?: false } // DataStore에 값 저장 suspend fun setIsAutoLoing(isAuto: Boolean) { // DataStore에 저장된 String 값과 매개변수로 넘어오는 String값이 다를 경우만 저장(중복값 저장 안함) val getData = getIsAutoLogin.first() if (getData != text) { context.dataStore.edit { preferences -&gt; preferences[booleanKey] = userId } } }} Hilt를 이용한 의존성 주입 @Module@InstallIn(SingletonComponent::class) // Application 의 onCreate()에서 생성, onDestroy()에서 파괴object LocalDataModule { @Singleton @Provides fun provideDataStoreModule(@ApplicationContext context: Context): DataStoreModule { return DataStoreModule(context) }} 사용 @AndroidEntryPointclass HomeFragment : Fragment() { private lateinit var binding: FragmentHomeBinding // Hilt를 통해 주입받는 객체는 Private 할 수 없음 @Inject lateinit var dataStore: DataStoreModule override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = DataBindingUtil.inflate(inflater, layoutResId, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.lifecycleOwner = viewLifecycleOwner // DataStore 값 가져오기 viewLifecycleOwner.lifecycleScope.launch { dataStore.getText.collect { it: String Timber.e(\"data store getText Value -&gt; $it\") } } // DataStore 값 저장하기 CoroutineScope.launch(Dispatchers.IO) { dataStore.setText(\"test\") } }} 마치며이번 포스팅에서는 DataStore에 대하여 알아보았습니다.Preferences DataStore에 대하여 알아보았는데 저는 Proto DataStore는 잘 사용하지 않습니다.구글 공식 홈페이지에 나와있듯 복잡한 데이터는 Room에 저장하는 것이 좋고 편하므로 복잡한 데이터를 저장할때는 Room을 이용합니다.이번 포스팅은 여기서 마치도록 하겠습니다." }, { "title": "Android Custom Dialog", "url": "/posts/Android-Custom-Dialog/", "categories": "Android, Custom", "tags": "android, custom, dialog", "date": "2022-07-15 16:38:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.이번 포스팅은 조금 가벼운 주제로 쉬어가고자 합니다.Custom Dialog를 만들어 필요할 때 마다 간단히 호출하여 사용하는 방법을 익혀보고자 합니다.Custom Dialog Class 생성class BasicDialog( private context: Context, root: ViewGroup? = null) { private val builder = AlertDialog.Builder(context, R.style.AlertDialogTheme) private val binding: DialogBasicPopupBinding by lazy { val b = DialogBasicPopupBinding.inflate(LayoutInflater.from(context), root, false) // DataBinding 을 사용합니다. b.body = null b.okCallback = null b.cancelCallback = null return@lazy b } // androidx 의 AlertDialog를 import 해주셔야 합니다. private var dialog: AlertDialog? = null // Dialog 의 Title을 지정해주는 Method 입니다. // R.string.confirm 의 형식을 인자에 넣어주는 Method 입니다. fun setTitle(@StringRes titleId: Int): BasicDialog { return setTitle(context.getText(titleId)) } // 위의 setTitle 의 return 에서 사용하는 Method 입니다. // resources.getString() 로 string resource를 가져와 인자에 넣어주는 방식의 Method 입니다. fun setTitle(title: CharSequence): BasicDialog { // Data Binding 을 사용하여 xml에 넣어줍니다. binding.subject = title return this } // Dialog 의 Message를 지정해주는 Method 입니다. // R.string.confirm 의 형식을 인자에 넣어주는 Method 입니다. fun setMessage(@StringRes messageId: Int): BasicDialog { return setMessage(context.getText(messageId)) } // 위의 setMessage 함수의 return에서 사용하는 Method 입니다. // resource.getString() 로 string resource를 가져와 인자에 넣어주는 방식의 Method 입니다. fun setMessage(message: CharSequence): BasicDialog { // Data Binding 을 사용하여 xml에 넣어줍니다. binding.body = message return this } // Dialog 의 Message를 지정해주는 Method 입니다. // R.string.confirm 의 형식을 인자에 넣어주는 Method 입니다. fun setMessageStyle1(@StringRes messageId: Int): BasicDialog { return setMessageStyle1(context.getText(messageId)) } // 위의 setMessageStyle1 함수의 return에서 사용하는 Method 입니다. // resource.getString() 로 string resource를 가져와 인자에 넣어주는 방식의 Method 입니다. fun setMessageStyle1(message: CharSequence): BasicDialog { // SpannableStringBuilder 를 사용하면 Code 상에서 TextView에 넣을 문자 일부의 색, 크기, 스타일을 변경할 수 있습니다. return setMessage(SpannableStringBuilder(message).apply { // 지정된 개체로 지정된 텍스트 범위를 표시합니다. // Flag 는 범위 범위의 시작 또는 끝에 텍스트가 삽입될 때 범위가 작동하는 방식을 결정합니다. // start 변수에서부터 end 변수까지를 what의 설정으로 변경합니다. setSpan( // 텍스트 크기를 물리적 픽셀 크기로 설정하거나 'dip'이 true인 경우 장치 독립적 픽셀 크기로 설정합니다. what = AbsoluteSizeSpan( TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP, 17f, // Text 크기를 17f로 고정 binding.root.context.resources.displayMetrics ).toInt(), dip = false ), start = 0, end = length, flags = Spanned.SPAN_EXCLUSIVE_EXCLUSIVE // 길이가 0일 수 없으며 포함하는 모든 텍스트가 제거되면 버퍼에서 자동으로 제거됩니다. ) }) } // Dialog의 \"확인\" 버튼 Click Listener 라고 생각하시면 됩니다. // R.string.confirm 의 형식을 인자에 넣어주고 Click Listener Callback을 받는 Method 입니다. fun setPositiveButton(@StringRes textId: Int, listener: View.OnClickListener?): BasicDialog { return setPositiveButton(context.getText(textId), listener) } // resource.getString() 로 string resource를 가져와 인자에 넣어주고 Click Listener Callback을 받는 Method 입니다. fun setPositiveButton(text: CharSequence, listener: View.OnClickListener?): BasicDialog { // 버튼 이름을 Data Binding 을 통해 넣어줍니다. binding.ok = text if (listener != null) { // Click Listener를 Data Binding을 통해 넣어줍니다. binding.okCallback = View.OnClickListener { v -&gt; listener.onClick(v) dismiss() } } else { binding.okCallback = listener } return this } // Dialog \"부정\" 버튼 Click Listener 라고 생각하시면 됩니다. // R.string.confirm 의 형식을 인자에 넣어주고 Click Listener Callback을 받는 Method 입니다. fun setNegativeButton(@StringRes textId: Int, listener: View.OnClickListener): BasicDialog { return setNegativeButton(context.getText(textId), listener) } // resource.getString() 로 string resource를 가져와 인자에 넣어주고 Click Listener Callback을 받는 Method 입니다. fun setNegativeButton(text: CharSequence, listener: View.OnClickListener?): BasicDialog { // 부정 버튼 이름을 Data Binding 을 통해 넣어줍니다. binding.cancel = text if (listener != null) { // Click Listener를 Data Binding을 통해 넣어줍니다. binding.cancelCallback = View.OnClickListener { v -&gt; listener.onClick(v) dismiss() } } else { binding.cancelCallback = listener } return this } // Dialog 취소가 되는지 여부를 설정합니다. fun setCancelable(cancelable: Boolean): BasicDialog { builder.setCancelable(cancelable) return this } // Dialog 의 취소 Listener 를 설정합니다. fun setOnCancelListener(onCancelListener: DialogInterface.OnCancelListener): BasicDialog { builder.setOnCancelListener(onCancelListener) return this } // Dialog 가 dismiss 될때 호출되는 Listener 를 설정합니다. // Dialog 가 dismiss 될때 해야할 적업이 있을 때 사용하시면 됩니다. fun setOnDismissListener(onDismissListener: DialogInterface.OnDismissListener): BasicDialog { builder.setOnDismissListener(onDismissListener) return this } // Dialog 에 Custom View를 세팅해주고 dialog를 create() 해주는 Method 입니다. private fun create(): AlertDialog { builder.setView(binding.root) dialog = builder.create() return dialog!! } // Dialog 를 보여주는 함수입니다. Dialog 는 마지막에 show()를 호출하지 않으면 동작하지 않습니다. fun show() { create().show() } // Dialog 를 dismiss 하는 함수입니다. fun dismiss() { dialog?.dismiss() }}xml 쪽 알아보기DialogBasicPopupBinding 내부를 살펴보겠습니다.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- Data Binding 을 사용하기 위해 alt + enter 를 통해 layout 테그를 만들어 줍니다. --&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;!-- View의 Visible 처리를 해주기 위해 import 합니다. --&gt; &lt;import type=\"android.view.View\" /&gt; &lt;!-- 제목, 즉 Title을 담당하는 변수입니다. --&gt; &lt;variable name=\"subject\" type=\"CharSequence\" /&gt; &lt;!-- Message를 담당하는 변수입니다. --&gt; &lt;variable name=\"body\" type=\"CharSequence\" /&gt; &lt;!-- 취소 버튼의 이름을 담당하는 변수입니다. --&gt; &lt;variable name=\"cancel\" type=\"CharSequence\" /&gt; &lt;!-- 확인 버튼의 이름을 담당하는 변수입니다. --&gt; &lt;variable name=\"ok\" type=\"CharSequence\" /&gt; &lt;!-- 취소 버튼의 Click Listenr 를 담당해줄 변수입니다. --&gt; &lt;variable name=\"cancelCallback\" type=\"android.view.View.OnClickListener\" /&gt; &lt;!-- 확인 버튼의 Click Listenr 를 담당해줄 변수입니다. --&gt; &lt;variable name=\"okCallback\" type=\"android.view.View.OnClickListener\" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:paddingHorizontal=\"20dp\" tools:background=\"@color/colorSignUpHint\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:padding=\"20dp\" android:background=\"@drawable/white_round_frame\"&gt; &lt;LinearLayout android:id=\"@+id/basicDialogTitleLl\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:minHeight=\"120dp\" android:orientation=\"vertical\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;!-- 삼항식을 사용하여 title이 null 이 아니면 보여주고 null 이면 GONE 처리합니다. --&gt; &lt;TextView android:id=\"@+id/subjectTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:letterSpacing=\"-0.02\" android:lineSpacingExtra=\"6sp\" android:paddingBottom=\"7.5dp\" android:lineSpacingMultiplier=\"0.65\" android:maxLines=\"3\" android:paddingTop=\"2.2dp\" android:text=\"@{subject}\" android:textColor=\"#000000\" android:textSize=\"17sp\" android:textStyle=\"bold\" android:visibility=\"@{subject != null ? View.VISIBLE : View.GONE}\" tools:text=\"인증에 실패하였습니다.\\n다시 인증해주세요.\" /&gt; &lt;!-- 삼항식을 사용하여 Message가 null 이 아니면 보여주고 null 이면 GONE 처리합니다. --&gt; &lt;TextView android:id=\"@+id/bodyTv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"24.5dp\" android:gravity=\"center_horizontal\" android:letterSpacing=\"-0.03\" android:lineSpacingExtra=\"6sp\" android:lineSpacingMultiplier=\"0.65\" android:maxLines=\"5\" android:text=\"@{body}\" android:textColor=\"#000000\" android:textSize=\"14sp\" android:visibility=\"@{body != null ? View.VISIBLE : View.GONE}\" tools:text=\"인증번호를 받지 못한 경우 재요청하여 인증번호를 수신 후 진행하여 주십시오.\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:orientation=\"horizontal\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/basicDialogTitleLl\"&gt; &lt;TextView android:layout_width=\"0dp\" android:layout_height=\"48dp\" android:layout_weight=\"1\" android:background=\"@drawable/common_button_cancel\" android:gravity=\"center\" android:letterSpacing=\"-0.02\" android:lineSpacingExtra=\"-4sp\" android:text=\"@{cancel}\" android:textColor=\"#ffffff\" android:textSize=\"16sp\" android:visibility=\"@{cancelCallback != null ? View.VISIBLE : View.GONE}\" android:onClick=\"@{cancelCallback}\" tools:text=\"@string/str_cancel\" /&gt; &lt;!-- Space를 통해 취소 버튼과 확인 버튼 사이에 공백을 만듭니다. --&gt; &lt;!-- 취소 버튼의 ClickListener 가 Null 이 아니고 확인 버튼의 ClickListener 가 Null 이 아닐때만 보여주고 둘 중 하나라도 NUll 일 경우 Gone 처리 됩니다. --&gt; &lt;!-- &amp;amp;&amp;amp; = &amp;&amp; 와 같습니다. --&gt; &lt;Space android:id=\"@+id/space\" android:layout_width=\"8dp\" android:layout_height=\"48dp\" android:visibility=\"@{cancelCallback != null &amp;amp;&amp;amp; okCallback != null ? View.VISIBLE : View.GONE}\" /&gt; &lt;TextView android:layout_width=\"0dp\" android:layout_height=\"48dp\" android:layout_weight=\"1\" android:background=\"@drawable/common_button_ok\" android:gravity=\"center\" android:letterSpacing=\"-0.02\" android:lineSpacingExtra=\"-4sp\" android:text=\"@{ok}\" android:textColor=\"#ffffff\" android:textSize=\"16sp\" android:visibility=\"@{okCallback != null ? View.VISIBLE : View.GONE}\" android:onClick=\"@{okCallback}\" tools:text=\"@string/confirm\" /&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/LinearLayout&gt;&lt;/layout&gt;실제로 사용해 보기class HomeFragment : Fragment() { private lateinit var binding: FragmentHomeBinding override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = DataBindingUtil.inflate(inflater, layoutResId, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.lifecycleOwner = viewLifecycleOwner binding.showDialogButton.setOnClickListener { BasicDialog(requireContext(), binding.root as? ViewGroup) .setMessageStylel( getSpannedFromHtml( resources.getString(R.string.str_hello) .format(\"narvis2\") ) ) .setPositiveButton(resources.getString(R.string.str_confirm)) { // TODO: 확인 버튼 클릭 시 동작 작성 } .setNegativeButton(resources.getString(R.string.str_cancel)) { // TODO: 취소 버튼 클릭 시 동작 작성 // setNegativeButton 함수 내부에 dialog.dismiss()가 포함되어 있으므로 빈칸으로 놔둬도 클릭 시 자동 dismiss처리 됩니다. } .show() // show() 함수 내부에 create().show() 로 되어있습니다. } } // 제공된 HTML 문자열에서 표시 가능한 스타일 텍스트를 반환하는 Method 입니다. private fun getSpannedFromHtml(text: String?): Spanned? { return if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) { Html.fromHtml(text) } else { Html.fromHtml(text, Html.FROM_HTML_MODE_LEGACY) } }}strings 파일&lt;!-- 이렇게하면 &lt;b&gt; &lt;/b&gt; 안의 글자만 Bold 처리 됩니다. --&gt;&lt;string name=\"str_hello\"&gt;&lt;![CDATA[&lt;b&gt;%1$s&lt;/b&gt; 님 안녕하십니까?]]&gt;&lt;/string&gt;&lt;string name=\"str_confirm\"&gt;확인&lt;/string&gt;&lt;string name=\"str_cancel\"&gt;취소&lt;/string&gt;drawable1. common_button_cancel.xml 입니다. 취소 버튼 색상이 회색으로 바뀌며 모서리가 14dp 만큼 둥글게 됩니다.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;corners android:radius=\"14dp\" /&gt; &lt;solid android:color=\"#a8a9ae\" /&gt;&lt;/shape&gt;2. common_button_ok.xml 입니다. 확인 버튼 색상이 남색으로 바뀌며 모서리가 14dp 만큼 둥글게 됩니다.&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;corners android:radius=\"14dp\" /&gt; &lt;solid android:color=\"#152348\" /&gt;&lt;/shape&gt;StyleAlertDialog.Builder(context, R.style.AlertDialogTheme) 에 적용되는 Style 입니다. 뒷 배경을 투명으로 만듭니다. dialog 가 화면의 위, 아래 기준으로 중간에 오도록 합니다. 상태바 색상을 투명으로 만듭니다.&lt;style name=\"AlertDialogTheme\" parent=\"transparent\"&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;item name=\"android:layout_gravity\"&gt;center_vertical&lt;/item&gt; &lt;item name=\"android:statusBarColor\"&gt;@android:color/transparent&lt;/item&gt;&lt;/style&gt;마치며이번 포스팅에서는 Custom Dialog를 만드는 코드를 살펴보았습니다.해당 코드는 제가 주로 사용하는 방식입니다.다음에는 “중복 클릭 방지” 기능에 대한 코드를 살펴보겠습니다." }, { "title": "Android RequestMultiplePermissions()을 사용하여 권한 요청", "url": "/posts/Android-Permission/", "categories": "Android, Permission", "tags": "android, permission", "date": "2022-07-15 15:22:00 +0900", "snippet": "안녕하세요. narvis2 입니다.이번 포스팅에서는 Android에서 위험 권한을 요청하는 방법에 대해서 설명해볼까 합니다.기존에는 startActivityForResult()를 사용하여 권한 요청을 하였으나 해당 함수가 Deprecated됨에 따라 startActivityForResult()를 대체하는 방법을 Code를 통해 간단히 알아보겠습니다.RequestMultiplePermissions() 사용class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding // 필요한 권한을 배열에 담습니다. private val permissions = arrayOf( Manifest.permission.RECORD_AUDIO, Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE ) private val permissionResultLauncher = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { if(it.all { permissions -&gt; permissions.value == ture}) { // TODO: 권한이 승인되었을 경우 } else { // 권한이 거부 되었을 경우 } } override fun onCreate(saveInstanceState: Bundle?) { super.onCreate(saveInstanceState) binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this // 권한 체크 후 권한이 허가되지 않았으면 권한 요청 if (!checkPermission(permissions)) { permissionResultLauncher.launch(permissions) } binding.startSubActivity.setOnClickListener { onStartSubActivity() } } // 권한을 체크하는 함수 private fun checkPermissions(permissions: Array&lt;String&gt;): Boolean = permissions.all { it: String ContextCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_GRANTED } private fun onStartSubActivity() { // 권한이 거부된 경우 Dialog 생성 if (!checkPermissions(permissions)) { val alert = AlertDialog.Builder(this) alert.apply { setTitle(\"권한 설정\") setMessage(\"권한 거절로 인해 일부 기능이 제한될 수 있습니다.\") setPositiveButton(\"권한 설정하러 가기\") { _, _ -&gt; try { // 권한이 없을 때 \"애플리케이션 정보\" 화면으로 이동 val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS) .setData(Uri.fromParts(\"package\", packageName, null)) startActivity(intent) } catch (e: ActivityNotFoundException) { e.printStackTrace() // 나의 Application을 못찾았을 때 -&gt; \"애플리케이션\" 목록 페이지로 이동 val intent = Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS) startActivity(intent) } } setNegativeButton(\"취소\") { dialog, _ -&gt; // 권한이 거부 되었을 경우 dialog.dismiss() } create() show() } return } // 권한을 승인한 경우 SubActivity로 이동 startActivity(Intent(this, SubActivity::class.java)) }}" }, { "title": "Android Intent 에 관하여", "url": "/posts/Android-Intent/", "categories": "Android, Intent", "tags": "android, intent", "date": "2022-07-15 14:48:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.지난번 포스팅에서는 Android 4대 Component 에 대하여 쭉 알아 보았습니다.오늘은 Android 4대 Component 간에 통신에 사용되는 Intent에 대하여 알아보도록 하겠습니다.Intent는 Application Component 간에 작업 수행을 위한 정보를 전달하는 역할을 합니다. 즉, Component 간의 “통신수단”이라고 이해하시면 되겠습니다.Intent에는 명시적 인텐트, 암시적 인텐트가 존재합니다.각각 무엇인지 알아보도록 하겠습니다.Intent 에 대한 간단 설명 Android Component 간 통신에 이용됩니다. Component에 Action, Data 등을 전달합니다. Intent를 통하여 다른 Application의 Component를 활성화 시킬 수 있습니다. 가장 많이 사용하는 예로는 Activity간의 화면 전환이 있습니다.Explicit Intent(명시적 인텐트) 명시적 인텐트는 일반적으로 Activity, Service같은 Component를 시작할 때 사용됩니다. 참고 : 실행하고자 하는 Activity 또는 Service의 class name을 사용하는 형태를 의미합니다. private startMainActivity() { val intent = Intent(this@IntroActivity, MainActivity::class.java) startActivity(intent)} Implicit Intent(암시적 인텐트) 특정 구성 요소의 class name을 알아야 할 필요는 없지만, 수행할 작업을 선언하여 다른 앱의 구성 요소가 이를 처리할 수 있도록 할 때 사용하는 Intent 입니다. binding.startGoogleWeb.setOnClickListener { // Google 브라우저를 띄워줍니다. val intent = Intent(Intent.ACTION_VIEW, Uri.parse(\"http://www.google.com\")) startActivity(intent)} " }, { "title": "Android 4대 컴포넌트 중 ContentProvider 에 대하여", "url": "/posts/Android-ContentProvider/", "categories": "Android, 4 Component", "tags": "contentProvider, android, contentResolver", "date": "2022-07-15 10:32:00 +0900", "snippet": "안녕하세요. Narvis2입니다.지난 포스팅에서는 BroadcastReceiver에 대하여 알아보았습니다.이번 포스팅에서는 지난 시간에 이어 Android 4대 Component 중 하나인 ContentProvider에 관하여 알아보도록 하겠습니다.ContentProvider는 Application 사이에서 Data를 공유하는 통로 역할을 합니다. 즉, Android System의 각종 설정값이나 DB에 접근하게 해줍니다.여기에 이어 ContentResolver라는 녀석이 나오는데 이 녀석은 ContentProvider는 미리 만들어져 있는 ContentProvider로 부터 데이터를 가져오는 도구 라고 생각하시면 됩니다.간단하게 요약하면 ContentProvider는 Android System 의 각종 설정값이나 DB에 접근하게 해주고 ContentResolver는 그 결과 값을 가져오는 역할 입니다.ContentProvider Application의 Data를 다른 Application과 공유하는 것을 도와줍니다. 나의 Application 이 ContentProvider를 구현하여 제공하면, 다른 Application들은 ContentResolver를 통하여 나의 Application 에 구현된 ContentProvider에 접근할 수 있습니다. 다른 Application들은 ContentProvider가 제공하는 API들을 이용하여 데이터를 읽거나 저장, 삭제 할 수 있습니다.물론 내부적으로 SQLite와 같은 Database를 사용하여 Data를 관리해야 합니다. ContentProvider는 다른 Application과 Data를 공유하기 위한 인터페이스라고 이해하시면 됩니다.ContentResolver ContentProvider 가 제공하는 Data를 가져오기 위해 ContentResolver를 사용합니다. “미리 만들어져 있는 ContentProvider로 부터 Data를 가져오는 도구”라고 이해하시면 됩니다. Application이 ContentProvider에 접근할 때는 ContentResolver를 통해 접근하게 됩니다. 기본적으로 CRUD 함수를 제공합니다.(다른 Application의 Database를 조작할 수 있습니다.) 주로 Android에 있는 연락처, 갤러리, 음악 파일과 같은 기본 데이터를 가져오는 용도로 사용됩니다. 참고 : Android는 Media 정보를 저장하는 저장소 용도로 MediaStore을 사용합니다. ContentProvider, ContentResolver 를 통해 Image를 가져오기ContentResolver를 통하여 갤러리에 접근하여 원하는 Image를 가져오는 예제를 작성해 보겠습니다. MediaStore에서 이미지를 가져오기 private fun onAttachFileClick() { // Android 의 4대 Component 의 통신은 Intent로 합니다. val intent = Intent(Intent.ACTION_PICK).apply { this: Intent type = MediaStore.Images.Media.CONTENT_TYPE type = \"image/*\" } startIntentImage.launch(intent) } ContentResolver를 통하여 Image 가져오기 private val startIntentImage: ActivityResultLauncher&lt;Intent&gt; = registerForActivityResult( ActivityResultContracts.StartActivityForResult() ) { result: ActivityResult -&gt; result.data?.extras?.clear() val data = result.data?.data if (data != null &amp;&amp; result.resultCode == AppCompatActivity.RESULT_OK) { val context = binding.imageView.context val bitmap = MediaStore.Images.Media.getBitmap( context.contentResolver, data ) // Bitmap 의 비율을 지정합니다. val ratio = if (max(bitmap.width.toDouble(), bitmap.height.toDouble()) &gt; 1270) { when { bitmap.width &gt; bitmap.height -&gt; { 1270.0 / bitmap.width.toDouble() } else -&gt; { 1270.0 / bitmap.height.toDouble() } } } else { 1.0 } val width = (bitmap.width.toDouble() * ratio).toInt() val height = (bitmap.height.toDouble() * ratio).toInt() Glide.with(context) .asBitmap() .load(bitmap) .override(width, height) .centerCrop() .into(object : CustomTarget&lt;Bitmap&gt;() { override fun onResourceReady( resource: Bitmap, transition: com.bumptech.glide.request.transition.Transition&lt;in Bitmap&gt;?, ) { // 해당 함수를 통해 Custom 된 Bitmap을 ImageView에 넣습니다. BindingAdapters.loadBitmapCorner( view = binding.imageView, bitmap = resource, corner = 5, placeHolder = R.drawable.round_frame_gray_5 ) // bitmap 과 Glide 의 load에 넣었던 bitmap이 다른 경우 bitmap을 지웁니다. if (bitmap != resource) { bitmap.recycle() } } override fun onLoadCleared(placeholder: Drawable?) {} }) } } loadBitmapCorner() 함수 DataBinding을 위한 BindingAdapter를 사용한 함수입니다. @BindingAdapter(value = [\"loadBitmapCorner\", \"corner\", \"placeholder\", \"error\", \"mask\"])fun loadBitmapCorner( view: ImageView, bitmap: Bitmap, corner: Int = 0, @DrawableRes placeholder: Int = 0, @DrawableRes error: Int = 0) { val arrayList = arrayListOf&lt;Transformation&lt;Bitmap&gt;&gt;() arrayList.add(CenterCrop()) // image의 Corners 를 지정해줍니다. if (corner != 0) { arrayList.add(RoundedCorners(corner.pxToDp(view.context))) } val options = RequestOptions() .transform(*(arrayList.toTypedArray())) // 이미지 load에 실패한 경우 error에 저장된 이미지를 보여줍니다. @SuppressLint(\"CheckResult\") if (error != 0) { options.error(error) } Glide.with(view.context) .setDefaultRequestOptions(options) .load(bitmap).apply { // placeHolder -&gt; 요청받은 이미지가 나타나기 전까지 지정한 이미지를 보여줍니다. // 네트워크로 이미지를 요청하거나 큰 이미지를 요청하여 시간이 오래 걸릴 때 PlaceHolder로 지정한 이미지를 보여줍니다. @SuppressLint(\"CheckResult\") if (placeholder != 0) { apply(options.placeholder(placeholder)) } } .into(view)} 마치며이번 포스팅에서는 ContentProvider, ContentResolver에 대하여 알아보았습니다.이번 포스팅을 요약하자면 ContentProvider 가 제공하는 Data를 가져오기 위해 ContentResolver를 사용하며 Application이 ContentProvider에 접근할 때는 ContentResolver를 통해 접근하게 됩니다.다음 포스팅에서는 Android 4대 Component 간에 통신을 위해 사용하는 Intent에 대하여 알아보도록 하겠습니다." }, { "title": "Android 4대 컴포넌트 중 BroadcastReceiver 에 대하여", "url": "/posts/Android-BroadcastReceiver/", "categories": "Android, 4 Component", "tags": "broadcastReceiver, android", "date": "2022-07-15 08:34:00 +0900", "snippet": "안녕하세요. Narvis2입니다.지난번에 Android4 대 Component 중 하나인 Service에 대하여 알아보았습니다.이번 시간에는 Android 4대 Component(Activity, ContentProvider, BroadcastReceiver, Service) 중 하나인 BroadcastReceiver에 대하여 알아보겠습니다.BroadcastReceiver 는 이름에서 알 수 있듯이 “방송”이라고 생각하시면 됩니다.예를 들어 전화, 문자 등 어떤 행위가 왔다는 알림을 받고 처리할 수 있습니다. 밑에서 더욱 자세한 내용을 알아보도록 하겠습니다.BroadcastReceiver 전화, 문자 등 어떤 행위가 왔다는 알림을 받고 이것을 알려주는 기능입니다.예를 들어 Android System은 System “부팅”, “기기 충전” 시작과 같은 다양한 System Event가 발생할 때 Broadcast 를 전송합니다.이 Broadcast는 Intent를 통해 발송하게 되고, 이렇게 발송된 Broadcast는 BroadcastReceiver 객체가 수신하게 됩니다. BroadcastReceiver는 Broadcast가 발생하면 Intent-Filter를 통해 원하는 Intent만 수신할 수 있습니다. 참고 : AndroidManifest에 Receiver를 등록하고 Intent-Filter를 통해 원하는 Intent에 대해서만 알림을 받을 수 있습니다. 즉, 수많은 Broadcast 중에서 어떤 것을 수신할 것인지 등록하는 과정이라 할 수 있습니다. BroadcastReceiver는 복잡성이 낮고 Process간의 가장 쉬운 통신 방법입니다. One to All 통신으로 모든 수신자에게 동시에 메시지를 전송합니다.(Android OS 기반 응용 프로그램 구성 요소간의 통신) 따라서 보안 위협이 발생 가능합니다. 그 이유는 민감한 데이터는 방송되어서는 안되기 때문입니다. 참고 : Process 간 통신을 위해 BroadcastReceiver를 사용하면 이러한 보안 위협이 발생할 수 있습니다. 이런 경우 BroadcastReceiver를 대신하여 AIDL을 사용합니다. 비동기 통신입니다.onReceive() 간단하게 “내가 원하는 Broadcast를 고르는 곳” 이라고 생각하시면 됩니다. 즉, 원하는 Intent.action에 대한 처리를 담당하는 곳입니다. 항상 Main Thread 에서 실행합니다. Intent를 통해 Data를 보낼 때 Data 크기를 몇 KB로 제한 하도록 주의해야 합니다. 주의!! : 너무 많은 데이터를 보낼 경우 TransactionTooLargeException 이 발생할 수 있습니다.Intent는 최대 500Kb 크기의 Data를 전송할 수 있습니다. 대표적인 Broadcast 종류 ACTION_BOOT_COMPLERED : System 부팅이 끝났을 때(RECEIVE_BOOT_COMPLETED 권한 등록 필요 ACTION_CAMERA_BUTTON : 카메라 버튼을 눌렀을 때 ACTION_DATE_CHANGED, ACTION_TIME_CHANGED : 핸드폰의 날짜, 시간이 수동으로 변했을 때 즉, 설정에서 수정했을 때 ACTION_SCREEN_OFF, ACTION_SCREEN_ON : 화면 on, off ACTION_AIRPLANE_MODE_CHANGED : 비행기 모드 ACTION_BATTERY_CHANGED, ACTION_BATTERY_LOW, ACTION_BATTERY_OKAY : 베터리 상태 변화 ACTION_PACKAGE_ADDED, ACTION_PACKAGE_CHANGED, ACTION_PACKAGE_DATA_CLEARED, ACTION_PACKAGE_INSTALL, ACTION_PACKAGE_REMOVED, ACTION_PACKAGE_REPLACED, ACTION_PACKAGE_RESTARTED : 어플 설치 / 제거 ACTION_POWER_CONNECTED, ACTION_POWER_DISCONNECTED : 충전 관련 ACTION_REBOOT, ACTION_SHUTDOWN : 재부팅 / 종료 ACTION_TIME_TICK : 매 분마다 수신 android.provider.Telephony.SMS_RECEIVED : SMS 수신 (RECEIVE_SMS 권한 필요)BroadcastReceiver의 종류 Global Broadcast : 일반적으로 이야기하는 Broadcast 이며, Process 간의 경계를 무시하고 Android System 상에 등록된 모든 Receiver 들에게 전달됩니다. Local Broadcast : 현재 Process 안에만 유효한 Broadcast 입니다. 주로 Process 간의 통신에 사용됩니다.예를 들어 bindService를 통하여 Service -&gt; Activity/Fragment 간의 통신에 LocalBroadcastReceiver를 사용할 수 있습니다. LocalBroadcastManager를 이용한 Process 통신에 대해 간단한 예제로 알아보겠습니다.1. BroadcastReceiver 등록private fun registerLocalBroadcastManager() { LocalBroadcastManager.getInstance(context).registerReceiver(broadcastReceiver, createIntentFilter())}Intent-Filterprivate fun createIntentFilter(): IntentFilter { // Action Type을 지정해 줍니다. 이 Type을 바탕으로 onReceive() 에서 action을 분류하여 처리합니다. return IntentFilter().apply { addAction(\"Test\") }}2. BroadcastReceiver 해제private fun unRegisterLocalBroadcastManager() { LocalBroadcastManager.getInstance(context).unregisterReceiver(broadcastReceiver)}3. BroadcastReceiver에 Intent 전달private fun sendTestBroadcast() { val message = \"test 입니다.\" val intent = Intent(\"Test\") intent.putExtra(\"TestData\", message) LocalBroadcastManager.getInstance(context).sendBroadcast(intent)}4. Broadcast 를 수신하는 쪽 onReceive()Activity/Fragment 의 상태 공유를 위해 AndroidViewModel() 을 사용하여 AndroidViewModel 안에 해당 코드 작성// 객체 지향을 지켜 내부에서는 값을 넣을 수 있고, 외부에서는 값을 못넣고 가져올수만 있도록 합니다.private val _testEvent = MutableLiveData&lt;String&gt;()val testEvent: LiveData&lt;String&gt; get() = _testEvent// BroadcastReceiver 생성private val broadcastReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { // intent가 null 이 아닐때만 밑에 로직이 실행됩니다. null 일 경우 Timber를 이용하여 Error Log를 남깁니다. intent?.let { it: Intent // intent 내부의 data가 null이 아닐때만 밑의 로직을 실행합니다. null 일 경우 Timber를 이용하여 Error Log를 남깁니다. it.getStringExtra(\"TestData\")?.let { data: String -&gt; when (it.action) { \"Test\" -&gt; { // TODO : 값을 StateFlow, LiveData에 넣고 적절한 곳에서 Observing 혹은 직접 처리 _testEvent.postValue(data) } } } ?: Timber.e(\"onReceive data is null.\") } ?: Timber.e(\"onReceive intent is null.\") }}5. Activity, Fragment 에서 해당 Event를 Observing Activity에서 Observing class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding // activityX 를 이용한 ViewModel 생성 // 해당 by viewModels()를 사용하기 위해서는 build.gradle(app)에 androidX 의존성을 추가하셔야 합니다. private mainViewModel: MainViewModel by viewModels() override fun onCreate(saveInstanceState: Bundle?) { binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this mainViewModel.testEvent.observe(this) { it: String Toast.makeText(this, it, Toast.LENGTH_SHORT).show() } }} Fragment에서 Observing class HomeFragment : Fragment() { private lateinit var binding: FragmentHomeBinding // fragmentX 를 이용한 ViewModel 생성 (Activity에 있는 MainViewModel 공유) // 해당 by activityViewModels()를 사용하기 위해서는 build.gradle(app)에 fragmentX 의존성을 추가하셔야 합니다. private mainViewModel: MainViewModel by activityViewModels() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = DataBindingUtil.inflate(inflater, layoutResId, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.lifecycleOwner = viewLifecycleOwner mainViewModel.testEvent.observe(viewLifecycleOwner) { it: String Toast.makeText(requireContext(), it, Toast.LENGTH_SHORT).show() } }} 6. LocalBroadcastManager 관련 전체 코드class MainViewModel(application: Application) : AndroidViewModel(application) { private val context = application // StateFlow, SharedFlow 를 사용하셔도 무방합니다. // 저는 요즘 StateFlow, SharedFlow, Coroutine Channel 을 사용하지만 여기서는 간단한 예를 위해 LiveData를 사용하였습니다. private val _testEvent = MutableLiveData&lt;String&gt;() val testEvent: LiveData&lt;String&gt; get() = _testEvent // LocalBroadcastManager 등록 private fun registerLocalBroadcastManager() { LocalBroadcastManager.getInstance(context.applicationContext).registerReceiver(broadcastReceiver, createIntentFilter()) } // Intent-Filter 생성 // Kotlin Type 추론에 의하여 반환값을 적어주지 않으셔도 되지만 이해를 돕기위해 반환값을 명시적으로 적었습니다. private fun createIntentFilter(): IntentFilter = IntentFilter().apply { // 여기서는 action Type 하나 뿐이라 하드 코딩을 하였지만, // type이 여러개일 경우 enum class를 활용하는 것이 좋습니다. addAction(\"Test\") } // LocalBroadcastManager 해제 private fun unRegisterLocalBroadcastManager() { LocalBroadcastManager.getInstance(context.applicationContext).unregisterReceiver(broadcastReceiver) } // BroadcastReceiver에 Intent 전달하는 함수 private fun sendTestBroadcast() { // 여기서는 간단한 예를 들기 위해 String 값을 넣었으나 // 직렬화를 통해 객체를 String으로 바꿔서 넘기고 onReceive() 에서 역직렬화를 통해 String을 객체로 바꿔 사용할 수 있습니다. val message = \"test 입니다.\" val intent = Intent(\"Test\") intent.putExtra(\"TestData\", message) LocalBroadcastManager.getInstance(context.applicationContext).sendBroadcast(intent) } // BroadcastReceiver 생성 private val broadcastReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { // intent가 null 이 아닐때만 밑에 로직이 실행됩니다. null 일 경우 Timber를 이용하여 Error Log를 남깁니다. intent?.let { it: Intent // intent 내부의 data가 null이 아닐때만 밑의 로직을 실행합니다. null 일 경우 Timber를 이용하여 Error Log를 남깁니다. it.getStringExtra(\"TestData\")?.let { data: String -&gt; when (it.action) { \"Test\" -&gt; { // TODO : 값을 StateFlow, LiveData에 넣고 적절한 곳에서 Observing 혹은 직접 처리 _testEvent.postValue(data) } } } ?: Timber.e(\"onReceive data is null.\") } ?: Timber.e(\"onReceive intent is null.\") } }}마치며이번 사간에는 BroadcastReceiver에 대하여 알아보았습니다.BroadcastReciver는 Android 4대 컴포넌트 중 하나이며 핸드폰의 각가지 Event와 Process간의 통신에도 사용됩니다.핸드폰의 각가지 Event를 수신할 때는 Global BroadcastReceiver 즉, 일반 BroadcastReceiver를 사용하고 Process간 통신에 사용할 경우 LocalBroadcastManager를 사용합니다.저는 Service -&gt; Fragment/Activity 통신에 있어 LocalBroadcastManager 를 사용 하였으며, 요즘에는 BroadcastReceiver의 혹시 모를 보안상 문제를 해결하기 위해 AIDL 을 사용하여 Process 통신을 하고 있습니다.최대한 이해를 돕기위해 실무적인 코드를 보여드리고 설명 드렸습니다.도움이 되셨길 바라며, 다음에는 Android 4대 컴포넌트 중 하나인 “ContentProvider”에 관한 포스팅으로 돌아오겠습니다.Android 4대 Component Service 참고 Activity의 Lifecycle 참고" }, { "title": "Android 4대 컴포넌트 중 Service 에 대하여", "url": "/posts/Android-Service/", "categories": "Android, 4 Component", "tags": "android, service, bind, foregorund", "date": "2022-07-14 16:56:00 +0900", "snippet": "안녕하세요. Narvis2 입니다.오늘은 Android 4대 Component(Activity, ContentProvider, BroadcastReceiver, Service) 중 하나인 Service에 대하여 알아볼까 합니다.안드로이드 Document에 따르면 Service의 주된 목적은 오래 걸리는 작업을 백그라운드에서 처리하라고 적혀있습니다.저는 현 직장에서 실시간 채팅 기능을 위한 Socket 통신에 Bind Service를 사용하고 있습니다.Service의 종류로는 Background, Bound, Foreground가 있으며 Background Service부터 알아보겠습니다.Background Service 사용자에게 직접 보이지 않는 작업을 수행할때 사용합니다. 작업을 수행하고 결과를 호출자에게 반환하지 않습니다. Application을 종료해도 Background Service는 계속 수행할 수 있습니다. 압축과 같은 작업을 할때 사용하며 Service가 Background 에서 장시간 실행 중이면 소멸 가능성이 높습니다. 주의!! API 26 부터는 Background Service에 대하여 여러가지 제약이 걸렸습니다. Bound Service (Bind Service) 바인딩을 위한 Service 입니다. Service는 모든 바인딩이 해제되면 System에 의해 소멸됩니다. Activity / Fragment 와 Service 간에 데이터를 주고 받을 수 있고 Process간 통신에도 사용됩니다. Activity / Fragment -&gt; Service 간의 통신에 보통 다음 3가지를 많이 사용합니다. BroadcastReciever Handler AIDL (AIDL 은 BroadcastReciever 보다 보안상 우위에 있습니다.)AIDL 에 관한 내용은 향후 따로 포스팅을 작성하도록 하겠습니다. Foreground Service 현재 서비스의 동작이나 상황을 유저에게 계속 알려주어야 하는 상황에서 유용합니다. 사용자가 다른 앱을 사용 중이라도 계속해서 실행 되도록 합니다. 소멸 가능성이 희박하며, notifictaion 알림을 10초안에 띄워야 합니다. (그렇지 않으면 Android에서 Service를 죽입니다.)Service Lifecycle startService() 의 경우 -&gt; onCreate() -&gt; onStartCommand() -&gt; Service가 스스로 혹은 Client에 의해 중단됨 -&gt; onDestory() bindService() 의 경우 -&gt; onCreate() -&gt; onBind() -&gt; onUnbind() -&gt; onDestory() 1. onCreate() Service가 생성될때 최초로 호출되는 메서드 입니다. 해당 메서드에서 초기 설정을 수행하시면 됩니다. Service가 이미 실행중이면 onCreate()는 호출되지 않습니다. 2. onStartCommand() startService()로 Service가 시작될 때 호출됩니다. startService()를 통해 전달한 Intent를 onStartCommand()에서 Service가 수신하게 됩니다. 작업이 완료되면 stopSelf()를 호출하여 스스로 중단 하거나, 다른 컴포넌트가 stopService()를 호출하여 중단 시킬 수 있습니다. Binding만 제공하고자 하는 경우에는 onStartCommand()를 구현하지 않아도 됩니다. onStartCommand() 호출을 한번이라도 받은 Service는 Lifecycle을 직접 관리 및 중단해야 합니다. onStartCommand() 의 Return 값 -&gt; Service가 System 에 의해 소멸된 경우, Service가 다시 시작할지 여부를 결정합니다. START_REDELIVER_INTENT : System이 Service를 중단하면 Service를 다시 생성합니다. 파일 다운로드와 같은 Service에 적합합니다. START_STICKY : 시스템이 Service를 중단하면 Service를 다시 생성합니다. 마지막 Intent를 전달하지 않고, null Intent로 onStartCommand()를 호출합니다. 명령을 실행하진 않지만 작업을 기다리는 Media Player와 같은 Service에 적합합니다. START_NOT_STICKY : System이 Service를 중단하면 Service를 재생성하지 않습니다. 다시 시작하려는 경우에 적합합니다. 3. onBind() 다른 구성 요소(Activity/Fragment)와 Service를 바인딩 하려는 경우에 사용합니다. 즉, Service 와 Activity / Fragment 사이에서 데이터를 주고 받을 때 사용합니다. bindService()로 시작합니다. 구현할때 Interface를 제공해야 합니다. reutrn으로 IBinder를 반환하면 됩니다. 다른 구성요소가 Service에 Bind 하고자 하는 경우, Client 가 Service와 통신을 주고받기 위해 사용할 인터페이스를 제공해야 합니다. AIDL 사용시 Stub() 구현체를 Return 하면 된다. Handler 사용시 Messanger(Handler(mainLopper, this)).binder 를 반환합니다. 이 메서드는 항상 구현해야 하며, 사용하지 않을 때는 return null 을 하시면 됩니다. 4. onUnBind() 모든 Client 들이 unBindService()를 호출하여 binding이 해지되었을 때 호출됩니다. 5. onReBind() unBindService() 가 호출된 이후에, Client가 bindService()를 호출하여 Service에 binding 될 때 호출됩니다. 6. Destory() Service가 해지될 때 호출 됩니다. Resource 해지를 수행합니다. 번외 - PendingIntent Notification 으로 작업을 수행할 때 Intent가 실행되도록 합니다.(Notification 으로 Intent 수행 시 PendingIntent 사용이 필수) 참고 런처 바탕화면의 위젯으로 Intent 작업을 수행할때 PendingIntent를 사용합니다. Alarm Manager를 통해 지정된 시간에 Intent가 실행되도록 할때 PendingIntent를 사용합니다. 생성 Activity를 시작하는 Intent -&gt; PendingIntent.getActivity(context: Context, requestCode: Int, intent: Intent, flags: Int) Service를 시작하는 Intent -&gt; PendingIntent.getService(context: Context, requestCode: Int, intent: Intent, flags: Int) BroadcastReciver를 시작하는 Intent -&gt; PendingIntent.getBroadcast(context: Context, requestCode: Int, intent: Intent, flags: Int) Flag FLAG_UPDATE_CURRENT : PendingIntent가 이미 존재하는 경우, Extra Data를 새로운 Intent에 있는 것으로 대체합니다. FLAG_CANCEL_CURRENT : PendingIntent가 이미 존재하는 경우, 기존 PendingIntent를 Cancel 하고 다시 생성합니다. FLAG_IMMUTABLE : 기존 PendingIntent는 변경되지 않고, 새로운 데이터를 추가한 PendingIntent를 보내도 무시합니다. FLAG_NO_CREATE : PendingIntent가 기존에 존재하지 않으면 Null을 반환합니다. FLAG_ONE_SHOT : 한번만 사용할 수 있는 PendingIntent fun makePendingIntent(): PendingIntent { // RequestCode, Id를 고유값으로 지정하여 알람이 개별 표시되도록 설정 val uniId: Int = (System.currentTimeMillis() / 1000).toInt() val intent = Intent(context, MainActivity::class.java) return PendingIntent.getActivity( context, uniId, intent, if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT } else { PendingIntent.FLAG_UPDATE_CURRENT } ) } 마무리이번 시간에는 Service에 대하여 알아보았습니다.저는 Service를 Socket 연결을 위해 Bind Service를 주로 사용하였고, AIDL 을 통해 Process 통신을 했습니다.AIDL에 대한 설명은 추후 따로 포스팅을 올리겠습니다.다음 포스팅은 Android 4대 컴포넌트 중 하나인 BroadcastReceiver 에 대하여 알아보는 시간을 가지도록 하겠습니다.Android 4대 Component BroadcastReceiver 참고 Activity의 Lifecycle 참고" }, { "title": "Android Process 및 Thread", "url": "/posts/Android-Process-Thread/", "categories": "Android, Process", "tags": "android, process, thread", "date": "2022-07-14 15:20:00 +0900", "snippet": "이번 포스팅에서는 Android의 Process와 Thread에 대해서 알아보고자 합니다.이번에는 설명이 많이 필요하여 지루하실 수 있습니다.빠르게 시작해보겠습니다.Process 와 Thread애플리케이션 구성 요소가 시작되고, 앱에 실행중인 다른 구성 요소가 없으면 하나의 실행 Thread로 앱의 Linux Process를 시작합니다.기본적으로 같은 애플리케이션의 모든 구성 요소는 같은 Process와 Thread에서 실행됩니다. 하지만 구성 요소가 각자 별도의 Process에서 실행 되도록 할 수 있고, 어느 Process든 추가 Thread를 만들 수 있습니다.Process (프로세스) 기본적으로 같은 앱의 모든 구성 요소는 Process와 Thread에서 실행되고 이를 바꾸면 안됩니다. 그러나 어느 Process가 특성 구성 요소에 속하는지 확인해야 할 경우 AndroidManifest 파일에서 확인 가능합니다.(android:process 속성) AndroidManifest에서 android:process 속성을 설정하여 구성요소가 실행되는 Process를 지정할 수 있습니다.지원하는 요소 : application, activity, service, receiver, provider Android System 에서는 어느 Process를 삭제할지 결정할때, 이들의 상대적 중요성을 가늠하여 우선 순위가 낮은 Process부터 삭제합니다. (메모리가 부족할 때 종료해야 하는 Process를 결정하기 위해 Android는 중요도에 따라 Process들을 유형별로 계층 구조에 배치합니다.)Process Lifecycle / 중요도가 높은 순으로 정리 안드로이드 시스템은 Process에서 실행되는 구성요소와 해당 구성요소의 상태에 기초하여 각 Process에 “중요계층”을 보여합니다. 중요도가 낮은 Process가 먼저 제거됩니다.1. Foreground Process (포그라운드 프로세스) 사용자가 현재 진행하는 작업에 필요한 Process입니다.(Activity 나 Foreground Service) 사용자가 상호작용하는 Activity를 호스팅할 경우 사용자와 상호작용하는 Activity에 Bind 된 Service를 호스팅할 경우 (bindService()) Foreground 에서 실행되는 Service를 호스팅할 경우 (ForegroundService, startForeground()) Lifecycle Call back 중 하나를 실행하는 Service를 실행할 경우 (onCreate(), onstart() 또는 onDestory()) 아래의 하나라도 해당되면 Process가 Foreground 에 있는 것으로 간주합니다. Process가 사용자와 상호작용하고 있는 화면에서 Activity 실행중인 경우 Process가 현재 실행중인 BroadcastReceiver가 있는 경우 Process에 Call back 중 하나에서 현재 코드를 실행중인 Service 가 있을 경우 2. Visible Process (가시적 프로세스) Foreground 구성 요소는 없지만 사용자가 화면에서 보는 것에 영향을 미칠 수 있는 Process 입니다. Process가 화면상으로는 사용자에게 표시되지만, Foreground에 있지 않은 Activity가 실행 중(onPause() 메서드가 호출된 상태)예를 들어 Foreground Activity 대화상자로 표시되고, 이 대화상자에서 Forground Activity 뒤에 이전 Activity가 보이는 때 Process에 Service.startForground()를 통해 Foreground Service로 실행중인 Service가 있는 경우 Process가 System에서 라이브 배경화면, 입력 방법 서비스 등과 같이 사용자가 알고 있는 특정 기능에 사용하는 서비스를 호스팅할 경우3. Service Process (서비스 프로세스) startService() 메서드로 시작된 Service를 유지하는 Process 입니다. 사용자에게 직접 표시되지는 않지만 일반적으로 사용자가 관심을 가진 작업을 실행합니다. System은 모든 Foreground Process 및 Visible Process를 유지할 메모리가 부족하지 않다면 항상 이 Process의 실행 상태를 유지합니다.4. Cached Process (빈 프로세스) 현재 필요하지 않는 Process 입니다. System은 다른 곳에서 메모리가 필요할 때 언제든 원하는 대로 이 Process를 종료합니다. 정상적으로 작용하는 System에서 Chaned Process는 메모리 관리와 관련된 유일한 Process 입니다. 현재 사용자에게 표시되지 않는 하나 이상의 Activity 인스턴스를 포함합니다. Activity Lifecycle 을 올바르게 구현하면 System이 이런 Process를 종료해도 앱으로 돌아갈때 사용자 환경에 영향을 주지 않습니다. LRU 목록으로 유지되며, 메모리 회수 시 목록의 마지막 Process가 제일 처음 종료됩니다.Thread (쓰레드) 앱이 시작되면 앱에 대한 실행의 Thread를 생성하며, 이를 Main Thread 혹은 UI Thread라고 합니다. 이 Thread는 이벤트를 포함한 UI 위젯에 이벤트를 발송하는 역할을 맡기도하여 UI Thread라고도 합니다. (UI 조작 작업은 UI Thread에서만 이루어져야 합니다.) 같은 Process에서 실행되는 모든 구성 요소는 UI Thread에서 시작되고, 구성 요소를 호출하는 System이 해당 Thread에서 발송됩니다. Network Access나 Database Query 등의 긴 작업을 UI Thread에서 수행할 경우 전체 UI 이벤트가 차단되어 사용자에게는 애플리케이션이 중단된 것 처럼 보입니다.(해당 상태를 ANR이라고 합니다.) Android System은 UI Thread가 몇 초 이상 차단되면(현재는 약 5초) 사용자에게 Application Not Response(ANR) 이라는 대화상자가 표시되고, Application이 종료되거나 블만족에 의해 제거될 수 있습니다. Android Ui Tool kit은 Thread Safe 하지 않기 떄문에 UI를 Worker Thread에서 조작하면 안됩니다.(IOException 발생)Worker Thread UI 반응성을 위해 UI Thread를 차단하지 않는 것이 매우 중요하며, UI Update를 제외하고 시간이 소요되는 작업은(Network, Database) 반드시 별도의 Thread 에서 수행해야 합니다. 이 별도의 Thread를 Background Thread 또는 Worker Thread라고 합니다. 다른 Thread 에서 UI Thread에 Access 하기 위해 제공하는 방식 Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 위의 방법을 사용하기에 복잡한 작업은 Handler를 사용하여 UI Thread에서 전달받은 메시지를 처리하는 방안을 고려해야 합니다.Handler, Looper 정리 참조 Thread-Safe 어떤 경우에는 구현하는 메서드가 하나 이상의 Thread에서 호출되는 일이 있어 안전하게 작성해야 합니다. 주로 원격으로 호출할 수 있는 메서드가 이에 해당합니다.(bindService 등..) IBinder 에서 구현된 메서드가 IBinder가 실행되는 Process 에서 호출될 경우, 해당 메서드는 호출자의 Thread에서 실행됩니다.이 호출이 다른 Process에서 발생하면, 해당 메서드는 System이 IBinder와 같은 Process에 유지하는 Thread Pool에서 선택된 Thread에서 실행됩니다.(Process의 UI Thread에서 실행되지 않음.) 이 같은 이유로 Thread로 부터 안전한 구현이 필요합니다." }, { "title": "Android Handler, Looper 에 관하여", "url": "/posts/Android-handler-looper/", "categories": "Android, Handler", "tags": "android, thread, handler, looper", "date": "2022-07-14 11:44:00 +0900", "snippet": "이번에는 Handler, Looper 에 대해서 알아보도록 하겠습니다.Android의 UI 처리는 Single Thread Model로 동작합니다. 즉, mainThread가 아닌 다른 Thread에서 UI 를 Update하는 등의 행위를 하면 안됩니다. 따라서 mainThread를 UI Thread라고 부르기도 합니다.동작의 무결성을 보장하기 위해 타 Thread에서는 UI를 건드릴 수 없고, 오로지 Main Thread에서만 UI 관련 동작을 할 수 있게끔 합니다.(MainThread를 제외한 다른 Thread에서 UI Update시 IOException이 발생합니다.)이때 시간이 오래걸리는 작업을 MainThread에서 하게되면 UI가 멈추게 되는데(ANR) 이를 방지하기 위해 시간이 오래걸리는 작업은 다른 Thread에서 하고, 해당 결과를 Main Thread에 넘겨줘서 Main Thread에서 해당 결과 값을 바탕으로 UI를 Update합니다. Android에서는 UI Thread가 몇 초 이상 차단되면(현재는 약 5초) 사용자에게 Application Not Response(ANR) 이라는 대화 상자가 표시되고, 어플리케이션이 종료 되거나 불만족에 의해 제거 될 수 있습니다.여기서 다른 Thread -&gt; Ui Thread 간에 결과값을 넘겨줄 때 통신을 위해서 즉, Thread 간의 통신을 위해 사용하는 것이 Handler 와 Looper 입니다. UI 반응성을 위해 UI Thread를 차단하지 않는 것이 매우 중요하며, UI Update를 제외하고 시간이 소요되는 작업은 반드시 별도의 Thread에서 수행해야 하는데 이 별도의 Thread를 Background Thread 또는 Worker Thread라고 합니다.이번에도 실용적인 측면에 초점을 두고 다루겠습니다.간단한 용어 설명 Thread, Main ThreadThread에 대해 간단히 설명드리면 “하나의 독립된 실행 흐름” 이라고 생각하시면 됩니다.mainThread는 하나의 프로그램이 실행될때 최초로 실행되는 Thread라고 생각하시면 됩니다.다른 Thread -&gt; UI Thread에 Access 하기 위해 제공하는 방식 Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 위의 방법을 사용하기에 복잡한 작업은 Handler를 사용하여 UI Thread에서 전달받은 Message를 처리하는 방안을 고려해야 합니다.Looper 하나의 Thread 당 단 하나의 Looper만 가질 수 있습니다. Android에선 기본적으로 MainActivity가 실행됨과 동시에 자동으로 Main Thread의 Looper가 돌기 시작합니다. 각 Thread의 Looper 내부에는 MessageQueue 라는 것이 존재하는데, 여기에는 해당 Thread가 처리해야 할 동작들이 ‘Message’ 라는 형태로 하나씩 쌓이게 됩니다. (큐 라는 이름에서 알 수 있듯 당연히 FIFO 방식이며 선입선출 방식으로 처리됩니다.) Queue에 대해 모르시면 자료구조 Stack, Queue 정리 포스팅을 참고 해주세요. MessageQueue가 비어있을 때는 아무런 동작도 하지 않다가 Message가 들어오면 Message를 꺼내 적절한 Handler로 전달합니다. Thread에서 무한히 돌면서 자신이 속한 Thread의 MessageQueue에 Message나 Runnable이 들어오면 차례대로(선입선출) Handler에 전달하는 역할을 합니다.Message “하나의 작은 작업 단위”, MessageQueue에는 이러한 작은 작업 단위를 하나씩 적재해두고, “Looper”가 이를 차례대로 처리한다. Thread간 통신 할 내용을 담는 객체이자 MessageQueue의 일감 단위라고 생각하시면 됩니다. Message는 Runnable, “Message” 2가지가 있습니다. Looper 객체가 MessageQueue에서 Message를 확인했을 때 Runnable 객체가 담겨져 있으면 Handler에 Message를 전달하지 않고 run()함수를 실행하여 해당 Runnable 작업을 바로 시작하고, Runnable 객체가 없을 경우 Message 객체 내부에 있는 Handler의 handleMessage()를 수행하여 처리합니다. Runnable은 Thread를 생성할때 생기는 run() 메서드를 따로 분리시킨 형태로 run() 추상 메서드를 반드시 구현해야합니다. run()함수 안에 실행될 동작이 들어갑니다.Handler Looper로 부터 전달 받은 Message 나 Runnable을 handleMessage()를 통해 처리하거나 다른 Thread로 부터 받은 Message를 MessageQueue에 넣습니다. Handler를 생성하게되면 호출한 Thread의 MessageQueue와 Looper에 자동으로 연결됩니다. Message 객체를 생성하여 이를 전달하는 방식으로 구현합니다. sendMessage() 메소드를 통해 MessageQueue에 Message 객체를 적재할 수 있습니다. post로 시작하는 메소드들을 통해 Runnable 객체를 직접 적재할 수 있습니다. UI를 갱신하기 위해서 사용합니다. 주의!! Handler를 상속받아서 처리하는 모든 부분에서 UI가 Destory 즉, 파괴될때 handler.removeCallbacksAndMessages(null)을 호출해줘야 합니다. 동작 방식 Handler 의 sendMessage()를 통해 MessageQueue에 Message를 차례대로 넣습니다. Looper는 무한히 돌면서 자신이 속한 Thread의 MessageQueue에 Message나 Runnable이 들어오면 차례대로 하나씩 MessageQueue에서 Message를 꺼내 적절한 Handler에게 전달합니다. Looper로 부터 Message를 전달받은 Handler는 handleMessage() 메서드를 통해 Message를 처리합니다.코드를 통해 살펴보기간다한 코드를 통해 살펴 보겠습니다. Handler 생성 (Message를 받는 쪽) 코드 부터 살펴보겠습니다. class HomeHandler(fragment: HomeFragment) : Handler(Looper.getMainLooper()) { private val weekReference: WeakReference(fragment) override fun handleMessage(msg: Message) { val fragment = weakReference.get() as HomeFragment // HomeFragment 의 함수를 사용하기 위해 apply 사용 (연속적으로 접근 할때는 apply, with 등을 사용하는 것이 좋습니다.) fragment.apply { this: HomeFragment when (msg.what) { FINISH_MAIN_ACTIVITY -&gt; { // this 는 생략 가능 여기서는 알아보기 쉽게 명시적으로 선언 // 여기서는 간단하게 부모 Activity를 종료 시키도록 하였습니다. this.finishActivity() } SHOW_SIMPLE_TOAST -&gt; { // this 는 생략 가능 여기서는 알아보기 쉽게 명시적으로 선언 this.showToast(msg.obj?.toString()) } // 등등.. } } } companion object { // 해당 변수로 Message를 구분합니다. const val FINISH_MAIN_ACTIVITY = 0 const val SHOW_SIMPLE_TOAST = 1 // 등등.. }} GC(Garbage Collector)는 “내가 다시 사용할 수 있냐, 없냐를 보고 없으면 쓰레기통에 버린다” 라고 생각하시면 편합니다. WeakReference : GC(Garbage Collector)가 발생되기 전까지는 참조를 유지하고 GC가 발생되면 무조건 회수 (짧은 시간, 자주 쓰일 수 있는 객체를 사용할때 유용하게 사용될 수 있음.) Message를 보내는 쪽 코드 (sendMessage()를 통해 Message 넣기) private val homeHandler = HomeHandler(this)// 함수 이름은 대충 지었습니다.fun sendMainActivityFinish() { homeHandler.obtainMessage().apply { this: Message what = HomeHandler.FINISH_MAIN_ACTIVITY obj = \"메인 엑티비티 종료\" // 전달하고자 하는 객체 넣기 (여기서는 간단하게 String을 넣어줬습니다.) homeHandler.sendMessage(this) }}fun sendShowToast() { homeHandler.obtainMessage().apply { this: Message what = HomeHandler.SHOW_SIMPLE_TOAST obj = \"안녕하세용\" // 전달하고자 하는 객체 넣기 (여기서는 간단하게 String을 넣어줬습니다.) homeHandler.sendMessage(this) }} sendMessage()를 통해 Message를 MessageQueue에 넣습니다. 이렇게 되면 Handler는 Looper 로 Message를 전달하고 Looper는 MessageQueue로 부터 해당 Message를 꺼냅니다. 이때 위의 코드에서는 Runnable이 없기 때문에 HomeHandler에게 Message를 전달합니다. Looper로 부터 Message를 전달받은 HomeHandler는 handleMessage()를 통해 Message를 처리합니다.참고 obtainMessage() : obtainMessage()는 Message 인스턴스를 생성합니다. 다만 정적으로 생성된 재사용 객체로 관리되기 때문에 new Message()로 인스턴스를 생성하는 것 보다 효율적 입니다. HomeFragment 의 handleMessage() 함수 내부에서 실행되는 HomeFragment의 함수 // HomeHandler 의 handleMessage() 에서 FINISH_MAIN_ACTIVITY 일때 호출하는 함수 fun activityFinish() { activity.finish() } // HomeHandler 의 handleMessage() 에서 SHOW_SIMPLE_TOAST 일때 호출하는 함수 fun showToast(msg: String) { Toast.makeText(requireContext(), msg, Toast.LENGTH_SHORT).show() } UI 가 Destory 될 때 handler 제거하는 코드 override fun onDestoryView() { castHandler.removeCallbacksAndMessages(null) super.onDestoryView() } Activity의 경우 onDestory() 에서 하시면 됩니다.주의!! UI 가 Destory 될 때 remove 해주지 않으면 IllegalStateException이 발생할 수 있습니다. Handler가 해당 Message를 가지고 있는지 확인하고 존재하면 제거하는 코드 private fun removeCheckShowToast() { if (castHandler.hasMessages(HomeHandler.SHOW_SIMPLE_TOAST)) { castHandler.removeMessages(HomeHandler.SHOW_SIMPLE_TOAST) } } Handler 에 Message를 보내는 Method 알아보기 boolean sendEmptyMessage(int what) : What 멤버만 채워진 Message 객체 전달 boolean sendEmptyMessageAtTime(int what, long upTimeMillies) : upTimeMillies에 지정된 시간에 what 멤머반 채워진 Message를 보냄 boolean sendEmptyMessageDelayed(int what, long delayMillies) : 현재 시간에서 delayMillies 만큼의 시간 후에 what 멤버만 채워진 Message 전달 boolean sendMessage(Message msg) : Message객체 전달, MessageQueue의 가장 마지막에 Message 추가(Queue 형식) boolean sendMessageAtFrontOfQueue(Message msg) : Message 객체 전달, MessageQueue의 가장 처음 위치에 Message 추가 boolean sendMessageAtTime(Message msg, long upTimeMillies) : upTimeMillies에 지정된 시간에 Message 객체 전달 boolean sendMessageDelayed(Message msg, long delayMillis) : 현재 시작에서 delayMillies 만큼의 시간 후에 Message 객체 전달마치며..이번 포스팅에서는 Looper와 Handler에 대하여 알아보았습니다.간단하게 요약하자면 Thread간 통신을 위해 Looper와 Handler를 사용한다고 이해하시면 될 것 같습니다.다음에는 Android Process 및 Thread 에 대하여 알보는 시간을 갖도록 하겠습니다." }, { "title": "자료구조 스택 Stack, 큐 Queue 에 대하여", "url": "/posts/Data-Structure-Stack-Queue/", "categories": "DataStructure", "tags": "stack, queue, data structure", "date": "2022-07-14 10:02:00 +0900", "snippet": "저는 비전공 개발자입니다.다른 직종의 회사에서 근무하면서 퇴근 후 독학으로 Android 개발을 시작하였습니다.독학 9개월차에 한 기업에 입사지원을 하게 되었고 그 기업의 면접에서 나왔던 질문이 Stack과 Queue였습니다.기초가 부족했던 저는 해당 질문에 답을 하지 못하였습니다. 그럼에도 결국 취업은 하였지만..저와 같은 길을 걷는 분들께 작은 도움이 되고 싶어 해당 포스팅을 작성합니다.본 포스팅은 Java 의 Stack과 Queue를 중심으로 설명합니다.매우 기초적인 부분을 설명드릴 것 이므로 더욱 자세한 정보를 원하시면 구글링을 추천드립니다.그럼 자료구조 Stack과 Queue에 대하여 알아보겠습니다.Stack (Last In First Out) Stack의 입출력 순서는 LIFO(Last In First Out) 즉, “후입선출” 방식입니다. 위의 그림을 보시면 이해가 편하실 겁니다. Push는 “삽입” Pop은 “삭제”라고 보시면 되겠습니다. 간단하게 “처음 들어온 것이 마지막으로 나간다.” 라고 생각하시면 됩니다. 데이터를 임시 저장할 때 사용합니다.Stack 의 Method push(E item) [삽입] : 파라미터로 들어오는 요소를 해당 Stack의 제일 상단에 “삽입”합니다. Object pop() [추출, 제거] : 해당 Stack의 제일 상단에 있는(제일 마지막으로 저장된) 요소를 반환하고, 해당 요소를 Stack에서 “제거”합니다. boolean empty() : 해당 Stack이 비어있으면 true, 비어있지 않으면 false를 반환합니다. 즉, Stack이 비어있는지 유무를 확인합니다. Object peek() [추출] : 해당 Stack의 제일 상단에 있는(제일 마지막으로 저장된) 요소를 반환합니다.(Pop() 처럼 반환 후 제거하지 않습니다.) int search(Object o) [찾기] : 해당 Stack에서 파라미터로 들어오는 객체가 존재하는 위치의 Index를 반환합니다. 이때, Index는 제일 상단에 있는(제일 마지막으로 저장된) 요소의 위치부터 0이 아닌 1부터 시작합니다. 사용 사례 -&gt; 웹 브라우저 방문 기록(뒤로가기), 실행 취소, 후위 표기법 계산특히 뒤로가기를 생각하시면 이해가 쉽습니다. 뒤로가기 시 제일 마지막에 띄웠던 브라우저부터 순서대로 나오게 됩니다. Queue (First In First Out) Queue의 입출력 순서는 FIFO(First In First Out) 즉, “선입선출” 방식입니다. 위의 그림을 보시면 이해가 편합니다. 간단하게 “처음 들어온 것이 처음 나간다.” 라고 생각하시면 됩니다. Stack과 마찬가지로 데이터를 임시 저장할 때 사용합니다. 가장 첫 번째 요소와 제일 끝 원소로만 접근이 가능합니다.Queue 의 Method boolean add(E e) : 해당 Queue의 맨 뒤에 요소를 삽입합니다. 삽입이 성공하면 “ture”, Queue에 여유공간이 없어 삽입에 실패하면 “IllegalStateException” 을 발생 시킵니다. E element() : 해당 Queue의 맨 앞에 있는(제일 먼저 저장된) 요소를 반환하고, 해당 요소를 “제거”합니다. boolean offer(E e) : 그림의 enqueue의 역할과 같으며, 해당 Queue의 맨 뒤에 요소를 삽입합니다. 삽입이 성공하면 “true”, Queue에 여유공간이 없어 삽입에 실패하면 IllegalStateException이 아닌 “false”를 반환합니다. E peek() : 해당 Queue의 맨 앞에 있는(제일 먼저 저장된) 요소를 반환하고, Queue가 비어있는 경우 Null을 반환합니다. (해당 요소를 Queue에서 제거하지 않습니다.) E poll() : 해당 Queue의 맨 앞에 있는(제일 먼저 저장된) 요소를 반환하고, Queue가 비어있는 경우 Null을 반환하며 “해당 요소를 Queue에서 제거”합니다. E remove() : 해당 Queue의 맨 앞에 있는(제일 먼저 저장된) 요소를 제거합니다. 사용 사례 -&gt; 최근 사용 문서, 은행 업무, 콜센터 대기 시간, Buffer, Cache즉, 시간 순서대로 처리할 필요가 있을 때 주로 사용한다. 마치며..지금까지 자료구조 Stack과 Queue에 대하여 알아보았습니다.도움이 되셨길 바라며 더 유용한 정보로 다시 찾아뵙겠습니다." }, { "title": "Android Fragment Lifecycle 생명주기 정리", "url": "/posts/Android-Fragment-Lifecycle/", "categories": "Android, Lifecycle", "tags": "android, fragment, lifecycle", "date": "2022-07-13 09:28:00 +0900", "snippet": "이전 Activity Lifecycle 정리 포스팅에 이어 이번에는 Fragment 의 Lifecycle에 대해 알아보겠습니다.🚩 Android Fragment Lifecycle 동작 순서이번에도 구글 공식 홈페이지에 나와있는 이미지를 바탕으로 살펴보겠습니다.해당 이미지를 참고하여 Fragment Lifecycle 의 순서를 보면 Fragment 생성시 onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onViewCreate() -&gt; onViewStateRestored() -&gt; onStart() -&gt; onResume() 순으로 Callbak이 호출되며, Fragment의 구성요소 변경 혹은 일부가 사라지면 onPause() -&gt; onStop() -&gt;onSaveInstanceState() -&gt; onDestroyView() -&gt; onDestroy() -&gt; onDetach() 순으로 Callback이 호출되어 onDetach() 이후로 Fragment가 완전이 소멸되고 Activity와의 연결이 끊어집니다.🚩 Fragment Lifecycle Callback Method 역할각 Callback Method 의 역할에 관하여 살펴보겠습니다.1. onAttach() Fragment가 Activity에 Attach 될때 호출된다. onAttach() 함수 인자로 context가 주어지기 때문에 부모 Activity에 접근이 가능하다.2. onCreate() Fragment 에서 필요한 Resource를 초기화 하는 곳 (Ui 관련 초기화는 할 수 없다.) Fragment가 생성되는 시점이다. View를 제외하고 Activity에서 전달된 값들을 받는 등 변수들을 초기화할때 사용한다.즉, Fragment를 생성하면서 넘겨준 값들이 있다면 여기서 변수에 넣어주면된다. Bundle 타입으로 saveInstanceState 파라미터가 함께 제공 된다.해당 파라미터는 Fragment가 처음 생성됐을때만 null로 넘어오며, onSaveInstanceState() 함수를 재정의 하지 않았더라도 그 이후 재생성부터는 non-null 값으로 넘어온다.3. onCreateView() Fragment와 xml을 연결하는 부분이다. onCreate() 이후에는 onCreateView() 와 onViewCreated() Callbak 함수가 이어서 호출된다. onCreateView() 의 반환값으로 정상적인 Fragment View 객체를 제공했을 때만 Fragment View 의 Lifecycle 이 생성된다. Fragment 와 xml 을 연결하는 작업만하고 View 의 Controll은 onViewCreated()에서 하는 것이 좋다.그 이유는 onCreateView()의 반환된 View 객체는 onViewCreated() 의 파라미터로 전달되고 이 시점 부터는 Fragment View 의 Lifecycle 이 INITIALIZED 상태로 업그데이트 됐기 때문이다. class HomeFragment : Fragment() { private lateinit var binding: FragmentHomeBinding override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = DataBindingUtil.inflate(inflater, layoutResId, container, false) return binding.root }} 4. onViewCreated() View 가 생성되면 호출된다. Fragment View 의 Lifecycle 이 INITIALIZED 상태로 업데이트 된다. Ui 관련 코드를 작성하는 곳으로 View 의 초기값을 설정해주거나 LiveData 옵저빙, StateFlow 옵저빙, Databinding, RecyclerView 또는 ViewPager2에 사용될 Adapter 세팅 등을 할 수 있다. override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.lifecycleOwner = viewLifecycleOwner // todo: Ui Update or LiveData Observing...} 5. onViewStateRestored() 저장해둔 모든 state 값이 Fragment 의 View 계층구조에 복원 됐을 때 호출된다. 이 시점의 Fragment View의 Lifecycle은 INITIALIZED 에서 **CREATED”” 상태로 변경되었음을 알린다.6. onStart() Fragment가 사용자에게 보여지기 직전에 호출된다. (사용자에게 Fragment가 보이도록 해줌) 이 시점부터는 Fragment의 child FragmentManager를 통해 FragmentTransaction을 안전하게 수행할 수 있다.7. onResume() Fragment가 비로서 보여지는 단계이다. Fragment가 보이는 상태에서 모든 Animator와 Transition 효과가 종료되고, Fragment가 사용자와 상호작용 할 수 있을 때 onResume()이 호출된다. Fragment가 다시 보여질 때 실행해야 할 코드를 넣으면 된다. ex) RecyclerView notifyDataSetChanged 등등 주의!! FragmentTransaction 을 통해 add 하는 경우에는 아래에 깔린 FirstFragment 의 Lifecycle 은 여전히 RESUME 상태이다. 8. onPause() 사용자와 상호작용을 중지한 상태이다. Fragment의 일부가 사라지면 호출된다. 부모 Activity가 아닌 다른 Activity가 위로 올라오거나, 다른 Fragment가 Add되는 경우 onPause() 즉, 일시정지 상태로 들어간다. UI 관련 코드를 정지하고, 중요한 데이터를 저장 주의!! Fragment 와 View의 Lifecycle 이 PAUSED 가 아닌 STARTED 가 된다. 9. onStop() Fragment가 완전히 사라지면 호출된다. (완전한 정지) Fragment가 더 이상 화면에 보여지지 않게되면 Fragment와 View의 Lifecycle은 CREATED 상태가 되고, onStop() Callback 함수가 호출된다.10. onDestroyView() Fragment와 관련된 View가 제거될때 호출된다. 모든 exit animation 과 transition이 완료되고, Fragment가 화면으로부터 벗어났을 경우 Fragment View 의 Lifecycle 은 DESTROYED가 된다. 이 시점부터는 getViewLifecycleOwnerLiveData() 의 리턴값으로 null 이 반환된다. Activity에서 Fragment를 생성했을 당시 addToBackStack()을 요청했을 경우 onDestroy()를 호출하지 않고, 인스턴스가 저장되어 있다가 Fragment를 다시 부를 때 onCreateView()를 실행하여 다시 화면에 보여지게 한다. 주의!! 해당 시점에서는 Garbage collection에 의해 수거될 수 있도록 Fragment View에 대한 모든 참조가 제거되어야 한다. 11. onDestroy() Fragment 가 제거되거나 FragmentManager가 destory 됐을 경우, Fragment의 Lifecycle은 DESTROYED 상태가 되고, onDestroy() 콜백 함수가 호출된다. View가 제거된 후 Fragment 가 완전히 소멸되기 전에 호출된다.12. onDetach() Fragment가 완전히 소멸되고 Activity와의 연결도 끊어질 때 호출된다.🚩 onResume() 이후에 홈 버튼을 누를 경우 onResume() 이후부터 홈 버튼을 누르면 Fragment의 Lifecycle 은 onPause() -&gt; onStop() -&gt; onSaveInstanceState() 까지만 호출되고, onDestroyView()부터 그 이후의 Lifecycle Callback은 호출되지 않습니다. 또한 홈에서 다시 해당 Fragment로 돌아오는 경우 onResume()이 호출됩니다. 즉, onResume() -&gt; 홈 버튼 클릭 -&gt; onPause() -&gt; onStop() -&gt; onSaveInstanceState() -&gt; 다시 해당 Fragment로 넘어옴 -&gt; onResume() 🚩 Jetpack Navigation Jetpack Navigation의 경우 Replace 형식으로 동작합니다. ‘A’Fragment 위에 ‘B’Fragment가 올라오는 경우 Lifecycle 👇 ‘A’ Fragment는 onDestroyView()까지만 호출되고 onDestroy(), onDetach()는 호출되지 않습니다. ‘B’ Fragment가 종료되면 ‘A’ Fragment는 onCreateView() -&gt; onViewCreated() -&gt; onViewStateRestored() -&gt; onStart() -&gt; onResume() 순으로 호출됩니다. 즉, ‘A’Fragment의 onAttach() 와 onCreate() 는 호출되지 않습니다. 마지며..Fragment는 Add 와 replace 방식이 있는데 동작하는 방식이 다릅니다. 저는 요즘 개발할때 androidx jetpack navigation component를 사용하여 Single Activity로 개발합니다. 현재 재직중인 회사 또한 Single Activity를 사용중이며, navigation component를 사용하면 fragment 간 전환이 매우 편리해집니다. 물론 navigation의 단점 또한 존재합니다. navigation component에 관해서는 추후 포스팅을 따로 올려 다뤄보도록 하겠습니다.Activity Lifecycle 정리" }, { "title": "Android Activity Lifecycle 생명주기 정리", "url": "/posts/Android-Activity-Lifecycle/", "categories": "Android, Lifecycle", "tags": "android, activity, lifecycle", "date": "2022-07-13 09:28:00 +0900", "snippet": "Android Activity Lifecycle 동작 순서구글 공식 홈페이지에 나와있는 이미지를 참고하시면 이해가 쉽습니다.해당 이미지를 참고하여 Activity Lifecycle 의 순서를 보면 Activity 생성 시 onCreate() -&gt; onStart() -&gt; onResume() 의 순서로 콜백이 실행 되며 Activity의 구성요소 혹은 일부가 사라지면 onPause() -&gt; onStop() -&gt; onDestory() 순으로 콜백이 실행되며 onDestory() 이후에 Activity가 종료됩니다. 참고 👉 Activity가 중지(onStop())상태에서 다시 화면에 보여지면 Lifecycycle은 어떻게 될까요?? ✅ onRestart() -&gt; onStart() -&gt; onResume() -&gt; ActivityRunning 순으로 실행됩니다. Activity가 onDestory()를 타지않고 onStop()에서 다시 보여진다면 onCreate()가 호출되지 않고 onRestart()가 호출 된다는 점 꼭 기억해주세요!! 🍀 Activity Lifecycle Callback Method 역할각 Callback Method 의 역할에 관하여 살펴보겠습니다.☘️ 1. onCreate() Activity가 실행되면 제일 처음 호출되는 메서드입니다. View 관련 처리는 해당 메서드에서 진행합니다. (click Listenr, data binding 등등..) onCreate 에는 saveInstanceState 즉 bundle를 매개변수로 가지고 있습니다. 해당 프로퍼티는 처음 생성된 경우 null을 담고있고, onSaveInstanceState() 함수를 통해 인스턴스 상태를 저장한 경우 saveInstanceState를 통해 상태값을 받아 처리할 수 있습니다.class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(saveInstanceState: Bundle?) { binding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.lifecycleOwner = this // todo View 세팅 (Adapter 세팅, ClickListener 연결 등등..) }}☘️ 2. onStart() Activity 가 onCreate()를 호출한 뒤 Activity가 ‘STARTED’ 상태에 진입하게 되면즉, Activity가 화면에 보이기 바로 직전에 호출됩니다. 이 메서드가 호출되면 Activity가 사용자와 상호작용할 수 있도록 준비합니다.☘️ 3. onResume() Activity가 onStart()를 호출한 뒤 Activity가 ‘RESUME’ 상태에 진입하게 되면 호출됩니다. 사용자와 상호작용을 할 수 있는 상태가 됩니다. ⚠️주의⚠️ 전화가 오거나, 화면을 슬립하면 Activity의 lifecycle은 onPause()로 넘어갑니다.이때 다시 해당 Activity로 돌아오면 onCreate()가 호출되지 않고 onResume()이 다시 한번 호출됩니다.이런 경우 Activity가 다시 보여질때마다 필요한 코드를 입력하시면 됩니다. ☘️ 4. onPause() 사용자가 잠시 Activity를 떠났을 때 즉, 또 다른 Activity에 Focus를 뒀을 때 호출됩니다. ✅ 전화가 오는 경우, 멀티 윈도우 상 다른 앱에 Focus를 두는 경우 호출 이 메서드가 Return 하기 전에는 다음 Activity가 시작될 수 없습니다. 따라서 이 작업은 매우 빨리 수행된 후 return 되어야 합니다. Activity가 onPause() 상태에 들어가면 System은 Activity를 강제 종료할 수 있습니다. Activity가 다시 시작되거나, 사용자에게 완전히 보여지지 않는 이상 Activity는 ‘PAUSED’ 상태에 머무르게 된다. ✅ onPause() 상태에서 다시 Activity가 보여지면 onCreate()를 타지않고 onRestart()를 호출 합니다. ⚠️주의⚠️ onPause()는 아주 잠깐 실행됩니다. 따라서 사용자 데이터 저장, 네트워크 호출, DB Transaction 등 시간이 오래걸리는 코드를 실행해서는 안 됩니다. ☘️ 5. onStop() Activity가 사용자에게 더 이상 보이지 않을 때 Activity는 ‘STOPPED’ 상태에 진입하고 onStop()을 호출합니다. ✅ Activity가 소멸하거나 다른 Activity가 화면을 가릴 때 호출됩니다. 이 메서드에서는 필요하지 않는 리소스를 해제해야 하고(애니메이션 일시중지 등등..), 사용자의 데이터 저장, 네트워크 호출, DB Transaction 등 시간이 오래걸리는 작업 또한 가능 합니다. Activity가 onStop() 상태에 들어가면 System은 Activity를 강제 종료할 수 있습니다. ⚠️주의⚠️ 만약 onStop() 상태에서 Activity가 다시 보여진다면 onCreate()는 호출되지 않고 onRestart() -&gt; onStart() -&gt; onResume() 순으로 호출됩니다. 예를 들어 화면을 잠그면 Activity는 onResume() 상태에서 onPause() -&gt; onStop()을 호출하고 잠금을 해제하면 onRestart() -&gt; onStart() -&gt; onResume() 순으로 호출됩니다. ☘️ 6. onDestory() Activity가 완전히 소멸되기 전에 호출됩니다. 이 메서드는 Activity가 받는 마지막 메서드 입니다. Activity가 앱에 의해 종료되거나(finish 메서드 호출), 화면 구성요소 변경(기기 회전 등..), System이 강제로 종료를 시키는 경우 호출될 수 있습니다. Activity가 onDestory() 상태에 들어가면 System 은 Activity를 강제로 종료할 수 있습니다. ⚠️주의⚠️ 만약 onDestory()가 호출되기까지 해제되지 않는 리소스가 있다면, 모두 여기서 해제해줘야 합니다. 그렇지 않으면 Memory Leak 즉, 메모리 누수의 위험이 있습니다. 🍀 번외☘️ 구성요소 변경시(화면 회전 등..) Activity 의 생명주기는?? 화면 회전 등 구성요소가 변경되면 Activity는 다음 순서로 lifecycle Callback Method를 호출합니다. 👇 onPause() -&gt; onStop() -&gt; onDestory() -&gt; onCreate() -&gt; onStart() -&gt; onResumse() 🛠 즉, 현재 Activity를 Destory 하고 새로 생성 하기 때문에 기존 데이터를 유지하기 위해서는 onSaveInstanceState()에서 Bundle에 데이터를 저장하도록 해야합니다.이러한 점 때문에 요즘 Android 개발에서는 AAC ViewModel 즉, Android Architecture Components ViewModel 을 사용하여 구성요소 변경시에도 데이터가 살아있도록 합니다. AAC ViewModel에 대한 개념은 다음에 따로 작성하겠습니다. ☘️ ‘A’ Activity 에서 ‘B’ Activity를 실행하는 경우 Activity의 생명주기는?? A -&gt; B Activity를 실행할 경우 Activity의 생명주기는 다음과 같습니다. 👇 'A' onPause() -&gt; 'B' onCreate() -&gt; 'B' onStart() -&gt; 'B' onResume() -&gt; 'A' onStop() -&gt; 'B'는 사용자에게 보여짐. 위의 상태에서 B Activity를 종료 즉, finish() 함수를 통해 종료하면 생명주기는 어떻게 될까요?? 👇 'B' onPause() -&gt; 'A' onRestart() -&gt; 'A' onStart() -&gt; 'A' onResume() -&gt; 'B' onStop() -&gt; 'B' onDestroy() -&gt; 'A'는 사용자에게 보여짐. 🍀 마치며..Activity Lifecycle 포스팅은 쓸데없는 설명은 최대한 자제하며 실용적인 의미의 내용만 담을려 노력하였습니다.긴 글 읽어주셔서 감사드리고 여러분께 꼭 도움이 되셨으면 합니다.다음 포스팅은 Fragment 의 Lifecycle 에 대하여 알아보고 정리하는 시간을 가지도록 하겠습니다." } ]
