<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Android Handler, Looper 에 관하여" /><meta name="author" content="Narvis2" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="이번에는 Handler, Looper 에 대해서 알아보도록 하겠습니다. Android의 UI 처리는 Single Thread Model로 동작합니다. 즉, mainThread가 아닌 다른 Thread에서 UI 를 Update하는 등의 행위를 하면 안됩니다. 따라서 mainThread를 UI Thread라고 부르기도 합니다. 동작의 무결성을 보장하기 위해 타 Thread에서는 UI를 건드릴 수 없고, 오로지 Main Thread에서만 UI 관련 동작을 할 수 있게끔 합니다.(MainThread를 제외한 다른 Thread에서 UI Update시 IOException이 발생합니다.) 이때 시간이 오래걸리는 작업을 MainThread에서 하게되면 UI가 멈추게 되는데(ANR) 이를 방지하기 위해 시간이 오래걸리는 작업은 다른 Thread에서 하고, 해당 결과를 Main Thread에 넘겨줘서 Main Thread에서 해당 결과 값을 바탕으로 UI를 Update합니다. Android에서는 UI Thread가 몇 초 이상 차단되면(현재는 약 5초) 사용자에게 Application Not Response(ANR) 이라는 대화 상자가 표시되고, 어플리케이션이 종료 되거나 불만족에 의해 제거 될 수 있습니다. 여기서 다른 Thread -&gt; Ui Thread 간에 결과값을 넘겨줄 때 통신을 위해서 즉, Thread 간의 통신을 위해 사용하는 것이 Handler 와 Looper 입니다. UI 반응성을 위해 UI Thread를 차단하지 않는 것이 매우 중요하며, UI Update를 제외하고 시간이 소요되는 작업은 반드시 별도의 Thread에서 수행해야 하는데 이 별도의 Thread를 Background Thread 또는 Worker Thread라고 합니다. 이번에도 실용적인 측면에 초점을 두고 다루겠습니다. 간단한 용어 설명 Thread, Main Thread Thread에 대해 간단히 설명드리면 “하나의 독립된 실행 흐름” 이라고 생각하시면 됩니다. mainThread는 하나의 프로그램이 실행될때 최초로 실행되는 Thread라고 생각하시면 됩니다." /><meta property="og:description" content="이번에는 Handler, Looper 에 대해서 알아보도록 하겠습니다. Android의 UI 처리는 Single Thread Model로 동작합니다. 즉, mainThread가 아닌 다른 Thread에서 UI 를 Update하는 등의 행위를 하면 안됩니다. 따라서 mainThread를 UI Thread라고 부르기도 합니다. 동작의 무결성을 보장하기 위해 타 Thread에서는 UI를 건드릴 수 없고, 오로지 Main Thread에서만 UI 관련 동작을 할 수 있게끔 합니다.(MainThread를 제외한 다른 Thread에서 UI Update시 IOException이 발생합니다.) 이때 시간이 오래걸리는 작업을 MainThread에서 하게되면 UI가 멈추게 되는데(ANR) 이를 방지하기 위해 시간이 오래걸리는 작업은 다른 Thread에서 하고, 해당 결과를 Main Thread에 넘겨줘서 Main Thread에서 해당 결과 값을 바탕으로 UI를 Update합니다. Android에서는 UI Thread가 몇 초 이상 차단되면(현재는 약 5초) 사용자에게 Application Not Response(ANR) 이라는 대화 상자가 표시되고, 어플리케이션이 종료 되거나 불만족에 의해 제거 될 수 있습니다. 여기서 다른 Thread -&gt; Ui Thread 간에 결과값을 넘겨줄 때 통신을 위해서 즉, Thread 간의 통신을 위해 사용하는 것이 Handler 와 Looper 입니다. UI 반응성을 위해 UI Thread를 차단하지 않는 것이 매우 중요하며, UI Update를 제외하고 시간이 소요되는 작업은 반드시 별도의 Thread에서 수행해야 하는데 이 별도의 Thread를 Background Thread 또는 Worker Thread라고 합니다. 이번에도 실용적인 측면에 초점을 두고 다루겠습니다. 간단한 용어 설명 Thread, Main Thread Thread에 대해 간단히 설명드리면 “하나의 독립된 실행 흐름” 이라고 생각하시면 됩니다. mainThread는 하나의 프로그램이 실행될때 최초로 실행되는 Thread라고 생각하시면 됩니다." /><link rel="canonical" href="https://narvis2.github.io/posts/Android-handler-looper/" /><meta property="og:url" content="https://narvis2.github.io/posts/Android-handler-looper/" /><meta property="og:site_name" content="Narvis2" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-14T11:44:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Android Handler, Looper 에 관하여" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Narvis2"},"dateModified":"2022-07-25T11:56:31+09:00","datePublished":"2022-07-14T11:44:00+09:00","description":"이번에는 Handler, Looper 에 대해서 알아보도록 하겠습니다. Android의 UI 처리는 Single Thread Model로 동작합니다. 즉, mainThread가 아닌 다른 Thread에서 UI 를 Update하는 등의 행위를 하면 안됩니다. 따라서 mainThread를 UI Thread라고 부르기도 합니다. 동작의 무결성을 보장하기 위해 타 Thread에서는 UI를 건드릴 수 없고, 오로지 Main Thread에서만 UI 관련 동작을 할 수 있게끔 합니다.(MainThread를 제외한 다른 Thread에서 UI Update시 IOException이 발생합니다.) 이때 시간이 오래걸리는 작업을 MainThread에서 하게되면 UI가 멈추게 되는데(ANR) 이를 방지하기 위해 시간이 오래걸리는 작업은 다른 Thread에서 하고, 해당 결과를 Main Thread에 넘겨줘서 Main Thread에서 해당 결과 값을 바탕으로 UI를 Update합니다. Android에서는 UI Thread가 몇 초 이상 차단되면(현재는 약 5초) 사용자에게 Application Not Response(ANR) 이라는 대화 상자가 표시되고, 어플리케이션이 종료 되거나 불만족에 의해 제거 될 수 있습니다. 여기서 다른 Thread -&gt; Ui Thread 간에 결과값을 넘겨줄 때 통신을 위해서 즉, Thread 간의 통신을 위해 사용하는 것이 Handler 와 Looper 입니다. UI 반응성을 위해 UI Thread를 차단하지 않는 것이 매우 중요하며, UI Update를 제외하고 시간이 소요되는 작업은 반드시 별도의 Thread에서 수행해야 하는데 이 별도의 Thread를 Background Thread 또는 Worker Thread라고 합니다. 이번에도 실용적인 측면에 초점을 두고 다루겠습니다. 간단한 용어 설명 Thread, Main Thread Thread에 대해 간단히 설명드리면 “하나의 독립된 실행 흐름” 이라고 생각하시면 됩니다. mainThread는 하나의 프로그램이 실행될때 최초로 실행되는 Thread라고 생각하시면 됩니다.","headline":"Android Handler, Looper 에 관하여","mainEntityOfPage":{"@type":"WebPage","@id":"https://narvis2.github.io/posts/Android-handler-looper/"},"url":"https://narvis2.github.io/posts/Android-handler-looper/"}</script><title>Android Handler, Looper 에 관하여 | Narvis2</title><link rel="android-chrome-192x192" sizes="192x192" href="/assets/img/favicons/android-chrome-192x192.png"><link rel="android-chrome-512x512" sizes="512x512" href="/assets/img/favicons/android-chrome-512x512.png"><link rel="mstile-150x150" sizes="150x150" href="/assets/img/favicons/mstile-150x150.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Narvis2"><meta name="application-name" content="Narvis2"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/main.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Narvis2</a></div><div class="site-subtitle font-italic">개발 일지</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/narvis2" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['narvis2','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>Android Handler, Looper 에 관하여</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Android Handler, Looper 에 관하여</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1657766640" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-07-14 </em> </span> <span> 업데이트 <em class="" data-ts="1658717791" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2022-07-25 </em> </span><div class="d-flex justify-content-between"> <span> By <em> narvis2 </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2521 단어"> <em>14 분</em>읽는 시간</span></div></div></div><div class="post-content"><p>이번에는 Handler, Looper 에 대해서 알아보도록 하겠습니다.<br /> Android의 UI 처리는 Single Thread Model로 동작합니다. 즉, mainThread가 아닌 다른 Thread에서 UI 를 Update하는 등의 행위를 하면 안됩니다. 따라서 mainThread를 UI Thread라고 부르기도 합니다.<br /> 동작의 무결성을 보장하기 위해 타 Thread에서는 UI를 건드릴 수 없고, 오로지 Main Thread에서만 UI 관련 동작을 할 수 있게끔 합니다.(MainThread를 제외한 다른 Thread에서 UI Update시 <strong><em>IOException</em></strong>이 발생합니다.)<br /> 이때 시간이 오래걸리는 작업을 MainThread에서 하게되면 UI가 멈추게 되는데(ANR) 이를 방지하기 위해 시간이 오래걸리는 작업은 다른 Thread에서 하고, 해당 결과를 Main Thread에 넘겨줘서 Main Thread에서 해당 결과 값을 바탕으로 UI를 Update합니다.</p><blockquote><p>Android에서는 UI Thread가 몇 초 이상 차단되면(현재는 약 5초) 사용자에게 Application Not Response(ANR) 이라는 대화 상자가 표시되고, 어플리케이션이 종료 되거나 불만족에 의해 제거 될 수 있습니다.</p></blockquote><p>여기서 다른 Thread -&gt; Ui Thread 간에 결과값을 넘겨줄 때 통신을 위해서 즉, Thread 간의 통신을 위해 사용하는 것이 Handler 와 Looper 입니다.</p><blockquote><p>UI 반응성을 위해 UI Thread를 차단하지 않는 것이 매우 중요하며, UI Update를 제외하고 시간이 소요되는 작업은 반드시 별도의 Thread에서 수행해야 하는데 이 별도의 Thread를 Background Thread 또는 Worker Thread라고 합니다.</p></blockquote><p>이번에도 실용적인 측면에 초점을 두고 다루겠습니다.</p><h2 id="간단한-용어-설명-thread-main-thread"><span class="mr-2">간단한 용어 설명 Thread, Main Thread</span><a href="#간단한-용어-설명-thread-main-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>Thread에 대해 간단히 설명드리면 “하나의 독립된 실행 흐름” 이라고 생각하시면 됩니다.<br /> mainThread는 하나의 프로그램이 실행될때 최초로 실행되는 Thread라고 생각하시면 됩니다.</p><h2 id="다른-thread---ui-thread에-access-하기-위해-제공하는-방식"><span class="mr-2">다른 Thread -&gt; UI Thread에 Access 하기 위해 제공하는 방식</span><a href="#다른-thread---ui-thread에-access-하기-위해-제공하는-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ol><li>Activity.runOnUiThread(Runnable)<li>View.post(Runnable)<li>View.postDelayed(Runnable, long)<li>위의 방법을 사용하기에 복잡한 작업은 Handler를 사용하여 UI Thread에서 전달받은 Message를 처리하는 방안을 고려해야 합니다.</ol><h2 id="looper"><span class="mr-2">Looper</span><a href="#looper" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ol><li>하나의 Thread 당 단 하나의 Looper만 가질 수 있습니다.<li>Android에선 기본적으로 MainActivity가 실행됨과 동시에 자동으로 Main Thread의 Looper가 돌기 시작합니다.<li>각 Thread의 Looper 내부에는 MessageQueue 라는 것이 존재하는데, 여기에는 해당 Thread가 처리해야 할 동작들이 <strong><em>‘Message’</em></strong> 라는 형태로 하나씩 쌓이게 됩니다. (큐 라는 이름에서 알 수 있듯 당연히 FIFO 방식이며 <strong><em>선입선출</em></strong> 방식으로 처리됩니다.)<blockquote><p><strong><em>Queue</em></strong>에 대해 모르시면 <a href="https://narvis2.github.io/posts/Data-Structure-Stack-Queue/">자료구조 Stack, Queue 정리</a> 포스팅을 참고 해주세요.</p></blockquote><li>MessageQueue가 비어있을 때는 아무런 동작도 하지 않다가 Message가 들어오면 Message를 꺼내 적절한 <strong><em>Handler</em></strong>로 전달합니다.<li>Thread에서 무한히 돌면서 자신이 속한 Thread의 MessageQueue에 Message나 Runnable이 들어오면 차례대로(선입선출) Handler에 전달하는 역할을 합니다.</ol><h2 id="message"><span class="mr-2">Message</span><a href="#message" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ol><li><strong><em>“하나의 작은 작업 단위”</em></strong>, <strong>MessageQueue</strong>에는 이러한 작은 작업 단위를 하나씩 적재해두고, <strong><em>“Looper”</em></strong>가 이를 차례대로 처리한다.<li><strong><em>Thread간 통신 할 내용을 담는 객체이자 MessageQueue의 일감 단위라고 생각하시면 됩니다.</em></strong><li><strong>Message</strong>는 <strong><em>Runnable</em></strong>, <strong><em>“Message”</em></strong> 2가지가 있습니다. Looper 객체가 MessageQueue에서 Message를 확인했을 때 Runnable 객체가 담겨져 있으면 Handler에 Message를 전달하지 않고 run()함수를 실행하여 해당 Runnable 작업을 바로 시작하고, Runnable 객체가 없을 경우 Message 객체 내부에 있는 Handler의 handleMessage()를 수행하여 처리합니다.<li><strong><em>Runnable</em></strong>은 Thread를 생성할때 생기는 run() 메서드를 따로 분리시킨 형태로 run() 추상 메서드를 반드시 구현해야합니다. run()함수 안에 실행될 동작이 들어갑니다.</ol><h2 id="handler"><span class="mr-2">Handler</span><a href="#handler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ol><li><strong><em>Looper</em></strong>로 부터 전달 받은 <strong><em>Message</em></strong> 나 <strong><em>Runnable</em></strong>을 <strong><em>handleMessage()</em></strong>를 통해 처리하거나 다른 <strong><em>Thread</em></strong>로 부터 받은 <strong><em>Message</em></strong>를 <strong><em>MessageQueue</em></strong>에 넣습니다.<li><strong><em>Handler</em></strong>를 생성하게되면 호출한 <strong><em>Thread</em></strong>의 <strong><em>MessageQueue</em></strong>와 <strong><em>Looper</em></strong>에 자동으로 연결됩니다.<li>Message 객체를 생성하여 이를 전달하는 방식으로 구현합니다.<li>sendMessage() 메소드를 통해 MessageQueue에 Message 객체를 적재할 수 있습니다.<li>post로 시작하는 메소드들을 통해 Runnable 객체를 직접 적재할 수 있습니다.<li>UI를 갱신하기 위해서 사용합니다.<blockquote><p><strong>주의!!</strong> Handler를 상속받아서 처리하는 모든 부분에서 UI가 Destory 즉, 파괴될때 handler.removeCallbacksAndMessages(null)을 호출해줘야 합니다.</p></blockquote></ol><h2 id="동작-방식"><span class="mr-2">동작 방식</span><a href="#동작-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ol><li>Handler 의 sendMessage()를 통해 MessageQueue에 Message를 차례대로 넣습니다.<li>Looper는 무한히 돌면서 자신이 속한 Thread의 MessageQueue에 Message나 Runnable이 들어오면 차례대로 하나씩 MessageQueue에서 Message를 꺼내 적절한 Handler에게 전달합니다.<li>Looper로 부터 Message를 전달받은 Handler는 handleMessage() 메서드를 통해 Message를 처리합니다.</ol><h2 id="코드를-통해-살펴보기"><span class="mr-2">코드를 통해 살펴보기</span><a href="#코드를-통해-살펴보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>간다한 코드를 통해 살펴 보겠습니다.</p><ol><li>Handler 생성 (Message를 받는 쪽) 코드 부터 살펴보겠습니다.<div class="language-kotlin highlighter-rouge"><div class="code-header"> <span data-label-text="Kotlin"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">HomeHandler</span><span class="p">(</span><span class="n">fragment</span><span class="p">:</span> <span class="nc">HomeFragment</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Handler</span><span class="p">(</span><span class="nc">Looper</span><span class="p">.</span><span class="nf">getMainLooper</span><span class="p">())</span> <span class="p">{</span>
 <span class="k">private</span> <span class="kd">val</span> <span class="py">weekReference</span><span class="p">:</span> <span class="nc">WeakReference</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span>

 <span class="k">override</span> <span class="k">fun</span> <span class="nf">handleMessage</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="nc">Message</span><span class="p">)</span> <span class="p">{</span>
     <span class="kd">val</span> <span class="py">fragment</span> <span class="p">=</span> <span class="n">weakReference</span><span class="p">.</span><span class="k">get</span><span class="p">()</span> <span class="k">as</span> <span class="nc">HomeFragment</span>

     <span class="c1">// HomeFragment 의 함수를 사용하기 위해 apply 사용 (연속적으로 접근 할때는 apply, with 등을 사용하는 것이 좋습니다.)</span>
     <span class="n">fragment</span><span class="p">.</span><span class="nf">apply</span> <span class="p">{</span> <span class="k">this</span><span class="p">:</span> <span class="nc">HomeFragment</span>
         <span class="k">when</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">what</span><span class="p">)</span> <span class="p">{</span>
             <span class="nc">FINISH_MAIN_ACTIVITY</span> <span class="p">-&gt;</span> <span class="p">{</span>
                 <span class="c1">// this 는 생략 가능 여기서는 알아보기 쉽게 명시적으로 선언</span>
                 <span class="c1">// 여기서는 간단하게 부모 Activity를 종료 시키도록 하였습니다.</span>
                 <span class="k">this</span><span class="p">.</span><span class="nf">finishActivity</span><span class="p">()</span>
             <span class="p">}</span>

             <span class="nc">SHOW_SIMPLE_TOAST</span> <span class="p">-&gt;</span> <span class="p">{</span>
                 <span class="c1">// this 는 생략 가능 여기서는 알아보기 쉽게 명시적으로 선언</span>
                 <span class="k">this</span><span class="p">.</span><span class="nf">showToast</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">obj</span><span class="o">?.</span><span class="nf">toString</span><span class="p">())</span>
             <span class="p">}</span>
             <span class="c1">// 등등..</span>
         <span class="p">}</span>
     <span class="p">}</span>
 <span class="p">}</span>

 <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
     <span class="c1">// 해당 변수로 Message를 구분합니다.</span>
     <span class="k">const</span> <span class="kd">val</span> <span class="py">FINISH_MAIN_ACTIVITY</span> <span class="p">=</span> <span class="mi">0</span>
     <span class="k">const</span> <span class="kd">val</span> <span class="py">SHOW_SIMPLE_TOAST</span> <span class="p">=</span> <span class="mi">1</span>
     <span class="c1">// 등등..</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>GC(Garbage Collector)는 “내가 다시 사용할 수 있냐, 없냐를 보고 없으면 쓰레기통에 버린다” 라고 생각하시면 편합니다.<br /> WeakReference : GC(Garbage Collector)가 발생되기 전까지는 참조를 유지하고 GC가 발생되면 무조건 회수 (짧은 시간, 자주 쓰일 수 있는 객체를 사용할때 유용하게 사용될 수 있음.)</p></blockquote><li>Message를 보내는 쪽 코드 (sendMessage()를 통해 Message 넣기)<div class="language-kotlin highlighter-rouge"><div class="code-header"> <span data-label-text="Kotlin"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="kd">val</span> <span class="py">homeHandler</span> <span class="p">=</span> <span class="nc">HomeHandler</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="c1">// 함수 이름은 대충 지었습니다.</span>
<span class="k">fun</span> <span class="nf">sendMainActivityFinish</span><span class="p">()</span> <span class="p">{</span>
 <span class="n">homeHandler</span><span class="p">.</span><span class="nf">obtainMessage</span><span class="p">().</span><span class="nf">apply</span> <span class="p">{</span> <span class="k">this</span><span class="p">:</span> <span class="nc">Message</span>
     <span class="n">what</span> <span class="p">=</span> <span class="nc">HomeHandler</span><span class="p">.</span><span class="nc">FINISH_MAIN_ACTIVITY</span>
     <span class="n">obj</span> <span class="p">=</span> <span class="s">"메인 엑티비티 종료"</span> <span class="c1">// 전달하고자 하는 객체 넣기 (여기서는 간단하게 String을 넣어줬습니다.)</span>
     <span class="n">homeHandler</span><span class="p">.</span><span class="nf">sendMessage</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">sendShowToast</span><span class="p">()</span> <span class="p">{</span>
 <span class="n">homeHandler</span><span class="p">.</span><span class="nf">obtainMessage</span><span class="p">().</span><span class="nf">apply</span> <span class="p">{</span> <span class="k">this</span><span class="p">:</span> <span class="nc">Message</span>
     <span class="n">what</span> <span class="p">=</span> <span class="nc">HomeHandler</span><span class="p">.</span><span class="nc">SHOW_SIMPLE_TOAST</span>
     <span class="n">obj</span> <span class="p">=</span> <span class="s">"안녕하세용"</span> <span class="c1">// 전달하고자 하는 객체 넣기 (여기서는 간단하게 String을 넣어줬습니다.)</span>
     <span class="n">homeHandler</span><span class="p">.</span><span class="nf">sendMessage</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>sendMessage()를 통해 Message를 MessageQueue에 넣습니다. 이렇게 되면 Handler는 Looper 로 Message를 전달하고 Looper는 MessageQueue로 부터 해당 Message를 꺼냅니다. 이때 위의 코드에서는 Runnable이 없기 때문에 HomeHandler에게 Message를 전달합니다. Looper로 부터 Message를 전달받은 HomeHandler는 handleMessage()를 통해 Message를 처리합니다.<br /> <strong><em>참고</em></strong> <u>obtainMessage()</u> : obtainMessage()는 Message 인스턴스를 생성합니다. 다만 정적으로 생성된 재사용 객체로 관리되기 때문에 new Message()로 인스턴스를 생성하는 것 보다 효율적 입니다.</p></blockquote><li>HomeFragment 의 handleMessage() 함수 내부에서 실행되는 HomeFragment의 함수<div class="language-kotlin highlighter-rouge"><div class="code-header"> <span data-label-text="Kotlin"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="c1">// HomeHandler 의 handleMessage() 에서 FINISH_MAIN_ACTIVITY 일때 호출하는 함수</span>
 <span class="k">fun</span> <span class="nf">activityFinish</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">activity</span><span class="p">.</span><span class="nf">finish</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="c1">// HomeHandler 의 handleMessage() 에서 SHOW_SIMPLE_TOAST 일때 호출하는 함수</span>
 <span class="k">fun</span> <span class="nf">showToast</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
     <span class="nc">Toast</span><span class="p">.</span><span class="nf">makeText</span><span class="p">(</span><span class="nf">requireContext</span><span class="p">(),</span> <span class="n">msg</span><span class="p">,</span> <span class="nc">Toast</span><span class="p">.</span><span class="nc">LENGTH_SHORT</span><span class="p">).</span><span class="nf">show</span><span class="p">()</span>
 <span class="p">}</span>
</pre></table></code></div></div><li>UI 가 Destory 될 때 handler 제거하는 코드<div class="language-kotlin highlighter-rouge"><div class="code-header"> <span data-label-text="Kotlin"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="k">override</span> <span class="k">fun</span> <span class="nf">onDestoryView</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">castHandler</span><span class="p">.</span><span class="nf">removeCallbacksAndMessages</span><span class="p">(</span><span class="k">null</span><span class="p">)</span>
     <span class="k">super</span><span class="p">.</span><span class="nf">onDestoryView</span><span class="p">()</span>
 <span class="p">}</span>
</pre></table></code></div></div><blockquote><p>Activity의 경우 onDestory() 에서 하시면 됩니다.<br /> <strong>주의!!</strong> UI 가 Destory 될 때 remove 해주지 않으면 IllegalStateException이 발생할 수 있습니다.</p></blockquote><li>Handler가 해당 Message를 가지고 있는지 확인하고 존재하면 제거하는 코드<div class="language-kotlin highlighter-rouge"><div class="code-header"> <span data-label-text="Kotlin"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="k">private</span> <span class="k">fun</span> <span class="nf">removeCheckShowToast</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">castHandler</span><span class="p">.</span><span class="nf">hasMessages</span><span class="p">(</span><span class="nc">HomeHandler</span><span class="p">.</span><span class="nc">SHOW_SIMPLE_TOAST</span><span class="p">))</span> <span class="p">{</span>
         <span class="n">castHandler</span><span class="p">.</span><span class="nf">removeMessages</span><span class="p">(</span><span class="nc">HomeHandler</span><span class="p">.</span><span class="nc">SHOW_SIMPLE_TOAST</span><span class="p">)</span>
     <span class="p">}</span>
 <span class="p">}</span>
</pre></table></code></div></div></ol><h2 id="handler-에-message를-보내는-method-알아보기"><span class="mr-2">Handler 에 Message를 보내는 Method 알아보기</span><a href="#handler-에-message를-보내는-method-알아보기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>boolean sendEmptyMessage(int what) : What 멤버만 채워진 Message 객체 전달<li>boolean sendEmptyMessageAtTime(int what, long upTimeMillies) : upTimeMillies에 지정된 시간에 what 멤머반 채워진 Message를 보냄<li>boolean sendEmptyMessageDelayed(int what, long delayMillies) : 현재 시간에서 delayMillies 만큼의 시간 후에 what 멤버만 채워진 Message 전달<li>boolean sendMessage(Message msg) : Message객체 전달, MessageQueue의 가장 마지막에 Message 추가(Queue 형식)<li>boolean sendMessageAtFrontOfQueue(Message msg) : Message 객체 전달, MessageQueue의 가장 처음 위치에 Message 추가<li>boolean sendMessageAtTime(Message msg, long upTimeMillies) : upTimeMillies에 지정된 시간에 Message 객체 전달<li>boolean sendMessageDelayed(Message msg, long delayMillis) : 현재 시작에서 delayMillies 만큼의 시간 후에 Message 객체 전달</ul><h2 id="마치며"><span class="mr-2">마치며..</span><a href="#마치며" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p>이번 포스팅에서는 Looper와 Handler에 대하여 알아보았습니다.<br /> 간단하게 요약하자면 Thread간 통신을 위해 Looper와 Handler를 사용한다고 이해하시면 될 것 같습니다.<br /> 다음에는 <a href="https://narvis2.github.io/posts/Android-Process-Thread/">Android Process 및 Thread</a> 에 대하여 알보는 시간을 갖도록 하겠습니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>Android</a>, <a href='/categories/handler/'>Handler</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/android/" class="post-tag no-text-decoration" >android</a> <a href="/tags/thread/" class="post-tag no-text-decoration" >thread</a> <a href="/tags/handler/" class="post-tag no-text-decoration" >handler</a> <a href="/tags/looper/" class="post-tag no-text-decoration" >looper</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Android+Handler%2C+Looper+%EC%97%90+%EA%B4%80%ED%95%98%EC%97%AC+-+Narvis2&url=https%3A%2F%2Fnarvis2.github.io%2Fposts%2FAndroid-handler-looper%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Android+Handler%2C+Looper+%EC%97%90+%EA%B4%80%ED%95%98%EC%97%AC+-+Narvis2&u=https%3A%2F%2Fnarvis2.github.io%2Fposts%2FAndroid-handler-looper%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fnarvis2.github.io%2Fposts%2FAndroid-handler-looper%2F&text=Android+Handler%2C+Looper+%EC%97%90+%EA%B4%80%ED%95%98%EC%97%AC+-+Narvis2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/iOS-SwiftUi-ViewModel/">iOS SwiftUi ViewModel</a><li><a href="/posts/Android-Activity-Lifecycle/">Android Activity Lifecycle 생명주기 정리</a><li><a href="/posts/Javascript-Promise-Async-Await/">JavaScript 비동기 작업 Promise, async, await 알아보기</a><li><a href="/posts/iOS-Swift-Alamofire/">iOS SwiftUi Alamofire 기초</a><li><a href="/posts/iOS-Swift-Combine-Basic/">iOS SwiftUi Combine 기초</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/react-native/">react-native</a> <a class="post-tag" href="/tags/compose/">compose</a> <a class="post-tag" href="/tags/jetpack/">jetpack</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/redux/">redux</a> <a class="post-tag" href="/tags/typescript/">typescript</a> <a class="post-tag" href="/tags/uikit/">UIKit</a> <a class="post-tag" href="/tags/coroutine/">coroutine</a> <a class="post-tag" href="/tags/class/">class</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Android-Process-Thread/"><div class="card-body"> <em class="small" data-ts="1657779600" data-df="YYYY-MM-DD" > 2022-07-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android Process 및 Thread</h3><div class="text-muted small"><p> 이번 포스팅에서는 Android의 Process와 Thread에 대해서 알아보고자 합니다. 이번에는 설명이 많이 필요하여 지루하실 수 있습니다. 빠르게 시작해보겠습니다. Process 와 Thread 애플리케이션 구성 요소가 시작되고, 앱에 실행중인 다른 구성 요소가 없으면 하나의 실행 Thread로 앱의 Linux Process를 시작합니다. 기...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Activity-Lifecycle/"><div class="card-body"> <em class="small" data-ts="1657672080" data-df="YYYY-MM-DD" > 2022-07-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android Activity Lifecycle 생명주기 정리</h3><div class="text-muted small"><p> Android Activity Lifecycle 동작 순서 구글 공식 홈페이지에 나와있는 이미지를 참고하시면 이해가 쉽습니다. 해당 이미지를 참고하여 Activity Lifecycle 의 순서를 보면 Activity 생성 시 onCreate() -&amp;gt; onStart() -&amp;gt; onResume() 의 순서로 콜백이 실행 되며 Activity...</p></div></div></a></div><div class="card"> <a href="/posts/Android-Fragment-Lifecycle/"><div class="card-body"> <em class="small" data-ts="1657672080" data-df="YYYY-MM-DD" > 2022-07-13 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Android Fragment Lifecycle 생명주기 정리</h3><div class="text-muted small"><p> 이전 Activity Lifecycle 정리 포스팅에 이어 이번에는 Fragment 의 Lifecycle에 대해 알아보겠습니다. 🚩 Android Fragment Lifecycle 동작 순서 이번에도 구글 공식 홈페이지에 나와있는 이미지를 바탕으로 살펴보겠습니다. 해당 이미지를 참고하여 Fragment Lifecycle 의 순서를 보면 Fragme...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Data-Structure-Stack-Queue/" class="btn btn-outline-primary" prompt="이전 글"><p>자료구조 스택 Stack, 큐 Queue 에 대하여</p></a> <a href="/posts/Android-Process-Thread/" class="btn btn-outline-primary" prompt="다음 글"><p>Android Process 및 Thread</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/narvis2">narvis2</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/android/">android</a> <a class="post-tag" href="/tags/react-native/">react-native</a> <a class="post-tag" href="/tags/compose/">compose</a> <a class="post-tag" href="/tags/jetpack/">jetpack</a> <a class="post-tag" href="/tags/ios/">iOS</a> <a class="post-tag" href="/tags/redux/">redux</a> <a class="post-tag" href="/tags/typescript/">typescript</a> <a class="post-tag" href="/tags/uikit/">UIKit</a> <a class="post-tag" href="/tags/coroutine/">coroutine</a> <a class="post-tag" href="/tags/class/">class</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
